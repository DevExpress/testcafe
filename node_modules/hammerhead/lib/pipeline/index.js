'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator').default;

var _interopRequireWildcard = require('babel-runtime/helpers/interop-require-wildcard').default;

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default').default;

exports.__esModule = true;
exports.runPipeline = runPipeline;

var _resourceProcessing = require('../resource-processing');

var _errs = require('../errs');

var ERR = _interopRequireWildcard(_errs);

var _destinationRequest = require('./destination-request');

var _destinationRequest2 = _interopRequireDefault(_destinationRequest);

var _pipelineContext = require('./pipeline-context');

var _pipelineContext2 = _interopRequireDefault(_pipelineContext);

var _headerTransforms = require('./header-transforms');

var headerTransforms = _interopRequireWildcard(_headerTransforms);

var _connectionReset = require('./connection-reset');

var _sameOriginPolicy = require('./same-origin-policy');

var _utilsHttp = require('../utils/http');

var _upload = require('../upload');

// Stages
var stages = {
    0: function fetchProxyRequestBody(ctx, next) {
        return _regeneratorRuntime.async(function fetchProxyRequestBody$(context$1$0) {
            while (1) switch (context$1$0.prev = context$1$0.next) {
                case 0:
                    context$1$0.next = 2;
                    return (0, _utilsHttp.fetchBody)(ctx.req);

                case 2:
                    ctx.reqBody = context$1$0.sent;

                    next();

                case 4:
                case 'end':
                    return context$1$0.stop();
            }
        }, null, this);
    },

    1: function sendDestinationRequest(ctx, next) {
        var opts = createReqOpts(ctx);
        var req = new _destinationRequest2.default(opts);

        req.on('response', function (res) {
            ctx.destRes = res;
            next();
        });

        req.on('error', function () {
            return ctx.hasDestReqErr = true;
        });
        req.on('fatalError', function (err) {
            return error(ctx, err);
        });
    },

    2: function checkSameOriginPolicyCompliance(ctx, next) {
        if (ctx.isXhr && !(0, _sameOriginPolicy.check)(ctx)) {
            ctx.closeWithError(0);
            return;
        }

        next();
    },

    3: function decideOnProcessingStrategy(ctx, next) {
        ctx.buildContentInfo();

        //NOTE: just pipe body to browser if we don't need to process content body
        if (!ctx.contentInfo.requireProcessing) {
            sendResponseHeaders(ctx);
            ctx.destRes.pipe(ctx.res);
            return;
        }

        next();
    },

    4: function fetchContent(ctx, next) {
        return _regeneratorRuntime.async(function fetchContent$(context$1$0) {
            while (1) switch (context$1$0.prev = context$1$0.next) {
                case 0:
                    context$1$0.next = 2;
                    return (0, _utilsHttp.fetchBody)(ctx.destRes);

                case 2:
                    ctx.destResBody = context$1$0.sent;

                    if (!(ctx.hasDestReqErr && isDestResBodyMalformed(ctx))) {
                        context$1$0.next = 6;
                        break;
                    }

                    error({
                        code: ERR.PROXY_ORIGIN_SERVER_CONNECTION_TERMINATED,
                        destUrl: ctx.dest.url
                    });

                    return context$1$0.abrupt('return');

                case 6:

                    next();

                case 7:
                case 'end':
                    return context$1$0.stop();
            }
        }, null, this);
    },

    5: function processContent(ctx, next) {
        return _regeneratorRuntime.async(function processContent$(context$1$0) {
            while (1) switch (context$1$0.prev = context$1$0.next) {
                case 0:
                    context$1$0.prev = 0;
                    context$1$0.next = 3;
                    return (0, _resourceProcessing.process)(ctx);

                case 3:
                    ctx.destResBody = context$1$0.sent;

                    next();
                    context$1$0.next = 10;
                    break;

                case 7:
                    context$1$0.prev = 7;
                    context$1$0.t0 = context$1$0['catch'](0);

                    error(ctx, context$1$0.t0);

                case 10:
                case 'end':
                    return context$1$0.stop();
            }
        }, null, this, [[0, 7]]);
    },

    6: function sendProxyResponse(ctx) {
        sendResponseHeaders(ctx);

        (0, _connectionReset.handle)(function () {
            ctx.res.write(ctx.destResBody);
            ctx.res.end();
        });
    }
};

// Utils
function createReqOpts(ctx) {
    var bodyWithUploads = (0, _upload.inject)(ctx.req.headers['content-type'], ctx.reqBody);

    return {
        url: ctx.dest.url,
        protocol: ctx.dest.protocol,
        hostname: ctx.dest.hostname,
        host: ctx.dest.host,
        port: ctx.dest.port,
        path: ctx.dest.partAfterHost,
        method: ctx.req.method,
        headers: headerTransforms.forRequest(ctx, this),
        credentials: ctx.session.getAuthCredentials(),
        body: bodyWithUploads || ctx.reqBody
    };
}

function sendResponseHeaders(ctx) {
    var headers = headerTransforms.forResponse(ctx);

    ctx.res.writeHead(ctx.destRes.statusCode, headers);
    ctx.res.addTrailers(ctx.destRes.trailers);
}

function error(ctx, err) {
    if (ctx.isPage && !ctx.isIFrame) ctx.session.handlePageError(ctx, err);else ctx.closeWithError(500, err.toString());
}

function isDestResBodyMalformed(ctx) {
    return !ctx.destResBody || ctx.destResBody.length !== ctx.destRes.headers['content-length'];
}

// API

function runPipeline(req, res, serverInfo, openSessions) {
    var ctx = new _pipelineContext2.default(req, res, serverInfo);

    if (ctx.dispatch(openSessions)) {
        var stageIdx = 0;
        var next = function () {
            return stages[++stageIdx](ctx, next);
        };

        stages[0](ctx, next);
    } else (0, _utilsHttp.respond404)(res);
}

// NOTE: sometimes underlying socket emits error event.
// But if we have response body we can still process
// such requests. (See: B234324)
//# sourceMappingURL=../pipeline/index.js.map