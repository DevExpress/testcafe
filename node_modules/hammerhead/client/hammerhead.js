(function () {
    function initHammerheadClient(window, isIFrameWithoutSrc) {
        // NOTE: the following script will be executed in the current window context. But when you call a script in an iFrame
        // global vars are get from the top window. So, we should override the global vars that can have affect to our script.
        var document = window.document;
        var define = window.define;

        // This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"es6-promise": {
		":mainpath:": "dist/es6-promise.js",
		"dist": {
			"es6-promise.js": function (exports, module, require) {
				/*!
				 * @overview es6-promise - a tiny implementation of Promises/A+.
				 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
				 * @license   Licensed under MIT license
				 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
				 * @version   3.0.2
				 */

				(function () {
				  "use strict";
				  function lib$es6$promise$utils$$objectOrFunction(x) {
				    return typeof x === 'function' || typeof x === 'object' && x !== null;
				  }

				  function lib$es6$promise$utils$$isFunction(x) {
				    return typeof x === 'function';
				  }

				  function lib$es6$promise$utils$$isMaybeThenable(x) {
				    return typeof x === 'object' && x !== null;
				  }

				  var lib$es6$promise$utils$$_isArray;
				  if (!Array.isArray) {
				    lib$es6$promise$utils$$_isArray = function (x) {
				      return Object.prototype.toString.call(x) === '[object Array]';
				    };
				  } else {
				    lib$es6$promise$utils$$_isArray = Array.isArray;
				  }

				  var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;
				  var lib$es6$promise$asap$$len = 0;
				  var lib$es6$promise$asap$$toString = ({}).toString;
				  var lib$es6$promise$asap$$vertxNext;
				  var lib$es6$promise$asap$$customSchedulerFn;

				  var lib$es6$promise$asap$$asap = function asap(callback, arg) {
				    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;
				    lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;
				    lib$es6$promise$asap$$len += 2;
				    if (lib$es6$promise$asap$$len === 2) {
				      // If len is 2, that means that we need to schedule an async flush.
				      // If additional callbacks are queued before the queue is flushed, they
				      // will be processed by this flush that we are scheduling.
				      if (lib$es6$promise$asap$$customSchedulerFn) {
				        lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);
				      } else {
				        lib$es6$promise$asap$$scheduleFlush();
				      }
				    }
				  };

				  function lib$es6$promise$asap$$setScheduler(scheduleFn) {
				    lib$es6$promise$asap$$customSchedulerFn = scheduleFn;
				  }

				  function lib$es6$promise$asap$$setAsap(asapFn) {
				    lib$es6$promise$asap$$asap = asapFn;
				  }

				  var lib$es6$promise$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;
				  var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};
				  var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;
				  var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';

				  // test for web worker but not in IE10
				  var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

				  // node
				  function lib$es6$promise$asap$$useNextTick() {
				    // node version 0.10.x displays a deprecation warning when nextTick is used recursively
				    // see https://github.com/cujojs/when/issues/410 for details
				    return function () {
				      process.nextTick(lib$es6$promise$asap$$flush);
				    };
				  }

				  // vertx
				  function lib$es6$promise$asap$$useVertxTimer() {
				    return function () {
				      lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);
				    };
				  }

				  function lib$es6$promise$asap$$useMutationObserver() {
				    var iterations = 0;
				    var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);
				    var node = document.createTextNode('');
				    observer.observe(node, { characterData: true });

				    return function () {
				      node.data = iterations = ++iterations % 2;
				    };
				  }

				  // web worker
				  function lib$es6$promise$asap$$useMessageChannel() {
				    var channel = new MessageChannel();
				    channel.port1.onmessage = lib$es6$promise$asap$$flush;
				    return function () {
				      channel.port2.postMessage(0);
				    };
				  }

				  function lib$es6$promise$asap$$useSetTimeout() {
				    return function () {
				      setTimeout(lib$es6$promise$asap$$flush, 1);
				    };
				  }

				  var lib$es6$promise$asap$$queue = new Array(1000);
				  function lib$es6$promise$asap$$flush() {
				    for (var i = 0; i < lib$es6$promise$asap$$len; i += 2) {
				      var callback = lib$es6$promise$asap$$queue[i];
				      var arg = lib$es6$promise$asap$$queue[i + 1];

				      callback(arg);

				      lib$es6$promise$asap$$queue[i] = undefined;
				      lib$es6$promise$asap$$queue[i + 1] = undefined;
				    }

				    lib$es6$promise$asap$$len = 0;
				  }

				  function lib$es6$promise$asap$$attemptVertx() {
				    try {
				      var r = require;
				      var vertx = r('vertx');
				      lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;
				      return lib$es6$promise$asap$$useVertxTimer();
				    } catch (e) {
				      return lib$es6$promise$asap$$useSetTimeout();
				    }
				  }

				  var lib$es6$promise$asap$$scheduleFlush;
				  // Decide what async method to use to triggering processing of queued callbacks:
				  if (lib$es6$promise$asap$$isNode) {
				    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();
				  } else if (lib$es6$promise$asap$$BrowserMutationObserver) {
				    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();
				  } else if (lib$es6$promise$asap$$isWorker) {
				    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();
				  } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {
				    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();
				  } else {
				    lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();
				  }

				  function lib$es6$promise$$internal$$noop() {}

				  var lib$es6$promise$$internal$$PENDING = void 0;
				  var lib$es6$promise$$internal$$FULFILLED = 1;
				  var lib$es6$promise$$internal$$REJECTED = 2;

				  var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();

				  function lib$es6$promise$$internal$$selfFulfillment() {
				    return new TypeError("You cannot resolve a promise with itself");
				  }

				  function lib$es6$promise$$internal$$cannotReturnOwn() {
				    return new TypeError('A promises callback cannot return that same promise.');
				  }

				  function lib$es6$promise$$internal$$getThen(promise) {
				    try {
				      return promise.then;
				    } catch (error) {
				      lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;
				      return lib$es6$promise$$internal$$GET_THEN_ERROR;
				    }
				  }

				  function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
				    try {
				      then.call(value, fulfillmentHandler, rejectionHandler);
				    } catch (e) {
				      return e;
				    }
				  }

				  function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {
				    lib$es6$promise$asap$$asap(function (promise) {
				      var sealed = false;
				      var error = lib$es6$promise$$internal$$tryThen(then, thenable, function (value) {
				        if (sealed) {
				          return;
				        }
				        sealed = true;
				        if (thenable !== value) {
				          lib$es6$promise$$internal$$resolve(promise, value);
				        } else {
				          lib$es6$promise$$internal$$fulfill(promise, value);
				        }
				      }, function (reason) {
				        if (sealed) {
				          return;
				        }
				        sealed = true;

				        lib$es6$promise$$internal$$reject(promise, reason);
				      }, 'Settle: ' + (promise._label || ' unknown promise'));

				      if (!sealed && error) {
				        sealed = true;
				        lib$es6$promise$$internal$$reject(promise, error);
				      }
				    }, promise);
				  }

				  function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {
				    if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {
				      lib$es6$promise$$internal$$fulfill(promise, thenable._result);
				    } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {
				      lib$es6$promise$$internal$$reject(promise, thenable._result);
				    } else {
				      lib$es6$promise$$internal$$subscribe(thenable, undefined, function (value) {
				        lib$es6$promise$$internal$$resolve(promise, value);
				      }, function (reason) {
				        lib$es6$promise$$internal$$reject(promise, reason);
				      });
				    }
				  }

				  function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {
				    if (maybeThenable.constructor === promise.constructor) {
				      lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);
				    } else {
				      var then = lib$es6$promise$$internal$$getThen(maybeThenable);

				      if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {
				        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);
				      } else if (then === undefined) {
				        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
				      } else if (lib$es6$promise$utils$$isFunction(then)) {
				        lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);
				      } else {
				        lib$es6$promise$$internal$$fulfill(promise, maybeThenable);
				      }
				    }
				  }

				  function lib$es6$promise$$internal$$resolve(promise, value) {
				    if (promise === value) {
				      lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());
				    } else if (lib$es6$promise$utils$$objectOrFunction(value)) {
				      lib$es6$promise$$internal$$handleMaybeThenable(promise, value);
				    } else {
				      lib$es6$promise$$internal$$fulfill(promise, value);
				    }
				  }

				  function lib$es6$promise$$internal$$publishRejection(promise) {
				    if (promise._onerror) {
				      promise._onerror(promise._result);
				    }

				    lib$es6$promise$$internal$$publish(promise);
				  }

				  function lib$es6$promise$$internal$$fulfill(promise, value) {
				    if (promise._state !== lib$es6$promise$$internal$$PENDING) {
				      return;
				    }

				    promise._result = value;
				    promise._state = lib$es6$promise$$internal$$FULFILLED;

				    if (promise._subscribers.length !== 0) {
				      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);
				    }
				  }

				  function lib$es6$promise$$internal$$reject(promise, reason) {
				    if (promise._state !== lib$es6$promise$$internal$$PENDING) {
				      return;
				    }
				    promise._state = lib$es6$promise$$internal$$REJECTED;
				    promise._result = reason;

				    lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);
				  }

				  function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
				    var subscribers = parent._subscribers;
				    var length = subscribers.length;

				    parent._onerror = null;

				    subscribers[length] = child;
				    subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;
				    subscribers[length + lib$es6$promise$$internal$$REJECTED] = onRejection;

				    if (length === 0 && parent._state) {
				      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);
				    }
				  }

				  function lib$es6$promise$$internal$$publish(promise) {
				    var subscribers = promise._subscribers;
				    var settled = promise._state;

				    if (subscribers.length === 0) {
				      return;
				    }

				    var child,
				        callback,
				        detail = promise._result;

				    for (var i = 0; i < subscribers.length; i += 3) {
				      child = subscribers[i];
				      callback = subscribers[i + settled];

				      if (child) {
				        lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);
				      } else {
				        callback(detail);
				      }
				    }

				    promise._subscribers.length = 0;
				  }

				  function lib$es6$promise$$internal$$ErrorObject() {
				    this.error = null;
				  }

				  var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();

				  function lib$es6$promise$$internal$$tryCatch(callback, detail) {
				    try {
				      return callback(detail);
				    } catch (e) {
				      lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;
				      return lib$es6$promise$$internal$$TRY_CATCH_ERROR;
				    }
				  }

				  function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {
				    var hasCallback = lib$es6$promise$utils$$isFunction(callback),
				        value,
				        error,
				        succeeded,
				        failed;

				    if (hasCallback) {
				      value = lib$es6$promise$$internal$$tryCatch(callback, detail);

				      if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {
				        failed = true;
				        error = value.error;
				        value = null;
				      } else {
				        succeeded = true;
				      }

				      if (promise === value) {
				        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());
				        return;
				      }
				    } else {
				      value = detail;
				      succeeded = true;
				    }

				    if (promise._state !== lib$es6$promise$$internal$$PENDING) {
				      // noop
				    } else if (hasCallback && succeeded) {
				        lib$es6$promise$$internal$$resolve(promise, value);
				      } else if (failed) {
				        lib$es6$promise$$internal$$reject(promise, error);
				      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {
				        lib$es6$promise$$internal$$fulfill(promise, value);
				      } else if (settled === lib$es6$promise$$internal$$REJECTED) {
				        lib$es6$promise$$internal$$reject(promise, value);
				      }
				  }

				  function lib$es6$promise$$internal$$initializePromise(promise, resolver) {
				    try {
				      resolver(function resolvePromise(value) {
				        lib$es6$promise$$internal$$resolve(promise, value);
				      }, function rejectPromise(reason) {
				        lib$es6$promise$$internal$$reject(promise, reason);
				      });
				    } catch (e) {
				      lib$es6$promise$$internal$$reject(promise, e);
				    }
				  }

				  function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {
				    var enumerator = this;

				    enumerator._instanceConstructor = Constructor;
				    enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);

				    if (enumerator._validateInput(input)) {
				      enumerator._input = input;
				      enumerator.length = input.length;
				      enumerator._remaining = input.length;

				      enumerator._init();

				      if (enumerator.length === 0) {
				        lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
				      } else {
				        enumerator.length = enumerator.length || 0;
				        enumerator._enumerate();
				        if (enumerator._remaining === 0) {
				          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);
				        }
				      }
				    } else {
				      lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());
				    }
				  }

				  lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function (input) {
				    return lib$es6$promise$utils$$isArray(input);
				  };

				  lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function () {
				    return new Error('Array Methods must be provided an Array');
				  };

				  lib$es6$promise$enumerator$$Enumerator.prototype._init = function () {
				    this._result = new Array(this.length);
				  };

				  var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;

				  lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function () {
				    var enumerator = this;

				    var length = enumerator.length;
				    var promise = enumerator.promise;
				    var input = enumerator._input;

				    for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
				      enumerator._eachEntry(input[i], i);
				    }
				  };

				  lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {
				    var enumerator = this;
				    var c = enumerator._instanceConstructor;

				    if (lib$es6$promise$utils$$isMaybeThenable(entry)) {
				      if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {
				        entry._onerror = null;
				        enumerator._settledAt(entry._state, i, entry._result);
				      } else {
				        enumerator._willSettleAt(c.resolve(entry), i);
				      }
				    } else {
				      enumerator._remaining--;
				      enumerator._result[i] = entry;
				    }
				  };

				  lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {
				    var enumerator = this;
				    var promise = enumerator.promise;

				    if (promise._state === lib$es6$promise$$internal$$PENDING) {
				      enumerator._remaining--;

				      if (state === lib$es6$promise$$internal$$REJECTED) {
				        lib$es6$promise$$internal$$reject(promise, value);
				      } else {
				        enumerator._result[i] = value;
				      }
				    }

				    if (enumerator._remaining === 0) {
				      lib$es6$promise$$internal$$fulfill(promise, enumerator._result);
				    }
				  };

				  lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {
				    var enumerator = this;

				    lib$es6$promise$$internal$$subscribe(promise, undefined, function (value) {
				      enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);
				    }, function (reason) {
				      enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);
				    });
				  };
				  function lib$es6$promise$promise$all$$all(entries) {
				    return new lib$es6$promise$enumerator$$default(this, entries).promise;
				  }
				  var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;
				  function lib$es6$promise$promise$race$$race(entries) {
				    /*jshint validthis:true */
				    var Constructor = this;

				    var promise = new Constructor(lib$es6$promise$$internal$$noop);

				    if (!lib$es6$promise$utils$$isArray(entries)) {
				      lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
				      return promise;
				    }

				    var length = entries.length;

				    function onFulfillment(value) {
				      lib$es6$promise$$internal$$resolve(promise, value);
				    }

				    function onRejection(reason) {
				      lib$es6$promise$$internal$$reject(promise, reason);
				    }

				    for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {
				      lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
				    }

				    return promise;
				  }
				  var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;
				  function lib$es6$promise$promise$resolve$$resolve(object) {
				    /*jshint validthis:true */
				    var Constructor = this;

				    if (object && typeof object === 'object' && object.constructor === Constructor) {
				      return object;
				    }

				    var promise = new Constructor(lib$es6$promise$$internal$$noop);
				    lib$es6$promise$$internal$$resolve(promise, object);
				    return promise;
				  }
				  var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;
				  function lib$es6$promise$promise$reject$$reject(reason) {
				    /*jshint validthis:true */
				    var Constructor = this;
				    var promise = new Constructor(lib$es6$promise$$internal$$noop);
				    lib$es6$promise$$internal$$reject(promise, reason);
				    return promise;
				  }
				  var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;

				  var lib$es6$promise$promise$$counter = 0;

				  function lib$es6$promise$promise$$needsResolver() {
				    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
				  }

				  function lib$es6$promise$promise$$needsNew() {
				    throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
				  }

				  var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;
				  /**
				    Promise objects represent the eventual result of an asynchronous operation. The
				    primary way of interacting with a promise is through its `then` method, which
				    registers callbacks to receive either a promise's eventual value or the reason
				    why the promise cannot be fulfilled.
				     Terminology
				    -----------
				     - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
				    - `thenable` is an object or function that defines a `then` method.
				    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
				    - `exception` is a value that is thrown using the throw statement.
				    - `reason` is a value that indicates why a promise was rejected.
				    - `settled` the final resting state of a promise, fulfilled or rejected.
				     A promise can be in one of three states: pending, fulfilled, or rejected.
				     Promises that are fulfilled have a fulfillment value and are in the fulfilled
				    state.  Promises that are rejected have a rejection reason and are in the
				    rejected state.  A fulfillment value is never a thenable.
				     Promises can also be said to *resolve* a value.  If this value is also a
				    promise, then the original promise's settled state will match the value's
				    settled state.  So a promise that *resolves* a promise that rejects will
				    itself reject, and a promise that *resolves* a promise that fulfills will
				    itself fulfill.
				      Basic Usage:
				    ------------
				     ```js
				    var promise = new Promise(function(resolve, reject) {
				      // on success
				      resolve(value);
				       // on failure
				      reject(reason);
				    });
				     promise.then(function(value) {
				      // on fulfillment
				    }, function(reason) {
				      // on rejection
				    });
				    ```
				     Advanced Usage:
				    ---------------
				     Promises shine when abstracting away asynchronous interactions such as
				    `XMLHttpRequest`s.
				     ```js
				    function getJSON(url) {
				      return new Promise(function(resolve, reject){
				        var xhr = new XMLHttpRequest();
				         xhr.open('GET', url);
				        xhr.onreadystatechange = handler;
				        xhr.responseType = 'json';
				        xhr.setRequestHeader('Accept', 'application/json');
				        xhr.send();
				         function handler() {
				          if (this.readyState === this.DONE) {
				            if (this.status === 200) {
				              resolve(this.response);
				            } else {
				              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
				            }
				          }
				        };
				      });
				    }
				     getJSON('/posts.json').then(function(json) {
				      // on fulfillment
				    }, function(reason) {
				      // on rejection
				    });
				    ```
				     Unlike callbacks, promises are great composable primitives.
				     ```js
				    Promise.all([
				      getJSON('/posts'),
				      getJSON('/comments')
				    ]).then(function(values){
				      values[0] // => postsJSON
				      values[1] // => commentsJSON
				       return values;
				    });
				    ```
				     @class Promise
				    @param {function} resolver
				    Useful for tooling.
				    @constructor
				  */
				  function lib$es6$promise$promise$$Promise(resolver) {
				    this._id = lib$es6$promise$promise$$counter++;
				    this._state = undefined;
				    this._result = undefined;
				    this._subscribers = [];

				    if (lib$es6$promise$$internal$$noop !== resolver) {
				      if (!lib$es6$promise$utils$$isFunction(resolver)) {
				        lib$es6$promise$promise$$needsResolver();
				      }

				      if (!(this instanceof lib$es6$promise$promise$$Promise)) {
				        lib$es6$promise$promise$$needsNew();
				      }

				      lib$es6$promise$$internal$$initializePromise(this, resolver);
				    }
				  }

				  lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;
				  lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;
				  lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;
				  lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;
				  lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;
				  lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;
				  lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;

				  lib$es6$promise$promise$$Promise.prototype = {
				    constructor: lib$es6$promise$promise$$Promise,

				    /**
				      The primary way of interacting with a promise is through its `then` method,
				      which registers callbacks to receive either a promise's eventual value or the
				      reason why the promise cannot be fulfilled.
				       ```js
				      findUser().then(function(user){
				        // user is available
				      }, function(reason){
				        // user is unavailable, and you are given the reason why
				      });
				      ```
				       Chaining
				      --------
				       The return value of `then` is itself a promise.  This second, 'downstream'
				      promise is resolved with the return value of the first promise's fulfillment
				      or rejection handler, or rejected if the handler throws an exception.
				       ```js
				      findUser().then(function (user) {
				        return user.name;
				      }, function (reason) {
				        return 'default name';
				      }).then(function (userName) {
				        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
				        // will be `'default name'`
				      });
				       findUser().then(function (user) {
				        throw new Error('Found user, but still unhappy');
				      }, function (reason) {
				        throw new Error('`findUser` rejected and we're unhappy');
				      }).then(function (value) {
				        // never reached
				      }, function (reason) {
				        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
				        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
				      });
				      ```
				      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
				       ```js
				      findUser().then(function (user) {
				        throw new PedagogicalException('Upstream error');
				      }).then(function (value) {
				        // never reached
				      }).then(function (value) {
				        // never reached
				      }, function (reason) {
				        // The `PedgagocialException` is propagated all the way down to here
				      });
				      ```
				       Assimilation
				      ------------
				       Sometimes the value you want to propagate to a downstream promise can only be
				      retrieved asynchronously. This can be achieved by returning a promise in the
				      fulfillment or rejection handler. The downstream promise will then be pending
				      until the returned promise is settled. This is called *assimilation*.
				       ```js
				      findUser().then(function (user) {
				        return findCommentsByAuthor(user);
				      }).then(function (comments) {
				        // The user's comments are now available
				      });
				      ```
				       If the assimliated promise rejects, then the downstream promise will also reject.
				       ```js
				      findUser().then(function (user) {
				        return findCommentsByAuthor(user);
				      }).then(function (comments) {
				        // If `findCommentsByAuthor` fulfills, we'll have the value here
				      }, function (reason) {
				        // If `findCommentsByAuthor` rejects, we'll have the reason here
				      });
				      ```
				       Simple Example
				      --------------
				       Synchronous Example
				       ```javascript
				      var result;
				       try {
				        result = findResult();
				        // success
				      } catch(reason) {
				        // failure
				      }
				      ```
				       Errback Example
				       ```js
				      findResult(function(result, err){
				        if (err) {
				          // failure
				        } else {
				          // success
				        }
				      });
				      ```
				       Promise Example;
				       ```javascript
				      findResult().then(function(result){
				        // success
				      }, function(reason){
				        // failure
				      });
				      ```
				       Advanced Example
				      --------------
				       Synchronous Example
				       ```javascript
				      var author, books;
				       try {
				        author = findAuthor();
				        books  = findBooksByAuthor(author);
				        // success
				      } catch(reason) {
				        // failure
				      }
				      ```
				       Errback Example
				       ```js
				       function foundBooks(books) {
				       }
				       function failure(reason) {
				       }
				       findAuthor(function(author, err){
				        if (err) {
				          failure(err);
				          // failure
				        } else {
				          try {
				            findBoooksByAuthor(author, function(books, err) {
				              if (err) {
				                failure(err);
				              } else {
				                try {
				                  foundBooks(books);
				                } catch(reason) {
				                  failure(reason);
				                }
				              }
				            });
				          } catch(error) {
				            failure(err);
				          }
				          // success
				        }
				      });
				      ```
				       Promise Example;
				       ```javascript
				      findAuthor().
				        then(findBooksByAuthor).
				        then(function(books){
				          // found books
				      }).catch(function(reason){
				        // something went wrong
				      });
				      ```
				       @method then
				      @param {Function} onFulfilled
				      @param {Function} onRejected
				      Useful for tooling.
				      @return {Promise}
				    */
				    then: function (onFulfillment, onRejection) {
				      var parent = this;
				      var state = parent._state;

				      if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {
				        return this;
				      }

				      var child = new this.constructor(lib$es6$promise$$internal$$noop);
				      var result = parent._result;

				      if (state) {
				        var callback = arguments[state - 1];
				        lib$es6$promise$asap$$asap(function () {
				          lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);
				        });
				      } else {
				        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);
				      }

				      return child;
				    },

				    /**
				      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
				      as the catch block of a try/catch statement.
				       ```js
				      function findAuthor(){
				        throw new Error('couldn't find that author');
				      }
				       // synchronous
				      try {
				        findAuthor();
				      } catch(reason) {
				        // something went wrong
				      }
				       // async with promises
				      findAuthor().catch(function(reason){
				        // something went wrong
				      });
				      ```
				       @method catch
				      @param {Function} onRejection
				      Useful for tooling.
				      @return {Promise}
				    */
				    'catch': function (onRejection) {
				      return this.then(null, onRejection);
				    }
				  };
				  function lib$es6$promise$polyfill$$polyfill() {
				    var local;

				    if (typeof global !== 'undefined') {
				      local = global;
				    } else if (typeof self !== 'undefined') {
				      local = self;
				    } else {
				      try {
				        local = Function('return this')();
				      } catch (e) {
				        throw new Error('polyfill failed because global object is unavailable in this environment');
				      }
				    }

				    var P = local.Promise;

				    if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {
				      return;
				    }

				    local.Promise = lib$es6$promise$promise$$default;
				  }
				  var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;

				  var lib$es6$promise$umd$$ES6Promise = {
				    'Promise': lib$es6$promise$promise$$default,
				    'polyfill': lib$es6$promise$polyfill$$default
				  };

				  /* global define:true module:true window: true */
				  if (typeof define === 'function' && define['amd']) {
				    define(function () {
				      return lib$es6$promise$umd$$ES6Promise;
				    });
				  } else if (typeof module !== 'undefined' && module['exports']) {
				    module['exports'] = lib$es6$promise$umd$$ES6Promise;
				  } else if (typeof this !== 'undefined') {
				    this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;
				  }
				}).call(this);
			}
		}
	},
	"testcafe-hammerhead": {
		"src": {
			"client": {
				"dom-processor": {
					"client-dom-adapter.js": function (exports, module, require) {
						exports.__esModule = true;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

						function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

						var _utilsBrowser = require('../utils/browser');

						var _utilsDom = require('../utils/dom');

						var _sandboxesNativeMethods = require('../sandboxes/native-methods');

						var _sandboxesNativeMethods2 = _interopRequireDefault(_sandboxesNativeMethods);

						var _utilsEventEmitter = require('../utils/event-emitter');

						var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

						var _processingDomBaseDomAdapter = require('../../processing/dom/base-dom-adapter');

						var _processingDomBaseDomAdapter2 = _interopRequireDefault(_processingDomBaseDomAdapter);

						var _settings = require('../settings');

						var _settings2 = _interopRequireDefault(_settings);

						var _utilsUrl = require('../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var _const = require('../../const');

						var _const2 = _interopRequireDefault(_const);

						var ClientDomAdapter = (function (_BaseDomAdapter) {
						    _inherits(ClientDomAdapter, _BaseDomAdapter);

						    function ClientDomAdapter() {
						        _classCallCheck(this, ClientDomAdapter);

						        _BaseDomAdapter.apply(this, arguments);
						    }

						    ClientDomAdapter.prototype.getAttr = function getAttr(el, attr) {
						        return _sandboxesNativeMethods2.default.getAttribute.call(el, attr);
						    };

						    ClientDomAdapter.prototype.hasAttr = function hasAttr(el, attr) {
						        for (var i = 0; i < el.attributes.length; i++) {
						            if (el.attributes[i].name === attr) return true;
						        }

						        return false;
						    };

						    ClientDomAdapter.prototype.hasEventHandler = function hasEventHandler(el) {
						        var attrs = el.attributes;

						        for (var i = 0; i < attrs.length; i++) {
						            if (this.EVENTS.indexOf(attrs[i])) return true;
						        }

						        return false;
						    };

						    ClientDomAdapter.prototype.getTagName = function getTagName(el) {
						        return el.tagName;
						    };

						    ClientDomAdapter.prototype.setAttr = function setAttr(el, attr, value) {
						        return _sandboxesNativeMethods2.default.setAttribute.call(el, attr, value);
						    };

						    ClientDomAdapter.prototype.setScriptContent = function setScriptContent(script, content) {
						        script.text = content;
						    };

						    ClientDomAdapter.prototype.getScriptContent = function getScriptContent(script) {
						        return script.text;
						    };

						    ClientDomAdapter.prototype.getStyleContent = function getStyleContent(style) {
						        return style.innerHTML;
						    };

						    ClientDomAdapter.prototype.setStyleContent = function setStyleContent(style, content) {
						        style.innerHTML = content;
						    };

						    ClientDomAdapter.prototype.getElementForSelectorCheck = function getElementForSelectorCheck(el) {
						        if (_utilsBrowser.isIE9 && el.tagName.toLowerCase() === 'script') {
						            var clone = _sandboxesNativeMethods2.default.cloneNode.call(el, false);

						            clone.src = clone.innerHTML = '';

						            return clone;
						        }

						        return el;
						    };

						    ClientDomAdapter.prototype.needToProcessUrl = function needToProcessUrl() {
						        return true;
						    };

						    ClientDomAdapter.prototype.hasIFrameParent = function hasIFrameParent(el) {
						        try {
						            return window.top.document !== _utilsDom.findDocument(el);
						        } catch (e) {
						            return true;
						        }
						    };

						    ClientDomAdapter.prototype.attachEventEmitter = function attachEventEmitter(domProcessor) {
						        var eventEmitter = new _utilsEventEmitter2.default();

						        domProcessor.on = eventEmitter.on.bind(eventEmitter);
						        domProcessor.off = eventEmitter.off.bind(eventEmitter);
						        domProcessor.emit = eventEmitter.emit.bind(eventEmitter);
						    };

						    ClientDomAdapter.prototype.getCrossDomainPort = function getCrossDomainPort() {
						        return _settings2.default.get().CROSS_DOMAIN_PROXY_PORT;
						    };

						    ClientDomAdapter.prototype.getProxyUrl = function getProxyUrl() {
						        return _utilsUrl2.default.getProxyUrl.apply(_utilsUrl2.default, arguments);
						    };

						    ClientDomAdapter.prototype.isTopParentIFrame = function isTopParentIFrame(el) {
						        var elWindow = el[_const2.default.DOM_SANDBOX_PROCESSED_CONTEXT];

						        return elWindow && window.top === elWindow.parent;
						    };

						    return ClientDomAdapter;
						})(_processingDomBaseDomAdapter2.default);

						exports.default = ClientDomAdapter;
						module.exports = exports.default;
					},
					"dom-processor.js": function (exports, module, require) {
						exports.__esModule = true;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						var _clientDomAdapter = require('./client-dom-adapter');

						var _clientDomAdapter2 = _interopRequireDefault(_clientDomAdapter);

						var _processingDomIndex = require('../../processing/dom/index');

						var _processingDomIndex2 = _interopRequireDefault(_processingDomIndex);

						exports.default = new _processingDomIndex2.default(new _clientDomAdapter2.default());
						module.exports = exports.default;
					}
				},
				"hammerhead.js": function (exports, module, require) {
					exports.__esModule = true;
					exports.on = on;
					exports.off = off;

					function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

					function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

					/*eslint-disable no-native-reassign*/

					var _utilsBrowser = require('./utils/browser');

					var Browser = _interopRequireWildcard(_utilsBrowser);

					var _utilsDom = require('./utils/dom');

					var DOM = _interopRequireWildcard(_utilsDom);

					var _sandboxesDomAccessorWrappers = require('./sandboxes/dom-accessor-wrappers');

					var _sandboxesDomDom = require('./sandboxes/dom/dom');

					var DOMSandbox = _interopRequireWildcard(_sandboxesDomDom);

					var _sandboxesEventElementEditingWatcher = require('./sandboxes/event/element-editing-watcher');

					var ElementEditingWatcher = _interopRequireWildcard(_sandboxesEventElementEditingWatcher);

					var _utilsEvent = require('./utils/event');

					var Event = _interopRequireWildcard(_utilsEvent);

					var _sandboxesEventSimulator = require('./sandboxes/event/simulator');

					var EventSimulator = _interopRequireWildcard(_sandboxesEventSimulator);

					var _sandboxesEventFocusBlur = require('./sandboxes/event/focus-blur');

					var FocusBlur = _interopRequireWildcard(_sandboxesEventFocusBlur);

					var _sandboxesIframe = require('./sandboxes/iframe');

					var IFrameSandbox = _interopRequireWildcard(_sandboxesIframe);

					var _sandboxesUploadInfoManager = require('./sandboxes/upload/info-manager');

					var InfoManager = _interopRequireWildcard(_sandboxesUploadInfoManager);

					var _json = require('./json');

					var JSON = _interopRequireWildcard(_json);

					var _processingJsIndex = require('../processing/js/index');

					var _processingJsIndex2 = _interopRequireDefault(_processingJsIndex);

					var _sandboxesEventListeners = require('./sandboxes/event/listeners');

					var Listeners = _interopRequireWildcard(_sandboxesEventListeners);

					var _sandboxesMessage = require('./sandboxes/message');

					var MessageSandbox = _interopRequireWildcard(_sandboxesMessage);

					var _sandboxesNativeMethods = require('./sandboxes/native-methods');

					var _sandboxesNativeMethods2 = _interopRequireDefault(_sandboxesNativeMethods);

					var _utilsPosition = require('./utils/position');

					var Position = _interopRequireWildcard(_utilsPosition);

					var _sandboxesEventSelection = require('./sandboxes/event/selection');

					var Selection = _interopRequireWildcard(_sandboxesEventSelection);

					var _sandboxesShadowUi = require('./sandboxes/shadow-ui');

					var ShadowUI = _interopRequireWildcard(_sandboxesShadowUi);

					var _utilsStyle = require('./utils/style');

					var Style = _interopRequireWildcard(_utilsStyle);

					var _transport = require('./transport');

					var Transport = _interopRequireWildcard(_transport);

					var _sandboxesEventUnload = require('./sandboxes/event/unload');

					var Unload = _interopRequireWildcard(_sandboxesEventUnload);

					var _sandboxesUploadUpload = require('./sandboxes/upload/upload');

					var UploadSandbox = _interopRequireWildcard(_sandboxesUploadUpload);

					var _sandboxesDomWindow = require('./sandboxes/dom/window');

					var Window = _interopRequireWildcard(_sandboxesDomWindow);

					var _sandboxesXhr = require('./sandboxes/xhr');

					var XhrSandbox = _interopRequireWildcard(_sandboxesXhr);

					/*eslint-enable no-native-reassign*/

					// Events
					var BEFORE_BEFORE_UNLOAD_EVENT = Unload.BEFORE_BEFORE_UNLOAD_EVENT;
					exports.BEFORE_BEFORE_UNLOAD_EVENT = BEFORE_BEFORE_UNLOAD_EVENT;
					var BEFORE_UNLOAD_EVENT = Unload.BEFORE_UNLOAD_EVENT;
					exports.BEFORE_UNLOAD_EVENT = BEFORE_UNLOAD_EVENT;
					var BODY_CREATED = DOMSandbox.BODY_CREATED;
					exports.BODY_CREATED = BODY_CREATED;
					var DOCUMENT_CLEANED = DOMSandbox.DOCUMENT_CLEANED;
					exports.DOCUMENT_CLEANED = DOCUMENT_CLEANED;
					var START_FILE_UPLOADING_EVENT = UploadSandbox.START_FILE_UPLOADING_EVENT;
					exports.START_FILE_UPLOADING_EVENT = START_FILE_UPLOADING_EVENT;
					var END_FILE_UPLOADING_EVENT = UploadSandbox.END_FILE_UPLOADING_EVENT;
					exports.END_FILE_UPLOADING_EVENT = END_FILE_UPLOADING_EVENT;
					var IFRAME_READY_TO_INIT = IFrameSandbox.IFRAME_READY_TO_INIT;
					exports.IFRAME_READY_TO_INIT = IFRAME_READY_TO_INIT;
					var UNCAUGHT_JS_ERROR = Window.UNCAUGHT_JS_ERROR;
					exports.UNCAUGHT_JS_ERROR = UNCAUGHT_JS_ERROR;
					var UNLOAD_EVENT = Unload.UNLOAD_EVENT;
					exports.UNLOAD_EVENT = UNLOAD_EVENT;
					var XHR_COMPLETED = XhrSandbox.XHR_COMPLETED;
					exports.XHR_COMPLETED = XHR_COMPLETED;
					var XHR_ERROR = XhrSandbox.XHR_ERROR;
					exports.XHR_ERROR = XHR_ERROR;
					var XHR_SEND = XhrSandbox.XHR_SEND;

					exports.XHR_SEND = XHR_SEND;
					var getEventOwner = function (evtName) {
					    switch (evtName) {
					        case Unload.BEFORE_UNLOAD_EVENT:
					        case Unload.BEFORE_BEFORE_UNLOAD_EVENT:
					        case Unload.UNLOAD_EVENT:
					            return Unload;

					        case DOMSandbox.BODY_CREATED:
					        case DOMSandbox.DOCUMENT_CLEANED:
					            return DOMSandbox;

					        case Window.UNCAUGHT_JS_ERROR:
					            return Window;

					        case UploadSandbox.FILE_UPLOADING_EVENT:
					            return UploadSandbox;

					        case IFrameSandbox.IFRAME_READY_TO_INIT:
					            return IFrameSandbox;

					        case XhrSandbox.XHR_COMPLETED:
					        case XhrSandbox.XHR_ERROR:
					        case XhrSandbox.XHR_SEND:
					            return XhrSandbox;

					        default:
					            return null;
					    }
					};

					function on(evtName, handler) {
					    var eventOwner = getEventOwner(evtName);

					    if (eventOwner) eventOwner.on(evtName, handler);
					}

					function off(evtName, handler) {
					    var eventOwner = getEventOwner(evtName);

					    if (eventOwner) eventOwner.off(evtName, handler);
					}

					// Methods
					var getOriginElementAttributes = _sandboxesDomAccessorWrappers.getAttributesProperty;
					exports.getOriginElementAttributes = getOriginElementAttributes;
					var upload = UploadSandbox.upload;

					exports.upload = upload;
					// Private members
					var _raiseBodyCreatedEvent = DOMSandbox.raiseBodyCreatedEvent;
					exports._raiseBodyCreatedEvent = _raiseBodyCreatedEvent;
					var _rebindDomSandboxToIframe = DOMSandbox.rebindDomSandboxToIframe;
					exports._rebindDomSandboxToIframe = _rebindDomSandboxToIframe;
					var _UploadManager = InfoManager;

					exports._UploadManager = _UploadManager;
					var _exports = module.exports;

					// Modules
					_exports.JSON = JSON;
					_exports.JSProcessor = _processingJsIndex2.default;
					_exports.MessageSandbox = MessageSandbox;
					_exports.NativeMethods = _sandboxesNativeMethods2.default;
					_exports.ShadowUI = ShadowUI;
					_exports.Transport = Transport;
					_exports.Util = {
					    Browser: Browser,
					    DOM: DOM,
					    Event: Event,
					    Position: Position,
					    Style: Style
					};
					_exports.EventSandbox = {
					    Listeners: Listeners,
					    FocusBlur: FocusBlur,
					    ElementEditingWatcher: ElementEditingWatcher,
					    EventSimulator: EventSimulator,
					    Selection: Selection
					};

					_exports.init = function () {
					    DOMSandbox.init(window, document);
					};

					_exports.get = require;

					window.Hammerhead = _exports;
				},
				"json.js": function (exports, module, require) {
					exports.__esModule = true;
					exports.stringify = stringify;
					exports.parse = parse;

					function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

					var _utilsIsJqueryObject = require('./utils/is-jquery-object');

					var _utilsIsJqueryObject2 = _interopRequireDefault(_utilsIsJqueryObject);

					//NOTE: json2.js uses fallbacks to existing JSON implementations. So we can't rely on it in our client code.
					//This is an isolated implementation of JSON that is not rely on any external stuff (prototypes, existing JSON
					//implementations, etc.)
					//Serialization/deserialization logic borrowed from http://json.org/json2.js
					function f(n) {
					    // Format integers to have at least two digits.
					    return n < 10 ? '0' + n : n;
					}

					var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
					    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
					    gap,
					    indent,
					    meta = { // table of character substitutions
					    '\b': '\\b',
					    '\t': '\\t',
					    '\n': '\\n',
					    '\f': '\\f',
					    '\r': '\\r',
					    '"': '\\"',
					    '\\': '\\\\'
					};

					function quote(string) {

					    // If the string contains no control characters, no quote characters, and no
					    // backslash characters, then we can safely slap some quotes around it.
					    // Otherwise we must also replace the offending characters with safe escape
					    // sequences.

					    escapable.lastIndex = 0;
					    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
					        var c = meta[a];
					        return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
					    }) + '"' : '"' + string + '"';
					}

					function str(key, holder) {

					    // Produce a string from holder[key].

					    var i,
					        // The loop counter.
					    k,
					        // The member key.
					    v,
					        // The member value.
					    length,
					        mind = gap,
					        partial,
					        value = holder[key];

					    // If the value has a toJSON method, call it to obtain a replacement value.

					    if (value && typeof value === 'object') {
					        //NOTE: determine exact object type instead of relying on prototype.toJSON like in original json2.js
					        var objToStrValue = Object.prototype.toString.apply(value);
					        if (objToStrValue === '[object String]' || objToStrValue === '[object Number]' || objToStrValue === '[object Boolean]') {
					            value = value.valueOf();
					        } else if (objToStrValue === '[object Date]') {
					            value = isFinite(this.valueOf()) ? this.getUTCFullYear() + '-' + f(this.getUTCMonth() + 1) + '-' + f(this.getUTCDate()) + 'T' + f(this.getUTCHours()) + ':' + f(this.getUTCMinutes()) + ':' + f(this.getUTCSeconds()) + 'Z' : null;
					        }
					    }

					    // What happens next depends on the value's type.
					    switch (typeof value) {
					        case 'string':
					            return quote(value);

					        case 'number':

					            // JSON numbers must be finite. Encode non-finite numbers as null.

					            return isFinite(value) ? String(value) : 'null';

					        case 'boolean':
					        case 'null':

					            // If the value is a boolean or null, convert it to a string. Note:
					            // typeof null does not produce 'null'. The case is included here in
					            // the remote chance that this gets fixed someday.

					            return String(value);

					        // If the type is 'object', we might be dealing with an object or an array or
					        // null.

					        case 'object':

					            // Due to a specification blunder in ECMAScript, typeof null is 'object',
					            // so watch out for that case.

					            if (!value) {
					                return 'null';
					            }

					            // Make an array to hold the partial results of stringifying this object value.

					            gap += indent;
					            partial = [];

					            // Is the value an array?

					            if (Object.prototype.toString.apply(value) === '[object Array]') {

					                // The value is an array. Stringify every element. Use null as a placeholder
					                // for non-JSON values.

					                length = value.length;
					                for (i = 0; i < length; i += 1) {
					                    partial[i] = str(i, value) || 'null';
					                }

					                // Join all of the elements together, separated with commas, and wrap them in
					                // brackets.

					                v = partial.length === 0 ? '[]' : gap ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' : '[' + partial.join(',') + ']';
					                gap = mind;
					                return v;
					            }

					            // Iterate through all of the keys in the object.
					            for (k in value) {
					                if (Object.prototype.hasOwnProperty.call(value, k)) {
					                    v = str(k, value);
					                    if (v) {
					                        partial.push(quote(k) + (gap ? ': ' : ':') + v);
					                    }
					                }
					            }

					            // Join all of the member texts together, separated with commas,
					            // and wrap them in braces.

					            v = partial.length === 0 ? '{}' : gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' : '{' + partial.join(',') + '}';
					            gap = mind;
					            return v;
					    }
					}

					function isDOMNode(obj) {
					    if (typeof Node === 'object') return obj instanceof Node;

					    return typeof obj.nodeType === 'number' && typeof obj.nodeName === 'string';
					}

					function isSerializable(value) {
					    if (value) {
					        //NOTE: jquery object, DOM nodes and functions are disallowed obj types because we can't serialize them correctly
					        if (typeof value === 'function' || _utilsIsJqueryObject2.default(value) || isDOMNode(value)) return false;

					        if (typeof value === 'object') {
					            for (var prop in value) {
					                if (value.hasOwnProperty(prop) && !isSerializable(value[prop])) return false;
					            }
					        }
					    }

					    return true;
					}

					//Exports
					//-------------------------------------------------------------------------------------

					function stringify(value) {
					    gap = '';
					    indent = '';

					    // Make a fake root object containing our value under the key of ''.
					    // Return the result of stringifying the value.
					    return str('', { '': value });
					}

					function parse(text, reviver) {
					    // The parse method takes a text and an optional reviver function, and returns
					    // a JavaScript value if the text is a valid JSON text.

					    var j;

					    function walk(holder, key) {

					        // The walk method is used to recursively walk the resulting structure so
					        // that modifications can be made.

					        var k,
					            v,
					            value = holder[key];
					        if (value && typeof value === 'object') {
					            for (k in value) {
					                if (Object.prototype.hasOwnProperty.call(value, k)) {
					                    v = walk(value, k);
					                    if (v !== undefined) {
					                        value[k] = v;
					                    } else {
					                        delete value[k];
					                    }
					                }
					            }
					        }
					        return reviver.call(holder, key, value);
					    }

					    // Parsing happens in four stages. In the first stage, we replace certain
					    // Unicode characters with escape sequences. JavaScript handles many characters
					    // incorrectly, either silently deleting them, or treating them as line endings.

					    text = String(text);
					    cx.lastIndex = 0;
					    if (cx.test(text)) {
					        text = text.replace(cx, function (a) {
					            return '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
					        });
					    }

					    // In the second stage, we run the text against regular expressions that look
					    // for non-JSON patterns. We are especially concerned with '()' and 'new'
					    // because they can cause invocation, and '=' because it can cause mutation.
					    // But just to be safe, we want to reject all unexpected forms.

					    // We split the second stage into 4 regexp operations in order to work around
					    // crippling inefficiencies in IE's and Safari's regexp engines. First we
					    // replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
					    // replace all simple value tokens with ']' characters. Third, we delete all
					    // open brackets that follow a colon or comma or that begin the text. Finally,
					    // we look to see that the remaining characters are only whitespace or ']' or
					    // ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

					    if (/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']').replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

					        // In the third stage we use the eval function to compile the text into a
					        // JavaScript structure. The '{' operator is subject to a syntactic ambiguity
					        // in JavaScript: it can begin a block or an object literal. We wrap the text
					        // in parens to eliminate the ambiguity.

					        j = eval('(' + text + ')');

					        // In the optional fourth stage, we recursively walk the new structure, passing
					        // each name/value pair to a reviver function for possible transformation.

					        return typeof reviver === 'function' ? walk({ '': j }, '') : j;
					    }

					    // If the text is not JSON parseable, then a SyntaxError is thrown.

					    throw new SyntaxError('JSON.parse');
					}

					//NOTE: one more addition - func below allows as to check is it possible to correctly serialize given value
					exports.isSerializable = isSerializable;
				},
				"sandboxes": {
					"cookie.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.getCookie = getCookie;
						exports.setCookie = setCookie;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						var _utilsCookie = require('../utils/cookie');

						var Cookie = _interopRequireWildcard(_utilsCookie);

						var _utilsDom = require('../utils/dom');

						var DOM = _interopRequireWildcard(_utilsDom);

						var _utilsStringTrim = require('../../utils/string-trim');

						var _utilsStringTrim2 = _interopRequireDefault(_utilsStringTrim);

						var _serviceMsgCmd = require('../../service-msg-cmd');

						var _serviceMsgCmd2 = _interopRequireDefault(_serviceMsgCmd);

						var _transport = require('../transport');

						var _transport2 = _interopRequireDefault(_transport);

						var _utilsUrl = require('../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var _settings = require('../settings');

						var _settings2 = _interopRequireDefault(_settings);

						var getSettings = function () {
						    var settings = window !== window.top && !DOM.isCrossDomainWindows(window, window.top) ? window.top.Hammerhead.get('./settings') : _settings2.default;

						    return settings.get();
						};

						function getCookie() {
						    return getSettings().COOKIE;
						}

						function setCookie(document, value) {
						    //NOTE: let browser validate other stuff (e.g. Path attribute), so we add unique prefix
						    //to the cookie key, pass cookie to the browser then clean up and return result.
						    function getBrowserProcessedCookie(parsedCookie) {
						        var parsedCookieCopy = {};

						        for (var prop in parsedCookie) {
						            if (parsedCookie.hasOwnProperty(prop)) parsedCookieCopy[prop] = parsedCookie[prop];
						        }

						        var uniquePrefix = Math.floor(Math.random() * 1e10) + '|';

						        parsedCookieCopy.key = uniquePrefix + parsedCookieCopy.key;

						        // NOTE: We must add cookie path prefix to the path because the proxied location path defferent from the
						        // destination location path
						        if (parsedCookieCopy.path && parsedCookieCopy.path !== '/') parsedCookieCopy.path = _utilsUrl2.default.OriginLocation.getCookiePathPrefix() + parsedCookieCopy.path;

						        document.cookie = Cookie.format(parsedCookieCopy);

						        var processedByBrowserCookieStr = Cookie.get(document, parsedCookieCopy.key);

						        Cookie.del(document, parsedCookieCopy);

						        if (processedByBrowserCookieStr) return processedByBrowserCookieStr.substr(uniquePrefix.length);

						        return null;
						    }

						    //NOTE: perform validations which can't be processed by browser due to proxying
						    function isValidCookie(parsedCookie) {
						        if (!parsedCookie) return false;

						        //NOTE: HttpOnly cookies can't be accessed from client code
						        if (parsedCookie.httponly) return false;

						        var parsedOrigin = _utilsUrl2.default.OriginLocation.getParsed();
						        var originProtocol = parsedOrigin.protocol;

						        //NOTE: TestCafe tunnels HTTPS requests via HTTP so we should validate Secure attribute manually
						        if (parsedCookie.secure && originProtocol !== 'https:') return false;

						        //NOTE: add protocol portion to the domain, so we can use urlUtil for same origin check
						        var domain = parsedCookie.domain && 'http://' + parsedCookie.domain;

						        //NOTE: all TestCafe jobs has same domain, so we should validate Domain attribute manually
						        //according to test url
						        return !domain || _utilsUrl2.default.sameOriginCheck(document.location.toString(), domain);
						    }

						    function updateClientCookieStr(cookieKey, newCookieStr) {
						        var cookies = getSettings().COOKIE ? getSettings().COOKIE.split(';') : [];
						        var replaced = false;

						        //NOTE: replace cookie if it's already exists
						        for (var i = 0; i < cookies.length; i++) {
						            cookies[i] = _utilsStringTrim2.default(cookies[i]);

						            if (cookies[i].indexOf(cookieKey + '=') === 0 || cookies[i] === cookieKey) {
						                //NOTE: delete or update cookie string
						                if (newCookieStr === null) cookies.splice(i, 1);else cookies[i] = newCookieStr;

						                replaced = true;
						            }
						        }

						        if (!replaced && newCookieStr !== null) cookies.push(newCookieStr);

						        getSettings().COOKIE = cookies.join('; ');
						    }

						    function setCookie(cookie) {
						        var parsedCookie = Cookie.parse(cookie);

						        if (isValidCookie(parsedCookie)) {
						            //NOTE: this attributes shouldn't be processed by browser
						            delete parsedCookie.secure;
						            delete parsedCookie.domain;

						            var clientCookieStr = getBrowserProcessedCookie(parsedCookie);

						            /*eslint-disable indent*/
						            if (!clientCookieStr) {
						                //NOTE: we have two options here:
						                //1)cookie was invalid, so it was ignored
						                //2)cookie was deleted by setting Expired attribute
						                //We need to check the second option and delete cookie in our cookie string manually
						                delete parsedCookie.expires;

						                //NOTE: we should delete cookie
						                if (getBrowserProcessedCookie(parsedCookie)) updateClientCookieStr(parsedCookie.key, null);
						            } else updateClientCookieStr(parsedCookie.key, clientCookieStr);
						            /*eslint-enable indent*/
						        }
						    }

						    //NOTE: at first try to update our client cookie cache with client-validated cookie string,
						    //so sync code can immediately access cookie
						    setCookie(value);

						    var setCookieMsg = {
						        cmd: _serviceMsgCmd2.default.SET_COOKIE,
						        cookie: value,
						        url: document.location.href
						    };

						    //NOTE: meanwhile sync cookies with server cookie jar
						    _transport2.default.queuedAsyncServiceMsg(setCookieMsg);

						    return value;
						}
					},
					"dom": {
						"document.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.override = override;

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							var _utilsBrowser = require('../../utils/browser');

							var _iframe = require('../iframe');

							var _iframe2 = _interopRequireDefault(_iframe);

							var _processingJsIndex = require('../../../processing/js/index');

							var _processingJsIndex2 = _interopRequireDefault(_processingJsIndex);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _utilsHtml = require('../../utils/html');

							var Html = _interopRequireWildcard(_utilsHtml);

							var _utilsEventEmitter = require('../../utils/event-emitter');

							var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

							var _utilsUrl = require('../../utils/url');

							// Consts
							var BEFORE_DOCUMENT_CLEANED = 'beforeDocumentCleaned';
							exports.BEFORE_DOCUMENT_CLEANED = BEFORE_DOCUMENT_CLEANED;
							var DOCUMENT_CLOSED = 'documentClosed';
							exports.DOCUMENT_CLOSED = DOCUMENT_CLOSED;
							var DOCUMENT_CLEANED = 'documentCleaned';

							exports.DOCUMENT_CLEANED = DOCUMENT_CLEANED;
							var eventEmitter = new _utilsEventEmitter2.default();

							var on = eventEmitter.on.bind(eventEmitter);
							exports.on = on;
							var off = eventEmitter.off.bind(eventEmitter);

							exports.off = off;
							function isUninitializedIframeWithoutSrc(window) {
							    try {
							        return window !== window.top && _utilsUrl.isIframeWithoutSrc(window.frameElement) && !_iframe2.default.isIframeInitialized(window.frameElement);
							    } catch (e) {
							        return false;
							    }
							}

							function override(window, document, overrideNewElement) {
							    var storedDocumentWriteContent = '';
							    var writeBlockCounter = 0;

							    function beforeDocumentCleaned() {
							        eventEmitter.emit(BEFORE_DOCUMENT_CLEANED, {
							            document: document,
							            isIFrameWithoutSrc: isIFrameWithoutSrc
							        });
							    }

							    function onDocumentClosed() {
							        eventEmitter.emit(DOCUMENT_CLOSED, {
							            document: document,
							            isIFrameWithoutSrc: isIFrameWithoutSrc
							        });
							    }

							    function overridedDocumentWrite(args, ln) {
							        args = Array.prototype.slice.call(args);

							        var separator = ln ? '\n' : '';
							        var lastArg = args.length ? args[args.length - 1] : '';
							        var isBegin = lastArg === _processingJsIndex2.default.DOCUMENT_WRITE_BEGIN_PARAM;
							        var isEnd = lastArg === _processingJsIndex2.default.DOCUMENT_WRITE_END_PARAM;

							        if (isBegin) writeBlockCounter++;else if (isEnd) writeBlockCounter--;

							        if (isBegin || isEnd) args.pop();

							        var str = separator + args.join(separator);

							        var needWriteOnEndMarker = isEnd && !writeBlockCounter;

							        if (needWriteOnEndMarker || Html.isPageHtml(str) || Html.isWellFormattedHtml(str) && !storedDocumentWriteContent) {
							            writeBlockCounter = 0;
							            str = storedDocumentWriteContent + str;
							            storedDocumentWriteContent = '';
							        } else if (isBegin || storedDocumentWriteContent) {
							            storedDocumentWriteContent += str;

							            return null;
							        }

							        var isUninitializedIframe = isUninitializedIframeWithoutSrc(window);

							        str = Html.processHtml('' + str);

							        if (!isUninitializedIframe) beforeDocumentCleaned();

							        // FireFox, IE recreate window instance during the document.write function execution T213930
							        if ((_utilsBrowser.isMozilla || _utilsBrowser.isIE) && !Html.isPageHtml(str)) str = Html.INIT_SCRIPT_FOR_IFRAME_TEMPLATE + str;

							        var result = _nativeMethods2.default.documentWrite.call(document, str);

							        if (!isUninitializedIframe) {
							            eventEmitter.emit(DOCUMENT_CLEANED, { window: window, document: document });
							            overrideNewElement(null, document); // B234357
							        }

							        return result;
							    }

							    document.open = function () {
							        var isUninitializedIframe = isUninitializedIframeWithoutSrc(window);

							        if (!isUninitializedIframe) beforeDocumentCleaned();

							        var result = _nativeMethods2.default.documentOpen.call(document);

							        if (!isUninitializedIframe) eventEmitter.emit(DOCUMENT_CLEANED, { window: window, document: document });else
							            // If iframe initialization in progress, we should once again override document.write and document.open meths
							            // because they were cleaned after native document.open meth calling
							            override(window, document, overrideNewElement);

							        return result;
							    };

							    document.close = function () {
							        // IE10 and IE9 rise "load" event only when document.close meth called.
							        // We should restore overrided document.open and document.write meths before Hammerhead injection
							        // if window not initialized
							        if (_utilsBrowser.isIE && !_iframe2.default.isWindowInited(window)) _nativeMethods2.default.restoreNativeDocumentMeth(document);

							        var result = _nativeMethods2.default.documentClose.call(document);

							        if (!isUninitializedIframeWithoutSrc(window)) onDocumentClosed();

							        return result;
							    };

							    document.createElement = function (tagName) {
							        var el = _nativeMethods2.default.createElement.call(document, tagName);

							        overrideNewElement(el);

							        return el;
							    };

							    document.createElementNS = function (ns, tagName) {
							        var el = _nativeMethods2.default.createElementNS.call(document, ns, tagName);

							        overrideNewElement(el);

							        return el;
							    };

							    document.write = function () {
							        return overridedDocumentWrite(arguments);
							    };

							    document.writeln = function () {
							        return overridedDocumentWrite(arguments, true);
							    };

							    document.createDocumentFragment = function () {
							        var fragment = _nativeMethods2.default.createDocumentFragment.apply(document, arguments);

							        overrideNewElement(fragment);

							        return fragment;
							    };
							}
						},
						"dom.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.rebind = rebind;
							exports.rebindDomSandboxToIframe = rebindDomSandboxToIframe;
							exports.overrideDomMethods = overrideDomMethods;
							exports.init = init;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsBrowser = require('../../utils/browser');

							var _document = require('./document');

							var Document = _interopRequireWildcard(_document);

							var _utilsDom = require('../../utils/dom');

							var _domAccessorWrappers = require('../dom-accessor-wrappers');

							var DomAccessorWrappers = _interopRequireWildcard(_domAccessorWrappers);

							var _element = require('./element');

							var Element = _interopRequireWildcard(_element);

							var _eventEvent = require('../event/event');

							var EventSandbox = _interopRequireWildcard(_eventEvent);

							var _iframe = require('../iframe');

							var _iframe2 = _interopRequireDefault(_iframe);

							var _eventListeners = require('../event/listeners');

							var Listeners = _interopRequireWildcard(_eventListeners);

							var _message = require('../message');

							var MessageSandbox = _interopRequireWildcard(_message);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _shadowUi = require('../shadow-ui');

							var ShadowUI = _interopRequireWildcard(_shadowUi);

							var _const = require('../../../const');

							var _const2 = _interopRequireDefault(_const);

							var _uploadUpload = require('../upload/upload');

							var UploadSandbox = _interopRequireWildcard(_uploadUpload);

							var _window = require('./window');

							var Window = _interopRequireWildcard(_window);

							var _xhr = require('../xhr');

							var XhrSandbox = _interopRequireWildcard(_xhr);

							var _utilsEventEmitter = require('../../utils/event-emitter');

							var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

							// Consts
							var BODY_CREATED = 'bodyCreated';

							exports.BODY_CREATED = BODY_CREATED;
							var BODY_CONTENT_CHANGED = 'bodyContentChanged';
							var DOCUMENT_CLEANED = 'documentCleaned';

							var IFRAME_DOM_SANDBOXES_STORE = 'dom_sandboxes_store_5d9138e9';

							var eventEmitter = new _utilsEventEmitter2.default();

							var on = eventEmitter.on.bind(eventEmitter);
							exports.on = on;
							var off = eventEmitter.off.bind(eventEmitter);

							exports.off = off;
							function onBodyCreated() {
							    Listeners.initDocumentBodyListening(document);

							    eventEmitter.emit(BODY_CREATED, {
							        body: document.body
							    });
							}

							_iframe2.default.on(_iframe2.default.IFRAME_READY_TO_INIT_INTERNAL, function (e) {
							    // Eval Hammerhead code script
							    initHammerheadClient(e.iframe.contentWindow, true);
							});

							_iframe2.default.on(_iframe2.default.IFRAME_DOCUMENT_CREATED, function (e) {
							    // Override only document (In fact, we only need 'write' and 'writeln' methods)
							    Document.override(e.iframe.contentWindow, e.iframe.contentDocument, overrideDomMethods);
							});

							_iframe2.default.on(_iframe2.default.IFRAME_DOCUMENT_RECREATED, function (e) {
							    // We should informs iframe DomSandbox so that it restore communication with the recreated document
							    rebindDomSandboxToIframe(e.iframe);
							});

							function overrideElement(el) {
							    if (el[_const2.default.DOM_SANDBOX_PROCESSED_CONTEXT] !== window) {
							        el[_const2.default.DOM_SANDBOX_PROCESSED_CONTEXT] = window;

							        Element.override(el);
							        EventSandbox.overrideElement(el, true);
							        ShadowUI.overrideElement(el, true);
							    }
							}

							var raiseBodyCreatedEvent = onBodyCreated;

							exports.raiseBodyCreatedEvent = raiseBodyCreatedEvent;

							function rebind(iframe) {
							    // Assign exists DomSandbox to cleared document
							    onDocumentCleaned(iframe.contentWindow, iframe.contentDocument);
							}

							function rebindDomSandboxToIframe(iframe) {
							    if (iframe) {
							        var topSameDomainWindow = _utilsDom.getTopSameDomainWindow(window);
							        var domSandboxesStore = topSameDomainWindow[IFRAME_DOM_SANDBOXES_STORE];

							        // Find iframe DomSandbox
							        for (var i = 0; i < domSandboxesStore.length; i++) {
							            if (domSandboxesStore[i].iframe === iframe) {
							                // Inform the DomSandbox so that it restore communication with the recreated document
							                domSandboxesStore[i].domSandbox.rebind(iframe);

							                return;
							            }
							        }

							        // If the iframe DomSandbox is not found, this means that iframe not initialized,
							        // in this case we should inject Hammerhead

							        // Hack: IE10 clean up overrided methods after document.write calling
							        _nativeMethods2.default.restoreNativeDocumentMeth(iframe.contentDocument);

							        // DomSandbox for this iframe not found (iframe not yet initialized).
							        // Inform the IFrameSandbox about it, and it inject Hammerhead
							        _iframe2.default.onIframeBeganToRun(iframe);
							    }
							}

							function overrideDomMethods(el, doc) {
							    if (!el) {
							        doc = doc || document;

							        EventSandbox.overrideElement(doc);

							        if (doc.documentElement) overrideDomMethods(doc.documentElement);
							    } else if (el.querySelectorAll) {
							        //OPTIMIZATION: use querySelectorAll to iterate over descendant nodes
							        overrideElement(el);

							        var children = el.querySelectorAll('*');

							        for (var i = 0; i < children.length; i++) overrideElement(children[i]);
							    }

							    //NOTE: if querySelectorAll is not available fallback to recursive algorithm
							    else if (el.nodeType === 1 || el.nodeType === 11) {
							            overrideElement(el);

							            var cnLength = el.childNodes.length;

							            if (cnLength) {
							                for (var j = 0; j < cnLength; j++) overrideDomMethods(el.childNodes[j]);
							            }
							        }
							}

							function onDocumentCleaned(window, document) {
							    if (_utilsBrowser.isIE) {
							        var needToUpdateNativeDomMeths = false;
							        var needToUpdateNativeElementMeths = false;
							        var needToUpdateNativeWindowMeths = false;

							        try {
							            needToUpdateNativeDomMeths = !document.createElement || _nativeMethods2.default.createElement.toString() === document.createElement.toString();
							        } catch (e) {
							            needToUpdateNativeDomMeths = true;
							        }

							        try {
							            var nativeElement = _nativeMethods2.default.createElement.call(document, 'div');

							            needToUpdateNativeElementMeths = nativeElement.getAttribute.toString() === _nativeMethods2.default.getAttribute.toString();
							        } catch (e) {
							            needToUpdateNativeElementMeths = true;
							        }

							        try {
							            _nativeMethods2.default.setTimeout.call(window, function () {}, 0);

							            needToUpdateNativeWindowMeths = window.XMLHttpRequest.toString() === _nativeMethods2.default.XMLHttpRequest.toString();
							        } catch (e) {
							            needToUpdateNativeWindowMeths = true;
							        }

							        // T173709
							        if (needToUpdateNativeDomMeths) _nativeMethods2.default.refreshDocumentMeths(document);

							        if (needToUpdateNativeElementMeths) _nativeMethods2.default.refreshElementMeths(document);

							        // T239109
							        if (needToUpdateNativeWindowMeths) _nativeMethods2.default.refreshWindowMeths(window);
							    }

							    EventSandbox.initDocumentListening();

							    if (_utilsBrowser.isWebKit) Listeners.restartElementListening(window);

							    ShadowUI.init(window, document);
							    DomAccessorWrappers.init(window, document); // T182337

							    eventEmitter.emit(DOCUMENT_CLEANED, {
							        document: document,
							        isIFrameWithoutSrc: isIFrameWithoutSrc
							    });

							    Document.override(window, document, overrideDomMethods);
							}

							//NOTE: DOM sandbox hides evidence of the content proxying from page-native script. Proxy replaces URLs for
							//resources. Our goal is to make native script think that all resources are fetched from origin resource not
							//from proxy and also provide proxying for dynamicly created elements.

							function init(window, document) {
							    updateSandboxStore(window);

							    ShadowUI.init(window, document);
							    EventSandbox.init(window, document);
							    XhrSandbox.init(window, document);
							    MessageSandbox.init(window, document);
							    UploadSandbox.init(window, document);
							    DomAccessorWrappers.init(window, document);

							    DomAccessorWrappers.on(DomAccessorWrappers.BODY_CONTENT_CHANGED, function (el) {
							        var elContextWindow = el[_const2.default.DOM_SANDBOX_PROCESSED_CONTEXT];

							        /*eslint-disable indent */
							        if (elContextWindow !== window) {
							            MessageSandbox.sendServiceMsg({
							                cmd: BODY_CONTENT_CHANGED
							            }, elContextWindow);
							        } else ShadowUI.onBodyContentChanged();
							        /*eslint-enable indent */
							    });

							    window[_const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME] = overrideDomMethods;

							    // NOTE: Iframe loses its contentWindow after reinserting in the DOM (in the FF).
							    if (_utilsBrowser.isMozilla) {
							        Element.on(Element.IFRAME_ADDED, function (e) {
							            _iframe2.default.overrideIframe(e.iframe);
							        });
							    }

							    // NOTE: in some browsers (for example Firefox) 'window.document' are different objects when iframe is created
							    // just now and on document ready event. Therefore we should update 'document' object to override its methods (Q527555).
							    document.addEventListener('DOMContentLoaded', function () {
							        overrideDomMethods(null, document);
							    }, false);

							    Document.on(Document.DOCUMENT_CLEANED, function (e) {
							        onDocumentCleaned(e.window, e.document);
							    });

							    Document.override(window, document, overrideDomMethods);
							    Window.init(window);
							    Window.override(window, overrideDomMethods);
							    Element.init(window, overrideDomMethods);

							    MessageSandbox.on(MessageSandbox.SERVICE_MSG_RECEIVED, function (e) {
							        var message = e.message;

							        if (message.cmd === BODY_CONTENT_CHANGED) ShadowUI.onBodyContentChanged();
							    });
							}

							function updateSandboxStore(window) {
							    var topSameDomainWindow = _utilsDom.getTopSameDomainWindow(window);

							    /*eslint-disable indent */
							    if (isIFrameWithoutSrc) {
							        topSameDomainWindow[IFRAME_DOM_SANDBOXES_STORE].push({
							            iframe: window.frameElement,
							            domSandbox: module.exports
							        });
							    } else if (window === topSameDomainWindow) window[IFRAME_DOM_SANDBOXES_STORE] = [];
							    /*eslint-enable indent */
							}
						},
						"element.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.init = init;
							exports.override = override;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsDom = require('../../utils/dom');

							var DOM = _interopRequireWildcard(_utilsDom);

							var _utilsEvent = require('../../utils/event');

							var _uploadHiddenInfo = require('../upload/hidden-info');

							var HiddenInfo = _interopRequireWildcard(_uploadHiddenInfo);

							var _iframe = require('../iframe');

							var _iframe2 = _interopRequireDefault(_iframe);

							var _uploadInfoManager = require('../upload/info-manager');

							var InfoManager = _interopRequireWildcard(_uploadInfoManager);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _domProcessorDomProcessor = require('../../dom-processor/dom-processor');

							var _domProcessorDomProcessor2 = _interopRequireDefault(_domProcessorDomProcessor);

							var _processingScript = require('../../../processing/script');

							var _processingScript2 = _interopRequireDefault(_processingScript);

							var _utilsHtml = require('../../utils/html');

							var _utilsEventEmitter = require('../../utils/event-emitter');

							var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

							var _shadowUi = require('../shadow-ui');

							var _transport = require('../../transport');

							var _utilsUrl = require('../../utils/url');

							var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

							var IFRAME_ADDED = 'iframeAdded';

							exports.IFRAME_ADDED = IFRAME_ADDED;
							var eventEmitter = new _utilsEventEmitter2.default();

							var on = eventEmitter.on.bind(eventEmitter);
							exports.on = on;
							var off = eventEmitter.off.bind(eventEmitter);

							exports.off = off;
							var overrideElementContent = null;

							function overridedInsertRow() {
							    var tagName = this.tagName.toLowerCase();
							    var nativeMeth = tagName === 'table' ? _nativeMethods2.default.insertTableRow : _nativeMethods2.default.insertTBodyRow;
							    var row = nativeMeth.apply(this, arguments);

							    overrideElementContent(row);

							    return row;
							}

							function overridedInsertCell() {
							    var cell = _nativeMethods2.default.insertCell.apply(this, arguments);

							    overrideElementContent(cell);

							    return cell;
							}

							function overridedInsertAdjacentHTML(pos, html) {
							    if (html !== null) html = _utilsHtml.processHtml('' + html, this.parentNode && this.parentNode.tagName);

							    _nativeMethods2.default.insertAdjacentHTML.call(this, pos, html);
							    overrideElementContent(this.parentNode || this);
							}

							function overridedFormSubmit() {
							    var form = this;

							    _transport.waitCookieMsg(function () {
							        _nativeMethods2.default.formSubmit.apply(form, arguments);
							    });
							}

							function overridedInsertBefore(newNode, refNode) {
							    overrideElementContent(newNode);

							    var result = _nativeMethods2.default.insertBefore.call(this, newNode, refNode);

							    onElementAdded(newNode);

							    return result;
							}

							function overridedAppendChild(child) {
							    //NOTE: we should process a TextNode as a script if it is appended to a script element (B254284)
							    if (child.nodeType === 3 && this.tagName && this.tagName.toLowerCase() === 'script') child.data = _processingScript2.default.process(child.data);

							    overrideElementContent(child);

							    var result = null;

							    /*eslint-disable indent */
							    if (this.tagName && this.tagName.toLowerCase() === 'body' && this.children.length) {
							        // NOTE: We should to append element before shadow ui root
							        var lastChild = this.children[this.children.length - 1];

							        result = _nativeMethods2.default.insertBefore.call(this, child, lastChild);
							    } else result = _nativeMethods2.default.appendChild.call(this, child);
							    /*eslint-enable indent */

							    onElementAdded(child);

							    return result;
							}

							function overridedRemoveChild(child) {
							    if (DOM.isDomElement(child)) {
							        DOM.find(child, 'input[type=file]', removeFileInputInfo);

							        if (DOM.isFileInput(child)) removeFileInputInfo(child);
							    }

							    var result = _nativeMethods2.default.removeChild.call(this, child);

							    onElementRemoved(child);

							    return result;
							}

							function overridedCloneNode() {
							    var clone = _nativeMethods2.default.cloneNode.apply(this, arguments);

							    overrideElementContent(clone);

							    return clone;
							}

							function overridedGetAttribute(attr) {
							    return overridedGetAttributeCore(this, attr);
							}

							function overridedGetAttributeNS(ns, attr) {
							    return overridedGetAttributeCore(this, attr, ns);
							}

							function overridedGetAttributeCore(el, attr, ns) {
							    var getAttrMeth = ns ? _nativeMethods2.default.getAttributeNS : _nativeMethods2.default.getAttribute;

							    // Optimization: hasAttribute meth is very slow
							    if (isUrlAttr(el, attr) || attr === 'sandbox' || _domProcessorDomProcessor2.default.EVENTS.indexOf(attr) !== -1 || attr === 'autocomplete') {
							        var storedAttr = _domProcessorDomProcessor2.default.getStoredAttrName(attr);

							        if (attr === 'autocomplete' && getAttrMeth.apply(el, ns ? [ns, storedAttr] : [storedAttr]) === 'none') return null;else if (el.hasAttribute(storedAttr)) attr = storedAttr;
							    }

							    return getAttrMeth.apply(el, ns ? [ns, attr] : [attr]);
							}

							function overridedSetAttribute(attr, value) {
							    return overridedSetAttributeCore(this, attr, value);
							}

							function overridedSetAttributeNS(ns, attr, value) {
							    return overridedSetAttributeCore(this, attr, value, ns);
							}

							function overridedSetAttributeCore(el, attr, value, ns) {
							    var setAttrMeth = ns ? _nativeMethods2.default.setAttributeNS : _nativeMethods2.default.setAttribute;
							    var tagName = el.tagName.toLowerCase();
							    var isSupportedProtocol = _utilsUrl2.default.isSupportedProtocol(value);
							    var urlAttr = isUrlAttr(el, attr);
							    var isEventAttr = _domProcessorDomProcessor2.default.EVENTS.indexOf(attr) !== -1;

							    value += '';

							    if (urlAttr && !isSupportedProtocol || isEventAttr) {
							        var isJsProtocol = _domProcessorDomProcessor2.default.JAVASCRIPT_PROTOCOL_REG_EX.test(value);
							        var storedJsAttr = _domProcessorDomProcessor2.default.getStoredAttrName(attr);

							        /*eslint-disable indent */
							        if (urlAttr && isJsProtocol || isEventAttr) {
							            var valueWithoutProtocol = value.replace(_domProcessorDomProcessor2.default.JAVASCRIPT_PROTOCOL_REG_EX, '');
							            var matches = valueWithoutProtocol.match(_domProcessorDomProcessor2.default.HTML_STRING_REG_EX);
							            var processedValue = '';

							            if (matches && isJsProtocol) {
							                var html = matches[2];
							                var stringQuote = matches[1];

							                if (!_utilsHtml.isPageHtml(html)) html = '<html><body>' + html + '</body></html>';

							                html = html.replace(new RegExp('\\\\' + stringQuote, 'g'), stringQuote);
							                html = _utilsHtml.processHtml(html);
							                html = html.replace(new RegExp(stringQuote, 'g'), '\\' + stringQuote);

							                /*eslint-disable no-script-url */
							                processedValue = 'javascript:' + stringQuote + html + stringQuote;
							                /*eslint-enable no-script-url */
							            } else
							                /*eslint-disable no-script-url */
							                processedValue = (isJsProtocol ? 'javascript:' : '') + _processingScript2.default.process(valueWithoutProtocol, true);
							            /*eslint-enable no-script-url */

							            if (processedValue !== value) {
							                setAttrMeth.apply(el, ns ? [ns, storedJsAttr, value] : [storedJsAttr, value]);
							                value = processedValue;
							            }
							        } else setAttrMeth.apply(el, ns ? [ns, storedJsAttr, value] : [storedJsAttr, value]);
							        /*eslint-enable indent */
							    } else if (urlAttr && isSupportedProtocol) {
							            var storedUrlAttr = _domProcessorDomProcessor2.default.getStoredAttrName(attr);

							            setAttrMeth.apply(el, ns ? [ns, storedUrlAttr, value] : [storedUrlAttr, value]);

							            /*eslint-disable indent */
							            if (tagName !== 'img') {
							                if (value !== '') {
							                    var isIframe = tagName === 'iframe';
							                    var isScript = tagName === 'script';
							                    var isCrossDomainUrl = isSupportedProtocol && !_utilsUrl2.default.sameOriginCheck(location.toString(), value);
							                    var resourceType = null;

							                    if (isScript) resourceType = _utilsUrl2.default.SCRIPT;else if (isIframe || _domProcessorDomProcessor2.default.isOpenLinkInIFrame(el)) resourceType = _utilsUrl2.default.IFRAME;

							                    value = isIframe && isCrossDomainUrl ? _utilsUrl2.default.getCrossDomainIframeProxyUrl(value) : _utilsUrl2.default.getProxyUrl(value, null, null, null, null, resourceType);
							                }
							            } else if (value && !_utilsUrl2.default.parseProxyUrl(value)) value = _utilsUrl2.default.resolveUrlAsOrigin(value);
							            /*eslint-enable indent */
							        } else if (attr === 'autocomplete') {
							                var storedAutocompleteAttr = _domProcessorDomProcessor2.default.getStoredAttrName(attr);

							                setAttrMeth.apply(el, ns ? [ns, storedAutocompleteAttr, value] : [storedAutocompleteAttr, value]);

							                value = 'off';
							            } else if (attr === 'target' && value === '_blank' && _domProcessorDomProcessor2.default.TARGET_ATTR_TAGS[tagName]) return null;else if (attr === 'sandbox' && value.indexOf('allow-scripts') === -1) {
							                var storedSandboxAttr = _domProcessorDomProcessor2.default.getStoredAttrName(attr);

							                setAttrMeth.apply(el, ns ? [ns, storedSandboxAttr, value] : [storedSandboxAttr, value]);
							                value += ' allow-scripts';
							            }

							    return setAttrMeth.apply(el, ns ? [ns, attr, value] : [attr, value]);
							}

							function overridedRemoveAttribute() {
							    overridedRemoveAttributeCore.call(this, false, arguments);
							}

							function overridedRemoveAttributeNS() {
							    overridedRemoveAttributeCore.call(this, true, arguments);
							}

							function overridedRemoveAttributeCore(ns, arg) {
							    var attr = ns ? arg[1] : arg[0];
							    var removeAttrFunc = ns ? _nativeMethods2.default.removeAttributeNS : _nativeMethods2.default.removeAttribute;

							    if (isUrlAttr(this, attr) || attr === 'sandbox' || attr === 'autocomplete' || _domProcessorDomProcessor2.default.EVENTS.indexOf(attr) !== -1) {
							        var storedAttr = _domProcessorDomProcessor2.default.getStoredAttrName(attr);

							        if (attr === 'autocomplete') _nativeMethods2.default.setAttribute.call(this, storedAttr, 'none');else removeAttrFunc.apply(this, ns ? [arg[0], storedAttr] : [storedAttr]);
							    }

							    if (attr !== 'autocomplete') return removeAttrFunc.apply(this, arg);
							}

							function isUrlAttr(el, attr) {
							    var tagName = el.tagName.toLowerCase();

							    return _domProcessorDomProcessor2.default.URL_ATTR_TAGS[attr] && _domProcessorDomProcessor2.default.URL_ATTR_TAGS[attr].indexOf(tagName) !== -1;
							}

							function removeFileInputInfo(el) {
							    HiddenInfo.removeInputInfo(el);
							}

							function onElementAdded(el) {
							    if ((el.nodeType === 1 || el.nodeType === 9) && DOM.isElementInDocument(el)) {
							        var iframes = getIframes(el);

							        /*eslint-disable indent */
							        if (iframes.length) {
							            for (var i = 0; i < iframes.length; i++) onIFrameAddedToDOM(iframes[i]);
							        } else if (el.tagName && el.tagName.toLowerCase() === 'body') _shadowUi.onBodyElementMutation();
							        /*eslint-enable indent */
							    }

							    if (DOM.isDomElement(el)) {
							        DOM.find(el, 'input[type=file]', addFileInputInfo);

							        if (DOM.isFileInput(el)) addFileInputInfo(el);
							    }
							}

							function onElementRemoved(el) {
							    if (el.nodeType === 1 && el.tagName && el.tagName.toLowerCase() === 'body') _shadowUi.onBodyElementMutation();
							}

							function getIframes(el) {
							    var isIframe = el.tagName && el.tagName.toLowerCase() === 'iframe';

							    return isIframe ? [el] : el.querySelectorAll('iframe');
							}

							function addFileInputInfo(el) {
							    HiddenInfo.addInputInfo(el, InfoManager.getFiles(el), InfoManager.getValue(el));
							}

							function onIFrameAddedToDOM(iframe) {
							    if (!DOM.isCrossDomainIframe(iframe, true)) {
							        eventEmitter.emit(IFRAME_ADDED, {
							            iframe: iframe
							        });

							        _iframe2.default.iframeAddedToDom(iframe);
							    }
							}

							function init(window, overrideFunc) {
							    overrideElementContent = overrideFunc;

							    window.Element.prototype.insertBefore = overridedInsertBefore;
							    window.Element.prototype.appendChild = overridedAppendChild;
							    window.Element.prototype.removeChild = overridedRemoveChild;
							    window.Element.prototype.setAttribute = overridedSetAttribute;
							    window.Element.prototype.setAttributeNS = overridedSetAttributeNS;
							    window.Element.prototype.getAttribute = overridedGetAttribute;
							    window.Element.prototype.getAttributeNS = overridedGetAttributeNS;
							    window.Element.prototype.removeAttribute = overridedRemoveAttribute;
							    window.Element.prototype.removeAttributeNS = overridedRemoveAttributeNS;
							    window.Element.prototype.cloneNode = overridedCloneNode;
							    window.Node.prototype.cloneNode = overridedCloneNode;
							    window.Node.prototype.appendChild = overridedAppendChild;
							    window.Node.prototype.removeChild = overridedRemoveChild;
							    window.Node.prototype.insertBefore = overridedInsertBefore;
							    window.HTMLTableElement.prototype.insertRow = overridedInsertRow;
							    window.HTMLTableSectionElement.prototype.insertRow = overridedInsertRow;
							    window.HTMLTableRowElement.prototype.insertCell = overridedInsertCell;
							    window.HTMLFormElement.prototype.submit = overridedFormSubmit;
							}

							function override(el) {
							    var isDocFragment = el.nodeType === 11;
							    var elTagName = el.tagName && el.tagName.toLowerCase();
							    var isForm = elTagName === 'form';
							    var isIframe = elTagName === 'iframe';

							    if (!isDocFragment) _domProcessorDomProcessor2.default.processElement(el, _utilsUrl2.default.convertToProxyUrl);

							    if (elTagName === 'img') {
							        el.addEventListener('error', function (e) {
							            var storedAttr = _nativeMethods2.default.getAttribute.call(el, _domProcessorDomProcessor2.default.getStoredAttrName('src'));

							            if (storedAttr && !_utilsUrl2.default.parseProxyUrl(el.src) && _utilsUrl2.default.isSupportedProtocol(el.src)) {
							                _nativeMethods2.default.setAttribute.call(el, 'src', _utilsUrl2.default.getProxyUrl(storedAttr));
							                _utilsEvent.stopPropagation(e);
							            }
							        }, false);
							    }

							    if (isIframe && !DOM.isCrossDomainIframe(el, true)) _iframe2.default.overrideIframe(el);

							    if ('insertAdjacentHTML' in el) el.insertAdjacentHTML = overridedInsertAdjacentHTML;

							    el.insertBefore = overridedInsertBefore;
							    el.appendChild = overridedAppendChild;
							    el.removeChild = overridedRemoveChild;
							    el.cloneNode = overridedCloneNode;

							    if (!isDocFragment) {
							        el.setAttribute = overridedSetAttribute;
							        el.setAttributeNS = overridedSetAttributeNS;
							        el.getAttribute = overridedGetAttribute;
							        el.getAttributeNS = overridedGetAttributeNS;
							        el.removeAttribute = overridedRemoveAttribute;
							        el.removeAttributeNS = overridedRemoveAttributeNS;
							    }

							    if ('insertRow' in el) el.insertRow = overridedInsertRow;

							    if ('insertCell' in el) el.insertCell = overridedInsertCell;

							    if (isForm) el.submit = overridedFormSubmit;
							}
						},
						"window.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.init = init;
							exports.override = override;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							/*global history, navigator*/

							var _utilsBrowser = require('../../utils/browser');

							var _utilsDom = require('../../utils/dom');

							var _domAccessorWrappers = require('../dom-accessor-wrappers');

							var _message = require('../message');

							var MessageSandbox = _interopRequireWildcard(_message);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _processingScript = require('../../../processing/script');

							var _processingScript2 = _interopRequireDefault(_processingScript);

							var _utilsEventEmitter = require('../../utils/event-emitter');

							var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

							var _shadowUi = require('../shadow-ui');

							var _utilsUrl = require('../../utils/url');

							var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

							// Const
							var UNCAUGHT_JS_ERROR = 'uncaughtJSError';

							exports.UNCAUGHT_JS_ERROR = UNCAUGHT_JS_ERROR;
							var eventEmitter = new _utilsEventEmitter2.default();

							var on = eventEmitter.on.bind(eventEmitter);
							exports.on = on;
							var off = eventEmitter.off.bind(eventEmitter);

							exports.off = off;
							function raiseUncaughtJsErrorEvent(msg, window, pageUrl) {
							    if (_utilsDom.isCrossDomainWindows(window, window.top)) return;

							    var sendToTopWindow = window !== window.top;

							    if (!pageUrl) pageUrl = _utilsUrl2.default.OriginLocation.get();

							    if (sendToTopWindow) {
							        eventEmitter.emit(UNCAUGHT_JS_ERROR, {
							            msg: msg,
							            pageUrl: pageUrl,
							            inIFrame: true
							        });

							        MessageSandbox.sendServiceMsg({
							            cmd: UNCAUGHT_JS_ERROR,
							            pageUrl: pageUrl,
							            msg: msg
							        }, window.top);
							    } else {
							        eventEmitter.emit(UNCAUGHT_JS_ERROR, {
							            msg: msg,
							            pageUrl: pageUrl
							        });
							    }
							}

							function init() {
							    MessageSandbox.on(MessageSandbox.SERVICE_MSG_RECEIVED, function (e) {
							        var message = e.message;

							        if (message.cmd === UNCAUGHT_JS_ERROR) raiseUncaughtJsErrorEvent(message.msg, window, message.pageUrl);
							    });
							}

							function override(window, overrideNewElement) {
							    window.CanvasRenderingContext2D.prototype.drawImage = function () {
							        var args = Array.prototype.slice.call(arguments, 0);
							        var img = args.shift();
							        var src = img.src;

							        if (_utilsUrl2.default.sameOriginCheck(location.toString(), src)) {
							            img = _nativeMethods2.default.createElement.call(window.document, 'img');
							            img.src = _utilsUrl2.default.getProxyUrl(src);
							        }

							        args.unshift(img);

							        return _nativeMethods2.default.canvasContextDrawImage.apply(this, args);
							    };

							    // Override uncaught error handling
							    window.onerror = function (msg, url, line, col, errObj) {
							        // FireFox raises NS_ERROR_NOT_INITIALIZED exception after widnow has been removed from the dom
							        if (msg.indexOf('NS_ERROR_NOT_INITIALIZED') !== -1) return true;

							        var originalOnErrorHandler = window[_domAccessorWrappers.ORIGINAL_WINDOW_ON_ERROR_HANDLER_KEY];

							        var caught = originalOnErrorHandler && originalOnErrorHandler.call(window, msg, url, line, col, errObj) === true;

							        if (caught) return true;

							        raiseUncaughtJsErrorEvent(msg, window);

							        return false;
							    };

							    window.open = function () {
							        var newArgs = [];

							        newArgs.push(_utilsUrl2.default.getProxyUrl(arguments[0]));
							        newArgs.push('_self');

							        if (arguments.length > 2) newArgs.push(arguments[2]);
							        if (arguments.length > 3) newArgs.push(arguments[3]);

							        return _nativeMethods2.default.windowOpen.apply(window, newArgs);
							    };

							    window.Worker = function (scriptURL) {
							        scriptURL = _utilsUrl2.default.getProxyUrl(scriptURL);

							        return new _nativeMethods2.default.Worker(scriptURL);
							    };

							    if (window.Blob) {
							        window.Blob = function (parts, opts) {
							            var type = opts && opts.type && opts.type.toString().toLowerCase();

							            if (type === 'text/javascript' || type === 'application/javascript' || type === 'application/x-javascript') {
							                parts = [_processingScript2.default.process(parts.join(''))];
							            }

							            return new _nativeMethods2.default.Blob(parts, opts);
							        };
							    }

							    window.EventSource = function (url) {
							        url = _utilsUrl2.default.getProxyUrl(url);

							        return new _nativeMethods2.default.EventSource(url);
							    };

							    if (window.MutationObserver) {
							        window.MutationObserver = function (callback) {
							            var wrapper = function (mutations) {
							                var result = [];

							                for (var i = 0; i < mutations.length; i++) {
							                    if (!_shadowUi.isShadowUIMutation(mutations[i])) result.push(mutations[i]);
							                }

							                if (result.length) callback(result);
							            };

							            return new _nativeMethods2.default.MutationObserver(wrapper);
							        };
							    }

							    if (window.navigator && window.navigator.serviceWorker) {
							        window.navigator.serviceWorker.register = function (url) {
							            url = _utilsUrl2.default.getProxyUrl(url);

							            return _nativeMethods2.default.registerServiceWorker.call(window.navigator.serviceWorker, url);
							        };
							    }

							    window.Image = function () {
							        var image = null;

							        if (!arguments.length) image = new _nativeMethods2.default.Image();else if (arguments.length === 1) image = new _nativeMethods2.default.Image(arguments[0]);else image = new _nativeMethods2.default.Image(arguments[0], arguments[1]);

							        overrideNewElement(image);

							        return image;
							    };

							    if (typeof window.history.pushState === 'function' && typeof window.history.replaceState === 'function') {
							        window.history.pushState = function (data, title, url) {
							            var args = [data, title];

							            if (arguments.length > 2) args.push(url ? _utilsUrl2.default.getProxyUrl(url) : url);

							            return _nativeMethods2.default.historyPushState.apply(history, args);
							        };

							        window.history.replaceState = function (data, title, url) {
							            var args = [data, title];

							            if (arguments.length > 2) args.push(url ? _utilsUrl2.default.getProxyUrl(url) : url);

							            return _nativeMethods2.default.historyReplaceState.apply(history, args);
							        };
							    }

							    if (window.navigator.registerProtocolHandler) {
							        window.navigator.registerProtocolHandler = function () {
							            var args = Array.prototype.slice.call(arguments);
							            var urlIndex = 1;
							            var originHostname = _utilsUrl2.default.OriginLocation.getParsed().hostname;
							            var isOriginUrl = _utilsBrowser.isMozilla ? _utilsUrl2.default.isSubDomain(originHostname, _utilsUrl2.default.parseUrl(args[urlIndex]).hostname) : _utilsUrl2.default.sameOriginCheck(_utilsUrl2.default.OriginLocation.get(), args[urlIndex]);

							            if (isOriginUrl) args[urlIndex] = _utilsUrl2.default.getProxyUrl(args[urlIndex]);

							            return _nativeMethods2.default.registerProtocolHandler.apply(navigator, args);
							        };
							    }
							}
						}
					},
					"dom-accessor-wrappers.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.init = init;
						exports.getAttributesProperty = getAttributesProperty;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						var _cookie = require('./cookie');

						var CookieSandbox = _interopRequireWildcard(_cookie);

						var _utilsDom = require('../utils/dom');

						var DOM = _interopRequireWildcard(_utilsDom);

						var _utilsHtml = require('../utils/html');

						var Html = _interopRequireWildcard(_utilsHtml);

						var _eventElementEditingWatcher = require('./event/element-editing-watcher');

						var ElementEditingWatcher = _interopRequireWildcard(_eventElementEditingWatcher);

						var _processingJsIndex = require('../../processing/js/index');

						var _processingJsIndex2 = _interopRequireDefault(_processingJsIndex);

						var _message = require('./message');

						var MessageSandbox = _interopRequireWildcard(_message);

						var _nativeMethods = require('./native-methods');

						var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

						var _domProcessorDomProcessor = require('../dom-processor/dom-processor');

						var _domProcessorDomProcessor2 = _interopRequireDefault(_domProcessorDomProcessor);

						var _processingStyle = require('../../processing/style');

						var _processingStyle2 = _interopRequireDefault(_processingStyle);

						var _processingScript = require('../../processing/script');

						var _processingScript2 = _interopRequireDefault(_processingScript);

						var _shadowUi = require('./shadow-ui');

						var ShadowUI = _interopRequireWildcard(_shadowUi);

						var _const = require('../../const');

						var _const2 = _interopRequireDefault(_const);

						var _uploadUpload = require('./upload/upload');

						var UploadSandbox = _interopRequireWildcard(_uploadUpload);

						var _eventUnload = require('./event/unload');

						var Unload = _interopRequireWildcard(_eventUnload);

						var _utilsUrl = require('../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var _utilsCreatePropertyDescJs = require('../utils/create-property-desc.js');

						var _utilsCreatePropertyDescJs2 = _interopRequireDefault(_utilsCreatePropertyDescJs);

						var _utilsEventEmitter = require('../utils/event-emitter');

						var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

						var LOCATION_WRAPPER = 'location_1b082a6cec';

						exports.LOCATION_WRAPPER = LOCATION_WRAPPER;
						var IS_LOCATION_WRAPPER = 'is_location_1b082a6cec';

						var BODY_CONTENT_CHANGED = 'bodyContentChanged';
						exports.BODY_CONTENT_CHANGED = BODY_CONTENT_CHANGED;
						var ORIGINAL_WINDOW_ON_ERROR_HANDLER_KEY = 'onerror_23ad9304921s';
						exports.ORIGINAL_WINDOW_ON_ERROR_HANDLER_KEY = ORIGINAL_WINDOW_ON_ERROR_HANDLER_KEY;
						var WINDOW_ON_ERROR_SET = 'windowOnErrorSet';

						exports.WINDOW_ON_ERROR_SET = WINDOW_ON_ERROR_SET;
						var anchor = document.createElement('A');
						var emptyAnchor = document.createElement('A');

						var eventEmitter = new _utilsEventEmitter2.default();

						var on = eventEmitter.on.bind(eventEmitter);

						exports.on = on;
						function onBodyContentChanged(el) {
						    eventEmitter.emit(BODY_CONTENT_CHANGED, el);
						}

						function isAnchor(el) {
						    return DOM.isDomElement(el) && el.tagName.toLowerCase() === 'a';
						}

						function isStyleInstance(instance) {
						    if (instance instanceof _nativeMethods2.default.styleClass) return true;

						    if (instance && typeof instance === 'object' && typeof instance.border !== 'undefined') {
						        instance = instance.toString();

						        return instance === '[object CSSStyleDeclaration]' || instance === '[object CSS2Properties]' || instance === '[object MSStyleCSSProperties]';
						    }

						    return false;
						}

						function isLocationInstance(instance) {
						    if (instance instanceof _nativeMethods2.default.locationClass) return true;

						    return instance && typeof instance === 'object' && typeof instance.href !== 'undefined' && typeof instance.assign !== 'undefined';
						}

						function getAnchorProperty(el, prop) {
						    if (el.href) {
						        var parsedProxyUrl = _utilsUrl2.default.parseProxyUrl(el.href);

						        anchor.href = parsedProxyUrl ? parsedProxyUrl.originUrl : el.href;

						        return anchor[prop];
						    }

						    return emptyAnchor[prop];
						}

						function setAnchorProperty(el, prop, value) {
						    if (el.href) {
						        anchor.href = _utilsUrl2.default.parseProxyUrl(el.href).originUrl;
						        anchor[prop] = value;
						        el.setAttribute('href', anchor.href);

						        return anchor[prop];
						    }

						    return '';
						}

						function removeOurWriteMethArgs(args) {
						    if (args.length) {
						        var lastArg = args[args.length - 1];

						        if (lastArg === _processingJsIndex2.default.DOCUMENT_WRITE_BEGIN_PARAM || lastArg === _processingJsIndex2.default.DOCUMENT_WRITE_END_PARAM) {
						            var result = Array.prototype.slice.call(args);

						            result.pop();

						            return result;
						        }
						    }

						    return args;
						}

						function createLocWrapper(window) {
						    var locationProps = ['port', 'host', 'hostname', 'pathname', 'protocol'];
						    var result = {};
						    var resourceType = window !== window.top ? _utilsUrl2.default.IFRAME : null;

						    var getHref = function () {
						        return window.location.href === 'about:blank' ? 'about:blank' : _utilsUrl2.default.OriginLocation.get();
						    };

						    Object.defineProperty(result, 'href', _utilsCreatePropertyDescJs2.default({
						        get: function () {
						            return getHref();
						        },
						        set: function (href) {
						            window.location.href = _utilsUrl2.default.getProxyUrl(href, null, null, null, null, resourceType);

						            return href;
						        }
						    }));

						    Object.defineProperty(result, 'search', _utilsCreatePropertyDescJs2.default({
						        get: function () {
						            return window.location.search;
						        },
						        set: function (search) {
						            window.location = _utilsUrl2.default.changeOriginUrlPart(window.location.toString(), 'search', search, resourceType);

						            return search;
						        }
						    }));

						    Object.defineProperty(result, 'origin', _utilsCreatePropertyDescJs2.default({
						        get: function () {
						            var parsedOriginLocation = _utilsUrl2.default.OriginLocation.getParsed();

						            return parsedOriginLocation.protocol + '//' + parsedOriginLocation.host;
						        },
						        set: function (origin) {
						            return origin;
						        }
						    }));

						    Object.defineProperty(result, 'hash', _utilsCreatePropertyDescJs2.default({
						        get: function () {
						            return window.location.hash;
						        },
						        set: function (hash) {
						            window.location.hash = hash;

						            return hash;
						        }
						    }));

						    var overrideLocationProp = function (prop) {
						        Object.defineProperty(result, prop, _utilsCreatePropertyDescJs2.default({
						            get: function () {
						                return _utilsUrl2.default.OriginLocation.getParsed()[prop];
						            },
						            set: function (value) {
						                window.location = _utilsUrl2.default.changeOriginUrlPart(window.location.toString(), prop, value, resourceType);

						                return value;
						            }
						        }));
						    };

						    locationProps.forEach(function (value) {
						        overrideLocationProp(value);
						    });

						    result.assign = function (url) {
						        return window.location.assign(_utilsUrl2.default.getProxyUrl(url, null, null, null, null, resourceType));
						    };

						    result.reload = function (forceget) {
						        return window.location.reload(forceget);
						    };

						    result.replace = function (url) {
						        return window.location.replace(_utilsUrl2.default.getProxyUrl(url, null, null, null, null, resourceType));
						    };

						    result.toString = function () {
						        return getHref();
						    };

						    result[IS_LOCATION_WRAPPER] = true;

						    return result;
						}

						function init(window, document) {
						    var locationWrapper = createLocWrapper(window);
						    var storedDomain = '';

						    window[LOCATION_WRAPPER] = locationWrapper;
						    document[LOCATION_WRAPPER] = locationWrapper;

						    function getUrlAttr(el, attr) {
						        var attrValue = el.getAttribute(attr);

						        if (attrValue === null) return '';else if (attrValue === '') return _utilsUrl2.default.OriginLocation.get();else if (/^#/.test(attrValue)) return _utilsUrl2.default.OriginLocation.withHash(attrValue);

						        return _utilsUrl2.default.resolveUrlAsOrigin(attrValue);
						    }

						    var elementMethWrappers = {
						        postMessage: {
						            condition: function (window) {
						                return DOM.isWindowInstance(window);
						            },

						            method: function (contentWindow, args) {
						                return MessageSandbox.postMessage(contentWindow, args);
						            }
						        },

						        write: {
						            condition: function (document) {
						                return !DOM.isDocumentInstance(document);
						            },

						            method: function (document, args) {
						                return document.write.apply(document, removeOurWriteMethArgs(args));
						            }
						        },

						        writeln: {
						            condition: function (document) {
						                return !DOM.isDocumentInstance(document);
						            },

						            method: function (document, args) {
						                return document.writeln.apply(document, removeOurWriteMethArgs(args));
						            }
						        }
						    };

						    var elementPropertyAccessors = {
						        action: {
						            condition: function (el) {
						                if (DOM.isDomElement(el)) {
						                    var tagName = el.tagName.toLowerCase();

						                    return _domProcessorDomProcessor2.default.URL_ATTR_TAGS['action'].indexOf(tagName) !== -1;
						                }

						                return false;
						            },

						            get: function (el) {
						                return getUrlAttr(el, 'action');
						            },

						            set: function (el, value) {
						                return el.setAttribute('action', value);
						            }
						        },

						        activeElement: {
						            condition: function (el) {
						                return DOM.isDocumentInstance(el);
						            },

						            get: function (el) {
						                if (DOM.isShadowUIElement(el.activeElement)) return ShadowUI.getLastActiveElement() || el.body;

						                return el.activeElement;
						            },

						            set: function () {}
						        },

						        attributes: {
						            condition: function (el) {
						                var attributesType = window.NamedNodeMap || window.MozNamedAttrMap;

						                return attributesType && el.attributes instanceof attributesType;
						            },

						            get: function (el) {
						                return getAttributesProperty(el);
						            },

						            set: function (el, value) {
						                return value;
						            }
						        },

						        autocomplete: {
						            condition: function (el) {
						                return DOM.isInputElement(el);
						            },

						            get: function (input) {
						                return input.getAttribute('autocomplete') || '';
						            },

						            set: function (input, value) {
						                return input.setAttribute('autocomplete', value);
						            }
						        },

						        cookie: {
						            condition: function (doc) {
						                return DOM.isDocumentInstance(doc);
						            },

						            get: function () {
						                return CookieSandbox.getCookie();
						            },

						            set: function (doc, cookie) {
						                return CookieSandbox.setCookie(doc, cookie);
						            }
						        },

						        data: {
						            condition: function (el) {
						                if (DOM.isDomElement(el)) {
						                    var tagName = el.tagName.toLowerCase();

						                    return _domProcessorDomProcessor2.default.URL_ATTR_TAGS['data'].indexOf(tagName) !== -1;
						                }

						                return false;
						            },

						            get: function (el) {
						                return getUrlAttr(el, 'data');
						            },

						            set: function (el, value) {
						                return el.setAttribute('data', value);
						            }
						        },

						        domain: {
						            condition: function (doc) {
						                return DOM.isDocumentInstance(doc);
						            },

						            get: function () {
						                return storedDomain ? storedDomain : locationWrapper.hostname;
						            },

						            set: function (doc, domain) {
						                storedDomain = domain;

						                return domain;
						            }
						        },

						        files: {
						            condition: function (el) {
						                return DOM.isFileInput(el);
						            },

						            get: function (el) {
						                return UploadSandbox.getFiles(el);
						            },

						            set: function (el, value) {
						                return value;
						            }
						        },

						        firstChild: {
						            condition: function (el) {
						                return ShadowUI.isShadowContainer(el);
						            },

						            get: function (el) {
						                return ShadowUI.getFirstChild(el);
						            },

						            set: function () {}
						        },

						        firstElementChild: {
						            condition: function (el) {
						                return ShadowUI.isShadowContainer(el);
						            },

						            get: function (el) {
						                return ShadowUI.getFirstElementChild(el);
						            },

						            set: function () {}
						        },

						        host: {
						            condition: function (el) {
						                return isAnchor(el);
						            },

						            get: function (el) {
						                return getAnchorProperty(el, 'host');
						            },

						            set: function (el, port) {
						                return setAnchorProperty(el, 'host', port);
						            }
						        },

						        hostname: {
						            condition: function (el) {
						                return isAnchor(el);
						            },

						            get: function (el) {
						                return getAnchorProperty(el, 'hostname');
						            },

						            set: function (el, port) {
						                return setAnchorProperty(el, 'hostname', port);
						            }
						        },

						        href: {
						            condition: function (el) {
						                if (DOM.isDomElement(el)) {
						                    var tagName = el.tagName.toLowerCase();

						                    return _domProcessorDomProcessor2.default.URL_ATTR_TAGS['href'].indexOf(tagName) !== -1;
						                }

						                if (el[IS_LOCATION_WRAPPER]) return true;

						                return false;
						            },

						            get: function (el) {
						                return el[IS_LOCATION_WRAPPER] ? el.href : getUrlAttr(el, 'href');
						            },

						            set: function (el, value) {
						                return el[IS_LOCATION_WRAPPER] ? el.href = _utilsUrl2.default.resolveUrl(value, document) : el.setAttribute('href', value);
						            }
						        },

						        innerHTML: {
						            condition: function (el) {
						                return el.nodeType === 1 && 'innerHTML' in el;
						            },

						            get: function (el) {
						                return Html.cleanUpHtml(el.innerHTML, el.tagName);
						            },

						            set: function (el, value) {
						                if (el.tagName && el.tagName.toLowerCase() === 'style') value = _processingStyle2.default.process('' + value, _utilsUrl2.default.getProxyUrl, true);else if (value !== null) value = Html.processHtml('' + value, el.tagName);

						                el.innerHTML = value;

						                var parentDocument = DOM.findDocument(el);
						                var parentWindow = parentDocument ? parentDocument.defaultView : null;

						                //NOTE: for iframe with empty src
						                if (parentWindow && parentWindow !== window && parentWindow[_const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME]) parentWindow[_const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME](el, parentDocument);else if (window[_const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME]) window[_const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME](el);

						                //NOTE: fix for B239138 - unroll.me 'Cannot read property 'document' of null' error raised during recording
						                //There were an issue then document.body was replaced, so we need to reattach UI to new body manually
						                //See also: ui/ui.js
						                var containerTagName = el.tagName && el.tagName.toLowerCase();

						                //NOTE: this check is required because jQuery calls the set innerHTML method for an element in an unavailable window
						                if (window.self) {
						                    //NOTE: use timeout, so changes take effect
						                    if (containerTagName === 'html' || containerTagName === 'body') {
						                        _nativeMethods2.default.setTimeout.call(window, function () {
						                            onBodyContentChanged(el);
						                        }, 0);
						                    }
						                }

						                return value;
						            }
						        },

						        onerror: {
						            condition: function (owner) {
						                return DOM.isWindowInstance(owner);
						            },

						            get: function (owner) {
						                return owner[ORIGINAL_WINDOW_ON_ERROR_HANDLER_KEY] || null;
						            },

						            set: function (owner, handler) {
						                if (typeof handler === 'function') owner[ORIGINAL_WINDOW_ON_ERROR_HANDLER_KEY] = handler;

						                return handler;
						            }
						        },

						        lastChild: {
						            condition: function (el) {
						                return ShadowUI.isShadowContainer(el);
						            },

						            get: function (el) {
						                return ShadowUI.getLastChild(el);
						            },

						            set: function () {}
						        },

						        lastElementChild: {
						            condition: function (el) {
						                return ShadowUI.isShadowContainer(el);
						            },

						            get: function (el) {
						                return ShadowUI.getLastElementChild(el);
						            },

						            set: function () {}
						        },

						        length: {
						            condition: function (collection) {
						                return ShadowUI.isShadowContainerCollection(collection);
						            },

						            get: function (collection) {
						                var elementCount = 0;

						                for (var i = 0; i < collection.length; i++) {
						                    if (collection[i].className && collection[i].className.indexOf(_const2.default.SHADOW_UI_CLASSNAME_POSTFIX) !== -1) elementCount++;
						                }

						                if (elementCount !== 0) ShadowUI.checkElementsPosition(collection);

						                return collection.length - elementCount;
						            },

						            set: function () {}
						        },

						        location: {
						            condition: function (owner) {
						                return DOM.isDocumentInstance(owner) || DOM.isWindowInstance(owner);
						            },

						            get: function (owner) {
						                if (owner[LOCATION_WRAPPER]) return owner[LOCATION_WRAPPER];

						                var window = DOM.isWindowInstance(owner) ? owner : owner.defaultView;

						                return createLocWrapper(window);
						            },

						            set: function (owner, location) {
						                if (typeof location === 'string') {
						                    if (window.self !== window.top) location = _utilsUrl2.default.resolveUrl(location, window.top.document);

						                    var resourceType = owner !== window.top ? _utilsUrl2.default.IFRAME : null;

						                    owner.location = _utilsUrl2.default.getProxyUrl(location, null, null, null, null, resourceType);

						                    return location;
						                }

						                return owner.location;
						            }
						        },

						        manifest: {
						            condition: function (el) {
						                if (DOM.isDomElement(el)) {
						                    var tagName = el.tagName.toLowerCase();

						                    return _domProcessorDomProcessor2.default.URL_ATTR_TAGS['manifest'].indexOf(tagName) !== -1;
						                }

						                return false;
						            },

						            get: function (el) {
						                return getUrlAttr(el, 'manifest');
						            },

						            set: function (el, value) {
						                return el.setAttribute('manifest', value);
						            }
						        },

						        origin: {
						            condition: function (el) {
						                return isAnchor(el);
						            },

						            get: function (el) {
						                return typeof el.origin !== 'undefined' ? getAnchorProperty(el, 'origin') : el.origin;
						            },

						            set: function (el, origin) {
						                el.origin = origin;

						                return el.origin;
						            }
						        },

						        pathname: {
						            condition: function (el) {
						                return isAnchor(el);
						            },

						            get: function (el) {
						                return getAnchorProperty(el, 'pathname');
						            },

						            set: function (el, pathname) {
						                return setAnchorProperty(el, 'pathname', pathname);
						            }
						        },

						        port: {
						            condition: function (el) {
						                return isAnchor(el);
						            },

						            get: function (el) {
						                return getAnchorProperty(el, 'port');
						            },

						            set: function (el, port) {
						                return setAnchorProperty(el, 'port', port);
						            }
						        },

						        protocol: {
						            condition: function (el) {
						                return isAnchor(el);
						            },

						            get: function (el) {
						                return getAnchorProperty(el, 'protocol');
						            },

						            set: function (el, port) {
						                return setAnchorProperty(el, 'protocol', port);
						            }
						        },

						        referrer: {
						            condition: function (doc) {
						                return DOM.isDocumentInstance(doc);
						            },

						            get: function (doc) {
						                var proxyUrl = _utilsUrl2.default.parseProxyUrl(doc.referrer);
						                var result = proxyUrl ? proxyUrl.originResourceInfo.originUrl : '';

						                return result;
						            },

						            set: function (doc, value) {
						                doc.referrer = _utilsUrl2.default.getProxyUrl(value);

						                return value;
						            }
						        },

						        sandbox: {
						            condition: function (el) {
						                return DOM.isIframe(el);
						            },

						            get: function (el) {
						                return el.getAttribute('sandbox');
						            },

						            set: function (el, value) {
						                return el.setAttribute('sandbox', value);
						            }
						        },

						        search: {
						            condition: function (el) {
						                return isAnchor(el);
						            },

						            get: function (el) {
						                return getAnchorProperty(el, 'search');
						            },

						            set: function (el, search) {
						                return setAnchorProperty(el, 'search', search);
						            }
						        },

						        src: {
						            condition: function (el) {
						                if (DOM.isDomElement(el)) {
						                    var tagName = el.tagName.toLowerCase();

						                    return _domProcessorDomProcessor2.default.URL_ATTR_TAGS['src'].indexOf(tagName) !== -1;
						                }

						                return false;
						            },

						            get: function (el) {
						                return getUrlAttr(el, 'src');
						            },

						            set: function (el, value) {
						                return el.setAttribute('src', value);
						            }
						        },

						        target: {
						            condition: function (el) {
						                return DOM.isDomElement(el) && _domProcessorDomProcessor2.default.TARGET_ATTR_TAGS[el.tagName.toLowerCase()];
						            },

						            get: function (el) {
						                return el.target;
						            },

						            set: function (el, value) {
						                if (value !== '_blank') el.target = value;

						                return el.target;
						            }
						        },

						        text: {
						            condition: function (el) {
						                //NOTE: check for tagName being a string. Because is some cases in Angular app it
						                //may be function.
						                //See: T175340: TD_14_2 - Uncaught JS error on angular getting started site
						                return typeof el.tagName === 'string' && el.tagName.toLowerCase() === 'script';
						            },

						            get: function (el) {
						                return el.text;
						            },

						            set: function (el, script) {
						                el.text = script ? _processingScript2.default.process(script) : script;

						                return script;
						            }
						        },

						        textContent: {
						            condition: function (el) {
						                //NOTE: check for tagName being a string. Because is some cases in Angular app it
						                //may be function.
						                //See: T175340: TD_14_2 - Uncaught JS error on angular getting started site
						                return typeof el.tagName === 'string' && el.tagName.toLowerCase() === 'script';
						            },

						            get: function (el) {
						                return el.textContent;
						            },

						            set: function (el, script) {
						                el.textContent = script ? _processingScript2.default.process(script) : script;

						                return script;
						            }
						        },

						        URL: {
						            condition: function (doc) {
						                return DOM.isDocumentInstance(doc);
						            },

						            get: function () {
						                return locationWrapper.href;
						            },

						            set: function () {}
						        },

						        value: {
						            condition: function (el) {
						                return DOM.isDomElement(el) && (DOM.isFileInput(el) || DOM.isTextEditableElementAndEditingAllowed(el) && !DOM.isShadowUIElement(el));
						            },

						            get: function (el) {
						                if (DOM.isFileInput(el)) return UploadSandbox.getUploadElementValue(el);

						                return el.value;
						            },

						            set: function (el, value) {
						                if (DOM.isFileInput(el)) return UploadSandbox.setUploadElementValue(el, value);

						                el.value = value;

						                ElementEditingWatcher.restartWatchingElementEditing(el);

						                return value;
						            }
						        },

						        // Event
						        onbeforeunload: {
						            condition: function (window) {
						                return DOM.isWindowInstance(window);
						            },

						            get: function () {
						                return Unload.getOnBeforeUnload();
						            },

						            set: function (window, handler) {
						                return Unload.setOnBeforeUnload(window, handler);
						            }
						        },

						        onmessage: {
						            condition: function (window) {
						                return DOM.isWindowInstance(window);
						            },

						            get: function () {
						                return MessageSandbox.getOnMessage();
						            },

						            set: function (window, handler) {
						                return MessageSandbox.setOnMessage(window, handler);
						            }
						        },

						        which: {
						            condition: function (ev) {
						                return typeof ev[_const2.default.EVENT_SANDBOX_WHICH_PROPERTY_WRAPPER] !== 'undefined' || ev.originalEvent && typeof ev.originalEvent[_const2.default.EVENT_SANDBOX_WHICH_PROPERTY_WRAPPER] !== 'undefined';
						            },

						            get: function (ev) {
						                return ev.originalEvent ? ev.originalEvent[_const2.default.EVENT_SANDBOX_WHICH_PROPERTY_WRAPPER] : ev[_const2.default.EVENT_SANDBOX_WHICH_PROPERTY_WRAPPER];
						            },

						            set: function () {}
						        },

						        // Style
						        background: {
						            condition: function (style) {
						                return isStyleInstance(style);
						            },

						            get: function (style) {
						                return _processingStyle2.default.cleanUp(style.background, _utilsUrl2.default.parseProxyUrl, _utilsUrl2.default.formatUrl);
						            },

						            set: function (style, value) {
						                if (typeof value === 'string') style.background = _processingStyle2.default.process(value, _utilsUrl2.default.getProxyUrl);

						                return style.background;
						            }
						        },

						        backgroundImage: {
						            condition: function (style) {
						                return isStyleInstance(style);
						            },

						            get: function (style) {
						                return _processingStyle2.default.cleanUp(style.backgroundImage, _utilsUrl2.default.parseProxyUrl, _utilsUrl2.default.formatUrl);
						            },

						            set: function (style, value) {
						                if (typeof value === 'string') style.backgroundImage = _processingStyle2.default.process(value, _utilsUrl2.default.getProxyUrl);

						                return style.backgroundImage;
						            }
						        },

						        borderImage: {
						            condition: function (style) {
						                return isStyleInstance(style);
						            },

						            get: function (style) {
						                return _processingStyle2.default.cleanUp(style.borderImage, _utilsUrl2.default.parseProxyUrl, _utilsUrl2.default.formatUrl);
						            },

						            set: function (style, value) {
						                if (typeof value === 'string') style.borderImage = _processingStyle2.default.process(value, _utilsUrl2.default.getProxyUrl);

						                return style.borderImage;
						            }
						        },

						        cssText: {
						            condition: function (style) {
						                return isStyleInstance(style);
						            },

						            get: function (style) {
						                return _processingStyle2.default.cleanUp(style.cssText, _utilsUrl2.default.parseProxyUrl, _utilsUrl2.default.formatUrl);
						            },

						            set: function (style, value) {
						                if (typeof value === 'string') style.cssText = _processingStyle2.default.process(value, _utilsUrl2.default.getProxyUrl);

						                return style.cssText;
						            }
						        },

						        cursor: {
						            condition: function (style) {
						                return isStyleInstance(style);
						            },

						            get: function (style) {
						                return _processingStyle2.default.cleanUp(style.cursor, _utilsUrl2.default.parseProxyUrl, _utilsUrl2.default.formatUrl);
						            },

						            set: function (style, value) {
						                if (typeof value === 'string') style.cursor = _processingStyle2.default.process(value, _utilsUrl2.default.getProxyUrl);

						                return style.cursor;
						            }
						        },

						        listStyle: {
						            condition: function (style) {
						                return isStyleInstance(style);
						            },

						            get: function (style) {
						                return _processingStyle2.default.cleanUp(style.listStyle, _utilsUrl2.default.parseProxyUrl, _utilsUrl2.default.formatUrl);
						            },

						            set: function (style, value) {
						                if (typeof value === 'string') style.listStyle = _processingStyle2.default.process(value, _utilsUrl2.default.getProxyUrl);

						                return style.listStyle;
						            }
						        },

						        listStyleImage: {
						            condition: function (style) {
						                return isStyleInstance(style);
						            },

						            get: function (style) {
						                return _processingStyle2.default.cleanUp(style.listStyleImage, _utilsUrl2.default.parseProxyUrl, _utilsUrl2.default.formatUrl);
						            },

						            set: function (style, value) {
						                if (typeof value === 'string') style.listStyleImage = _processingStyle2.default.process(value, _utilsUrl2.default.getProxyUrl);

						                return style.listStyleImage;
						            }
						        }
						    };

						    module.exports.elementPropertyAccessors = elementPropertyAccessors;

						    //NOTE: isolate throw statement into separate function because JS engines doesn't optimize such functions.
						    function error(msg) {
						        throw new Error(msg);
						    }

						    function isNullOrUndefined(obj) {
						        return !obj && (obj === null || typeof obj === 'undefined');
						    }

						    function inaccessibleTypeToStr(obj) {
						        return obj === null ? 'null' : 'undefined';
						    }

						    //Proxy methods
						    function callMethod(owner, methName, args) {
						        if (isNullOrUndefined(owner)) error('Cannot call method \'' + methName + '\' of ' + inaccessibleTypeToStr(owner));

						        if (typeof owner[methName] !== 'function') error('\'' + methName + '\' is not a function');

						        if (typeof methName !== 'string' || !elementMethWrappers.hasOwnProperty(methName)) return owner[methName].apply(owner, args);

						        return elementMethWrappers[methName].condition(owner) ? elementMethWrappers[methName].method(owner, args) : owner[methName].apply(owner, args);
						    }

						    function getLocation(location) {
						        return isLocationInstance(location) ? locationWrapper : location;
						    }

						    function getProperty(owner, propName) {
						        if (isNullOrUndefined(owner)) error('Cannot read property \'' + propName + '\' of ' + inaccessibleTypeToStr(owner));

						        if (typeof propName !== 'string' || !elementPropertyAccessors.hasOwnProperty(propName)) return owner[propName];

						        return elementPropertyAccessors[propName].condition(owner) ? elementPropertyAccessors[propName].get(owner) : owner[propName];
						    }

						    function processScript(script) {
						        return typeof script !== 'string' ? script : _processingJsIndex2.default.process(script);
						    }

						    function setLocation(location, value) {
						        if (isLocationInstance(location)) {
						            location = value;

						            return location;
						        }

						        return null;
						    }

						    function setProperty(owner, propName, value) {
						        if (isNullOrUndefined(owner)) error('Cannot set property \'' + propName + '\' of ' + inaccessibleTypeToStr(owner));

						        var returnValue = null;

						        if (typeof propName !== 'string' || !elementPropertyAccessors.hasOwnProperty(propName)) {
						            returnValue = owner[propName] = value;

						            return returnValue;
						        }

						        if (elementPropertyAccessors[propName].condition(owner)) return elementPropertyAccessors[propName].set(owner, value);

						        returnValue = owner[propName] = value;

						        return returnValue;
						    }

						    window[_processingJsIndex2.default.CALL_METHOD_METH_NAME] = callMethod;
						    window[_processingJsIndex2.default.GET_LOCATION_METH_NAME] = getLocation;
						    window[_processingJsIndex2.default.GET_PROPERTY_METH_NAME] = getProperty;
						    window[_processingJsIndex2.default.PROCESS_SCRIPT_METH_NAME] = processScript;
						    window[_processingJsIndex2.default.SET_LOCATION_METH_NAME] = setLocation;
						    window[_processingJsIndex2.default.SET_PROPERTY_METH_NAME] = setProperty;
						}

						function AttributesWrapper(attributes) {
						    var length = 0;

						    for (var i = 0; i < attributes.length; i++) {
						        var attr = attributes[i];

						        if (!DOM.isHammerheadAttr(attr.name)) {
						            var storedAttrName = attributes[_domProcessorDomProcessor2.default.getStoredAttrName(attr.name)];

						            if (storedAttrName) {
						                attr = attr.cloneNode();
						                attr.value = storedAttrName.value;
						                Object.defineProperty(this, attr.name, { value: attr });
						            }

						            Object.defineProperty(this, length, { value: attr });
						            length++;
						        }
						    }

						    Object.defineProperty(this, 'length', { value: length });

						    this.item = function (index) {
						        return this[index];
						    };

						    for (var funcName in attributes) {
						        if (typeof this[funcName] === 'function' && funcName !== 'item') this[funcName] = attributes[funcName].bind(attributes);
						    }
						}

						function getAttributesProperty(el) {
						    for (var i = 0; i < el.attributes.length; i++) {
						        if (DOM.isHammerheadAttr(el.attributes[i].name)) {
						            AttributesWrapper.prototype = el.attributes;

						            return new AttributesWrapper(el.attributes);
						        }
						    }

						    return el.attributes;
						}
					},
					"event": {
						"element-editing-watcher.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.stopWatching = stopWatching;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsDom = require('../../utils/dom');

							var DOM = _interopRequireWildcard(_utilsDom);

							var _simulator = require('./simulator');

							var EventSimulator = _interopRequireWildcard(_simulator);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _const = require('../../../const');

							var _const2 = _interopRequireDefault(_const);

							var ELEMENT_EDITING_OBSERVED_FLAG = _const2.default.PROPERTY_PREFIX + 'elementEditingObserved';
							var OLD_VALUE_PROPERTY = _const2.default.PROPERTY_PREFIX + 'oldValue';

							function onBlur(e) {
							    var target = e.target || e.srcElement;

							    if (!checkElementChanged(target)) stopWatching(target);
							}

							function onChange(e) {
							    stopWatching(e.target || e.srcElement);
							}

							function watchElement(element) {
							    if (element && !element[ELEMENT_EDITING_OBSERVED_FLAG] && DOM.isTextEditableElementAndEditingAllowed(element) && !DOM.isShadowUIElement(element)) {

							        element[ELEMENT_EDITING_OBSERVED_FLAG] = true;
							        element[OLD_VALUE_PROPERTY] = element.value;

							        _nativeMethods2.default.addEventListener.call(element, 'blur', onBlur);
							        _nativeMethods2.default.addEventListener.call(element, 'change', onChange);
							    }
							}

							function restartWatching(element) {
							    if (element && element[ELEMENT_EDITING_OBSERVED_FLAG]) element[OLD_VALUE_PROPERTY] = element.value;
							}

							function checkElementChanged(element) {
							    if (element && element[ELEMENT_EDITING_OBSERVED_FLAG] && element.value !== element[OLD_VALUE_PROPERTY]) {
							        EventSimulator.change(element);
							        restartWatching(element);

							        return true;
							    }

							    return false;
							}

							function stopWatching(element) {
							    if (element) {

							        _nativeMethods2.default.removeEventListener.call(element, 'blur', onBlur);
							        _nativeMethods2.default.removeEventListener.call(element, 'change', onChange);

							        if (element[ELEMENT_EDITING_OBSERVED_FLAG]) delete element[ELEMENT_EDITING_OBSERVED_FLAG];

							        if (element[OLD_VALUE_PROPERTY]) delete element[OLD_VALUE_PROPERTY];
							    }
							}

							var watchElementEditing = watchElement;
							exports.watchElementEditing = watchElementEditing;
							var restartWatchingElementEditing = restartWatching;
							exports.restartWatchingElementEditing = restartWatchingElementEditing;
							var processElementChanging = checkElementChanged;
							exports.processElementChanging = processElementChanging;
						},
						"event.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.init = init;
							exports.overrideElement = overrideElement;
							exports.initDocumentListening = initDocumentListening;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var _utilsDom = require('../../utils/dom');

							var DOM = _interopRequireWildcard(_utilsDom);

							var _utilsEvent = require('../../utils/event');

							var Event = _interopRequireWildcard(_utilsEvent);

							var _simulator = require('./simulator');

							var EventSimulator = _interopRequireWildcard(_simulator);

							var _focusBlur = require('./focus-blur');

							var FocusBlur = _interopRequireWildcard(_focusBlur);

							var _listeners = require('./listeners');

							var Listeners = _interopRequireWildcard(_listeners);

							var _timeout = require('./timeout');

							var Timeout = _interopRequireWildcard(_timeout);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _selection = require('./selection');

							var Selection = _interopRequireWildcard(_selection);

							var _shadowUi = require('../shadow-ui');

							var ShadowUI = _interopRequireWildcard(_shadowUi);

							var _unload = require('./unload');

							var Unload = _interopRequireWildcard(_unload);

							var _utilsExtend = require('../../utils/extend');

							var _utilsExtend2 = _interopRequireDefault(_utilsExtend);

							var ELEMENT_HAS_ADDITIONAL_EVENT_METHODS = Browser.isIE && Browser.version < 11;

							//wrappers
							function overridedDispatchEvent(ev) {
							    Listeners.beforeDispatchEvent();

							    var res = _nativeMethods2.default.dispatchEvent.call(this, ev);

							    Listeners.afterDispatchEvent();
							    return res;
							}

							function overridedFireEvent(eventName, ev) {
							    var eventType = eventName.substring(0, 2) === 'on' ? eventName.substring(2) : eventName;
							    var createEventType;
							    var res;

							    Listeners.beforeDispatchEvent();

							    //event is 'MSEventObj'
							    if (!ev || !ev.target) {
							        if (/(^mouse\w+$)|^(dbl)?click$|^contextmenu$/.test(eventType)) createEventType = 'MouseEvents';else if (/^key\w+$/.test(eventType)) createEventType = 'Events';else if (/^touch\w+$/.test(eventType)) createEventType = 'TouchEvent';else createEventType = 'Events';

							        if (ev) {
							            ev = _utilsExtend2.default(document.createEvent(createEventType), ev);
							            ev.initEvent(eventType, typeof ev.cancelBubble !== 'undefined' ? ev.cancelBubble : false, true);
							        } else {
							            //NOTE: fire event method can be called with no arguments
							            ev = document.createEvent(createEventType);
							            ev.initEvent(eventType, true, true);
							        }
							    }

							    res = _nativeMethods2.default.dispatchEvent.call(this, ev);
							    Listeners.afterDispatchEvent();
							    return res;
							}

							function overridedAttachEvent(eventName, handler) {
							    _nativeMethods2.default.addEventListener.call(this, eventName.substring(2), handler);
							}

							function overridedDetachEvent(eventName, handler) {
							    _nativeMethods2.default.removeEventListener.call(this, eventName.substring(2), handler);
							}

							function overridedClick() {
							    Listeners.beforeDispatchEvent();

							    if (DOM.isFileInput(this)) EventSimulator.setClickedFileInput(this);

							    var res = EventSimulator.nativeClick(this, _nativeMethods2.default.click);

							    Listeners.afterDispatchEvent();

							    return res;
							}

							function overridedSetSelectionRange() {
							    return Selection.setSelectionRangeWrapper.apply(this, arguments);
							}

							function overridedSelect() {
							    return Selection.selectWrapper.call(this);
							}

							function overridedFocus() {
							    return FocusBlur.focus(this, null, false, false, true);
							}

							function overridedBlur() {
							    return FocusBlur.blur(this, null, false, true);
							}

							function overrideElementOrHTMLElementMethod(methodName, overridedMethod) {
							    if (window.Element && methodName in window.Element.prototype) window.Element.prototype[methodName] = overridedMethod;else if (window.HTMLElement && methodName in window.HTMLElement.prototype) window.HTMLElement.prototype[methodName] = overridedMethod;

							    if (window.Document && methodName in window.Document.prototype) window.Document.prototype[methodName] = overridedMethod;
							}

							// internal handlers
							function onFocus(e) {
							    var focusedEl = e.target;
							    var activeEl = DOM.getActiveElement(document);

							    if (!DOM.isShadowUIElement(focusedEl) && !DOM.isShadowUIElement(activeEl)) ShadowUI.setLastActiveElement(activeEl);
							}

							function cancelInternalEvents(e, dispatched, preventEvent, cancelHandlers, stopPropagation) {
							    // NOTE: we should cancel events raised by native function calling (focus, blur) only if the element has the flag.
							    // If event is dispatched, we shouldn't cancel it.
							    var target = e.target || e.srcElement;
							    var internalEventFlag = FocusBlur.getInternalEventFlag(e.type);

							    if (target[internalEventFlag] && !e[EventSimulator.DISPATCHED_EVENT_FLAG]) stopPropagation();
							}

							function init(window, document) {
							    window.HTMLInputElement.prototype.setSelectionRange = overridedSetSelectionRange;
							    window.HTMLTextAreaElement.prototype.setSelectionRange = overridedSetSelectionRange;

							    overrideElementOrHTMLElementMethod('focus', overridedFocus);
							    overrideElementOrHTMLElementMethod('blur', overridedBlur);
							    overrideElementOrHTMLElementMethod('dispatchEvent', overridedDispatchEvent);

							    if (ELEMENT_HAS_ADDITIONAL_EVENT_METHODS) {
							        overrideElementOrHTMLElementMethod('fireEvent', overridedFireEvent);
							        overrideElementOrHTMLElementMethod('attachEvent', overridedAttachEvent);
							        overrideElementOrHTMLElementMethod('detachEvent', overridedDetachEvent);
							    }

							    if (window.TextRange && window.TextRange.prototype.select) window.TextRange.prototype.select = overridedSelect;

							    initDocumentListening();

							    Listeners.initElementListening(window, Event.DOM_EVENTS.concat(['beforeunload', 'unload', 'message']));

							    Listeners.addInternalEventListener(window, ['focus'], onFocus);
							    Listeners.addInternalEventListener(window, ['focus', 'blur', 'change'], cancelInternalEvents);

							    Unload.init(window, document);
							    Timeout.init(window);
							    FocusBlur.init(window);
							}

							function overrideElement(el, overridePrototypeMeths) {
							    if ('click' in el) el.click = overridedClick;

							    if (overridePrototypeMeths) {
							        el.dispatchEvent = overridedDispatchEvent;

							        if ('focus' in el) {
							            el.focus = overridedFocus;
							            el.blur = overridedBlur;
							        }

							        if ('setSelectionRange' in el) el.setSelectionRange = overridedSetSelectionRange;

							        if (ELEMENT_HAS_ADDITIONAL_EVENT_METHODS) {
							            el.fireEvent = overridedFireEvent;
							            el.attachEvent = overridedAttachEvent;
							            el.detachEvent = overridedDetachEvent;
							        }
							    }

							    if (DOM.isInputElement(el)) {
							        if (Browser.isIE) {
							            // Prevent browser's open file dialog
							            _nativeMethods2.default.addEventListener.call(el, 'click', function (e) {
							                if (DOM.isFileInput(el)) {
							                    if (EventSimulator.getClickedFileInput() === el) {
							                        EventSimulator.setClickedFileInput(null);

							                        return Event.preventDefault(e, true);
							                    }
							                }
							            }, true);
							        }
							    }
							}

							function initDocumentListening() {
							    Listeners.initElementListening(document, Event.DOM_EVENTS);
							}
						},
						"focus-blur.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.init = init;
							exports.focus = focus;
							exports.blur = blur;
							exports.disableOuterFocusHandlers = disableOuterFocusHandlers;
							exports.enableOuterFocusHandlers = enableOuterFocusHandlers;
							exports.getInternalEventFlag = getInternalEventFlag;
							exports.fixHoveredElement = fixHoveredElement;
							exports.freeHoveredElement = freeHoveredElement;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var _utilsDom = require('../../utils/dom');

							var DOM = _interopRequireWildcard(_utilsDom);

							var _elementEditingWatcher = require('./element-editing-watcher');

							var ElementEditingWatcher = _interopRequireWildcard(_elementEditingWatcher);

							var _simulator = require('./simulator');

							var EventSimulator = _interopRequireWildcard(_simulator);

							var _listeners = require('./listeners');

							var Listeners = _interopRequireWildcard(_listeners);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _timeout = require('./timeout');

							var Timeout = _interopRequireWildcard(_timeout);

							var _shadowUi = require('../shadow-ui');

							var ShadowUI = _interopRequireWildcard(_shadowUi);

							var _const = require('../../../const');

							var _const2 = _interopRequireDefault(_const);

							var _utilsStyle = require('../../utils/style');

							var Style = _interopRequireWildcard(_utilsStyle);

							var INTERNAL_FOCUS_FLAG = _const2.default.PROPERTY_PREFIX + 'iff';
							var INTERNAL_BLUR_FLAG = _const2.default.PROPERTY_PREFIX + 'ibf';

							var shouldDisableOuterFocusHandlers = false;
							var currentWindow = null;
							var topWindow = null;
							var hoverElementFixed = false;
							var lastHoveredElement = null;

							function callFocusCallback(callback, el) {
							    //NOTE:in MSEdge event 'selectionchange' doesn't occur immediately (with some delay)
							    //so we should raise it right after 'focus' event
							    if (Browser.isIE && Browser.version > 11 && el && DOM.isTextEditableElement(el)) EventSimulator.selectionchange(el);

							    if (typeof callback === 'function') callback();
							}

							function raiseEvent(element, type, callback, withoutHandlers, isAsync, forMouseEvent, preventScrolling) {
							    //NOTE: focus and blur events should be raised after the activeElement changed (B237489)
							    //in MSEdge focus/blur is sync
							    var simulateEvent = function () {
							        /*eslint-disable indent */
							        if (Browser.isIE && Browser.version < 12) {
							            currentWindow.setTimeout(function () {
							                currentWindow.setTimeout(function () {
							                    if (element[getInternalEventFlag(type)]) delete element[getInternalEventFlag(type)];
							                }, 0);
							            }, 0);
							        } else if (element[getInternalEventFlag(type)]) delete element[getInternalEventFlag(type)];
							        /*eslint-enable indent */

							        if (!withoutHandlers) {
							            /*eslint-disable indent */
							            if (isAsync) {
							                Timeout.deferFunction(function () {
							                    EventSimulator[type](element);
							                });
							            } else EventSimulator[type](element);
							            /*eslint-enable indent */
							        }

							        callback();
							    };

							    //T239149 - TD15.1? - Error occurs during assertion creation on http://knockoutjs.com/examples/helloWorld.html in IE9
							    if (Browser.isIE9 && ShadowUI.getRoot() === element && (type === 'focus' || type === 'blur')) callback();

							    /*eslint-disable indent */
							    if (element[type]) {
							        //NOTE: we should guarantee that activeElement will be changed, therefore we should call native focus/blur
							        // event. To guarantee all focus/blur events raising we should raise it manually too.

							        var windowScroll = null;

							        if (preventScrolling) windowScroll = Style.getElementScroll(currentWindow);

							        var tempElement = null;

							        if (type === 'focus' && element.tagName && element.tagName.toLowerCase() === 'label' && element.htmlFor) {
							            tempElement = DOM.findDocument(element).getElementById(element.htmlFor);
							            if (tempElement) element = tempElement;else {
							                callback();
							                return;
							            }
							        }

							        element[getInternalEventFlag(type)] = true;

							        _nativeMethods2.default[type].call(element);

							        if (preventScrolling) {
							            var newWindowScroll = Style.getElementScroll(currentWindow);

							            if (newWindowScroll.left !== windowScroll.left) Style.setScrollLeft(currentWindow, windowScroll.left);

							            if (newWindowScroll.top !== windowScroll.top) Style.setScrollTop(windowScroll.top);
							        }

							        var curDocument = DOM.findDocument(element);
							        var activeElement = DOM.getActiveElement(curDocument);

							        //if element was not focused and it has parent with tabindex, we focus this parent
							        var parent = element.parentNode;

							        if (type === 'focus' && activeElement !== element && parent !== document && DOM.closest(parent, '[tabindex]') && forMouseEvent) {
							            //NOTE: in WebKit calling of native focus for parent element raised page scrolling, we can't prevent it,
							            // therefore we need to restore page scrolling value
							            raiseEvent(DOM.closest(parent, '[tabindex]'), 'focus', simulateEvent, false, false, forMouseEvent, forMouseEvent && Browser.isWebKit);
							        }
							        // NOTE: some browsers doesn't change document.activeElement after element.blur() if browser window is on background.
							        // That's why we call body.focus() without handlers. It should be called synchronously because client scripts may
							        // expect that document.activeElement will be changed immediately after element.blur() calling.
							        else if (type === 'blur' && activeElement === element && element !== curDocument.body) raiseEvent(curDocument.body, 'focus', simulateEvent, true);else simulateEvent();
							    } else simulateEvent();
							    /*eslint-enable indent */
							}

							function onMouseOverHandler(e) {
							    if (hoverElementFixed || DOM.isShadowUIElement(e.target)) return;

							    // NOTE: In this method, we are looking for a joint parent for the previous and the new hovered element.
							    // Processes need only to that parent. This we are trying to reduce the number of dom calls.

							    var clearHoverMarkerUntilJointParent = function (lastHoveredElement, newHoveredElement) {
							        var jointParent = null;

							        if (lastHoveredElement) {
							            var el = lastHoveredElement;

							            while (el && el.tagName) {
							                // Check that the current element is a joint parent for the hovered elements.
							                /*eslint-disable indent */
							                if (el.contains && !el.contains(newHoveredElement)) {
							                    _nativeMethods2.default.removeAttribute.call(el, _const2.default.HOVER_PSEUDO_CLASS_ATTR);
							                    el = el.parentNode;
							                } else break;
							                /*eslint-enable indent */
							            }

							            jointParent = el;

							            if (jointParent) _nativeMethods2.default.removeAttribute.call(jointParent, _const2.default.HOVER_PSEUDO_CLASS_ATTR);
							        }

							        return jointParent;
							    };

							    var setHoverMarker = function (newHoveredElement, jointParent) {
							        if (jointParent) _nativeMethods2.default.setAttribute.call(jointParent, _const2.default.HOVER_PSEUDO_CLASS_ATTR, '');

							        while (newHoveredElement && newHoveredElement.tagName) {
							            /*eslint-disable indent */
							            // Assign pseudo-class marker up to joint parent.
							            if (newHoveredElement !== jointParent) {
							                _nativeMethods2.default.setAttribute.call(newHoveredElement, _const2.default.HOVER_PSEUDO_CLASS_ATTR, '');
							                newHoveredElement = newHoveredElement.parentNode;
							            } else break;
							            /*eslint-enable indent */
							        }
							    };

							    var jointParent = clearHoverMarkerUntilJointParent(lastHoveredElement, e.target);

							    setHoverMarker(e.target, jointParent);
							}

							function onMouseOut(e) {
							    if (!DOM.isShadowUIElement(e.target)) lastHoveredElement = e.target;
							}

							function init(window) {
							    currentWindow = window;
							    topWindow = DOM.isCrossDomainWindows(currentWindow, currentWindow.top) ? currentWindow : currentWindow.top;

							    Listeners.addInternalEventListener(window, ['mouseover'], onMouseOverHandler);
							    Listeners.addInternalEventListener(window, ['mouseout'], onMouseOut);
							}

							function focus(element, callback, silent, forMouseEvent, isNativeFocus) {
							    if (shouldDisableOuterFocusHandlers && !DOM.isShadowUIElement(element)) return null;

							    var isCurrentElementInIFrame = DOM.isElementInIframe(element);
							    var iFrameElement = isCurrentElementInIFrame ? DOM.getIFrameByElement(element) : null;
							    var curDocument = DOM.findDocument(element);
							    var withoutHandlers = element === curDocument.body && !Browser.isIE;

							    // NOTE: in IE if you call focus() or blur() methods from script, active element is changed immediately
							    // but events are raised asynchronously after some timeout
							    var isAsync = false;

							    var raiseFocusEvent = function () {
							        raiseEvent(element, 'focus', function () {
							            if (!silent) ElementEditingWatcher.watchElementEditing(element);

							            // NOTE: If we call focus for unfocusable element (like 'div' or 'image') in iframe we should make
							            // document.active this iframe manually, so we call focus without handlers
							            /*eslint-disable indent */
							            if (isCurrentElementInIFrame && iFrameElement && topWindow.document.activeElement !== iFrameElement) {
							                raiseEvent(iFrameElement, 'focus', function () {
							                    callFocusCallback(callback, element);
							                }, true, isAsync);
							            } else callFocusCallback(callback, element);
							            /*eslint-enable indent */
							        }, withoutHandlers || silent, isAsync, forMouseEvent);
							    };

							    if (isNativeFocus && Browser.isIE) {
							        //in IE focus() method does not have any effect if it is called from focus event handler on second event phase
							        if ((EventSimulator.isSavedWindowsEventsExists() || Browser.isIE && Browser.version > 10) && currentWindow.event && currentWindow.event.type === 'focus' && currentWindow.event.srcElement === element) {
							            callFocusCallback(callback);

							            return null;
							        }

							        if (Browser.version < 12) //in MSEdge focus/blur is sync
							            isAsync = true;
							    }

							    var activeElement = DOM.getActiveElement();
							    var activeElementDocument = DOM.findDocument(activeElement);
							    var needBlur = false;
							    var needBlurIFrame = false;

							    if (activeElement && activeElement.tagName) {
							        /*eslint-disable indent */
							        if (activeElement === element) withoutHandlers = true;else if (curDocument !== activeElementDocument && activeElement === activeElementDocument.body) //B253685
							            needBlur = false;else if (activeElement === curDocument.body) {
							            //Blur event raised for body only in IE. In addition, we must not call blur function for body because
							            //this leads to browser window moving to background
							            if (!silent && Browser.isIE) {
							                var simulateBodyBlur = EventSimulator.blur.bind(EventSimulator, activeElement);

							                if (isAsync) Timeout.internalSetTimeout.call(currentWindow, simulateBodyBlur, 0);else simulateBodyBlur();
							            }
							        } else needBlur = true;
							        /*eslint-enable indent */

							        //B254260
							        needBlurIFrame = curDocument !== activeElementDocument && DOM.isElementInIframe(activeElement, activeElementDocument);
							    }

							    //NOTE: we always call blur for iframe manually without handlers (B254260)
							    /*eslint-disable indent */
							    if (needBlurIFrame && !needBlur) {
							        if (Browser.isIE) {
							            //NOTE: We should call blur for iframe with handlers in IE
							            //but we can't call method 'blur' because activeElement !== element and handlers will not be called
							            EventSimulator.blur(DOM.getIFrameByElement(activeElement));
							            raiseFocusEvent();
							        } else blur(DOM.getIFrameByElement(activeElement), raiseFocusEvent, true, isNativeFocus);
							    } else if (needBlur) {
							        blur(activeElement, function () {
							            if (needBlurIFrame) blur(DOM.getIFrameByElement(activeElement), raiseFocusEvent, true, isNativeFocus);else raiseFocusEvent();
							        }, silent, isNativeFocus);
							    } else raiseFocusEvent();
							    /*eslint-enable indent */
							}

							function blur(element, callback, withoutHandlers, isNativeBlur) {
							    var activeElement = DOM.getActiveElement(DOM.findDocument(element));
							    //in IE if you call focus() or blur() methods from script, active element is changed immediately
							    // but events are raised asynchronously after some timeout (in MSEdge focus/blur is sync)
							    var isAsync = isNativeBlur && Browser.isIE && Browser.version < 12;

							    if (activeElement !== element) withoutHandlers = true;

							    if (!withoutHandlers) {
							        ElementEditingWatcher.processElementChanging(element);
							        ElementEditingWatcher.stopWatching(element);
							    }

							    raiseEvent(element, 'blur', function () {
							        if (typeof callback === 'function') callback();
							    }, withoutHandlers, isAsync);
							}

							function disableOuterFocusHandlers() {
							    shouldDisableOuterFocusHandlers = true;
							}

							function enableOuterFocusHandlers() {
							    shouldDisableOuterFocusHandlers = false;
							}

							function getInternalEventFlag(type) {
							    return type === 'focus' ? INTERNAL_FOCUS_FLAG : INTERNAL_BLUR_FLAG;
							}

							function fixHoveredElement() {
							    hoverElementFixed = true;
							}

							function freeHoveredElement() {
							    hoverElementFixed = false;
							}
						},
						"listeners.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.initElementListening = initElementListening;
							exports.restartElementListening = restartElementListening;
							exports.initDocumentBodyListening = initDocumentBodyListening;
							exports.cancelElementListening = cancelElementListening;
							exports.beforeDispatchEvent = beforeDispatchEvent;
							exports.afterDispatchEvent = afterDispatchEvent;
							exports.setEventListenerWrapper = setEventListenerWrapper;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsDom = require('../../utils/dom');

							var DOM = _interopRequireWildcard(_utilsDom);

							var _utilsEvent = require('../../utils/event');

							var Event = _interopRequireWildcard(_utilsEvent);

							var _listeningContext = require('./listening-context');

							var ListeningCtx = _interopRequireWildcard(_listeningContext);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _utilsEventEmitter = require('../../utils/event-emitter');

							var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

							var EVENT_LISTENER_ATTACHED_EVENT = 'eventListenerAttached';

							exports.EVENT_LISTENER_ATTACHED_EVENT = EVENT_LISTENER_ATTACHED_EVENT;
							var LISTENED_EVENTS = ['click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'mousemove', 'mouseover', 'mouseout', 'pointerdown', 'pointermove', 'pointerover', 'pointerout', 'pointerup', 'MSPointerDown', 'MSPointerMove', 'MSPointerOver', 'MSPointerOut', 'MSPointerUp', 'touchstart', 'touchmove', 'touchend', 'keydown', 'keypress', 'keyup', 'change', 'focus', 'blur', 'focusin', 'focusout'];

							var EVENT_SANDBOX_DISPATCH_EVENT_FLAG = 'tc-sdef-310efb6b';

							var eventEmitter = new _utilsEventEmitter2.default();

							function eventHandler(e) {
							    //NOTE: fix for the bug in firefox (https://bugzilla.mozilla.org/show_bug.cgi?id=1161548).
							    //An exception is raised when try to get any property from the event object in some cases.
							    var type = '';

							    try {
							        type = e.type;
							    } catch (err) {
							        return;
							    }

							    var el = this;
							    var eventPrevented = false;
							    var handlersCancelled = false;
							    var stopPropagationCalled = false;
							    var eventCtx = ListeningCtx.getEventCtx(el, type);
							    var internalHandlers = eventCtx ? eventCtx.internalHandlers : [];

							    eventCtx.cancelOuterHandlers = false;

							    var preventEvent = function () {
							        eventPrevented = true;
							        Event.preventDefault(e);
							    };

							    var cancelHandlers = function () {
							        if (!handlersCancelled) eventCtx.cancelOuterHandlers = true;

							        handlersCancelled = true;
							    };

							    var stopPropagation = function () {
							        stopPropagationCalled = true;

							        Event.stopPropagation(e);
							    };

							    for (var i = 0; i < internalHandlers.length; i++) {
							        internalHandlers[i].call(el, e, !!window[EVENT_SANDBOX_DISPATCH_EVENT_FLAG], preventEvent, cancelHandlers, stopPropagation);

							        if (eventPrevented || stopPropagationCalled) break;
							    }
							}

							function getEventListenerWrapper(eventCtx, listener) {
							    return function (e) {
							        if (eventCtx.cancelOuterHandlers) return null;

							        if (typeof eventCtx.outerHandlersWrapper === 'function') return eventCtx.outerHandlersWrapper.call(this, e, listener);

							        if (typeof listener === 'object' && typeof listener.handleEvent === 'function') return listener.handleEvent.call(listener, e);

							        return listener.call(this, e);
							    };
							}

							function getBodyEventListenerWrapper(documentEventCtx, listener) {
							    return function (e) {
							        if (documentEventCtx.cancelOuterHandlers) return null;

							        return listener.call(this, e);
							    };
							}

							function getNativeAddEventListener(el) {
							    if (DOM.isWindowInstance(el)) return _nativeMethods2.default.windowAddEventListener;

							    return typeof el.body !== 'undefined' ? _nativeMethods2.default.documentAddEventListener : _nativeMethods2.default.addEventListener;
							}

							function getNativeRemoveEventListener(el) {
							    if (DOM.isWindowInstance(el)) return _nativeMethods2.default.windowRemoveEventListener;

							    return typeof el.body !== 'undefined' ? _nativeMethods2.default.documentRemoveEventListener : _nativeMethods2.default.removeEventListener;
							}

							var on = eventEmitter.on.bind(eventEmitter);
							exports.on = on;
							var off = eventEmitter.off.bind(eventEmitter);

							exports.off = off;

							function initElementListening(el, events) {
							    var nativeAddEventListener = getNativeAddEventListener(el);
							    var nativeRemoveEventListener = getNativeRemoveEventListener(el);

							    events = events || LISTENED_EVENTS;

							    ListeningCtx.addListeningElement(el, events);

							    for (var i = 0; i < events.length; i++) nativeAddEventListener.call(el, events[i], eventHandler, true);

							    el.addEventListener = function (type, listener, useCapture) {
							        var eventListeningInfo = ListeningCtx.getEventCtx(el, type);

							        if (!eventListeningInfo) return nativeAddEventListener.call(this, type, listener, useCapture);

							        //T233158 - Wrong test run for mouse click in IE
							        var isDifferentHandler = eventListeningInfo.outerHandlers.every(function (value) {
							            return value.fn !== listener || value.useCapture !== useCapture;
							        });

							        if (!isDifferentHandler) return null;

							        var wrapper = getEventListenerWrapper(eventListeningInfo, listener);

							        ListeningCtx.wrapEventListener(eventListeningInfo, listener, wrapper, useCapture);

							        var res = nativeAddEventListener.call(this, type, wrapper, useCapture);

							        eventEmitter.emit(EVENT_LISTENER_ATTACHED_EVENT, {
							            el: this,
							            eventType: type,
							            listener: listener
							        });

							        return res;
							    };

							    el.removeEventListener = function (type, listener, useCapture) {
							        var eventCtx = ListeningCtx.getEventCtx(this, type);

							        if (!eventCtx) return nativeRemoveEventListener.call(this, type, listener, useCapture);

							        return nativeRemoveEventListener.call(this, type, ListeningCtx.getWrapper(eventCtx, listener, useCapture), useCapture);
							    };
							}

							function restartElementListening(el) {
							    var nativeAddEventListener = getNativeAddEventListener(el);
							    var elementCtx = ListeningCtx.getElementCtx(el);

							    if (elementCtx) {
							        Object.keys(elementCtx).forEach(function (event) {
							            nativeAddEventListener.call(el, event, eventHandler, true);
							        });
							    }
							}

							function initDocumentBodyListening(doc) {
							    var events = Event.DOM_EVENTS;

							    var nativeAddEventListener = (function () {
							        return doc.body.addEventListener;
							    })();

							    var nativeRemoveEventListener = (function () {
							        return doc.body.removeEventListener;
							    })();

							    ListeningCtx.addListeningElement(doc.body, events);

							    doc.body.addEventListener = function (type, listener, useCapture) {
							        var docEventListeningInfo = ListeningCtx.getEventCtx(doc, type);
							        var eventListeningInfo = ListeningCtx.getEventCtx(this, type);

							        if (!docEventListeningInfo) return nativeAddEventListener.call(this, type, listener, useCapture);

							        //T233158 - Wrong test run for mouse click in IE
							        var isDifferentHandler = eventListeningInfo.outerHandlers.every(function (value) {
							            return value.fn !== listener || value.useCapture !== useCapture;
							        });

							        if (!isDifferentHandler) return null;

							        var wrapper = getBodyEventListenerWrapper(docEventListeningInfo, listener);

							        ListeningCtx.wrapEventListener(eventListeningInfo, listener, wrapper, useCapture);

							        var res = nativeAddEventListener.call(this, type, wrapper, useCapture);

							        eventEmitter.emit(EVENT_LISTENER_ATTACHED_EVENT, {
							            el: this,
							            eventType: type,
							            listener: listener
							        });

							        return res;
							    };

							    doc.body.removeEventListener = function (type, listener, useCapture) {
							        var eventListeningInfo = ListeningCtx.getEventCtx(this, type);

							        if (!eventListeningInfo) return nativeRemoveEventListener.call(this, type, listener, useCapture);

							        return nativeRemoveEventListener.call(this, type, ListeningCtx.getWrapper(eventListeningInfo, listener, useCapture), useCapture);
							    };
							}

							function cancelElementListening(el) {
							    ListeningCtx.removeListeningElement(el);

							    if (el.body) ListeningCtx.removeListeningElement(el.body);
							}

							function beforeDispatchEvent() {
							    window[EVENT_SANDBOX_DISPATCH_EVENT_FLAG] = (window[EVENT_SANDBOX_DISPATCH_EVENT_FLAG] || 0) + 1;
							}

							function afterDispatchEvent() {
							    window[EVENT_SANDBOX_DISPATCH_EVENT_FLAG]--;

							    if (!window[EVENT_SANDBOX_DISPATCH_EVENT_FLAG]) delete window[EVENT_SANDBOX_DISPATCH_EVENT_FLAG];
							}

							function setEventListenerWrapper(el, events, wrapper) {
							    if (!ListeningCtx.isElementListening(el)) initElementListening(el, events);

							    for (var i = 0; i < events.length; i++) {
							        var eventListeningInfo = ListeningCtx.getEventCtx(el, events[i]);

							        eventListeningInfo.outerHandlersWrapper = wrapper;
							    }
							}

							var addInternalEventListener = ListeningCtx.addInternalHandler;
							exports.addInternalEventListener = addInternalEventListener;
							var addFirstInternalHandler = ListeningCtx.addFirstInternalHandler;
							exports.addFirstInternalHandler = addFirstInternalHandler;
							var removeInternalEventListener = ListeningCtx.removeInternalHandler;
							exports.removeInternalEventListener = removeInternalEventListener;
						},
						"listening-context.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.getElementCtx = getElementCtx;
							exports.getEventCtx = getEventCtx;
							exports.isElementListening = isElementListening;
							exports.addListeningElement = addListeningElement;
							exports.removeListeningElement = removeListeningElement;
							exports.addFirstInternalHandler = addFirstInternalHandler;
							exports.addInternalHandler = addInternalHandler;
							exports.removeInternalHandler = removeInternalHandler;
							exports.wrapEventListener = wrapEventListener;
							exports.getWrapper = getWrapper;

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							// for internal using Listeners

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var ELEMENT_LISTENING_EVENTS_STORAGE_PROP = 'tc_eles_bef23a16';

							function getElementCtx(el) {
							    return el[ELEMENT_LISTENING_EVENTS_STORAGE_PROP];
							}

							function getEventCtx(el, event) {
							    event = Browser.isIE && Browser.version > 10 && /MSPointer/.test(event) ? event.replace('MS', '').toLowerCase() : event;

							    return getElementCtx(el)[event] || null;
							}

							function isElementListening(el) {
							    return !!el[ELEMENT_LISTENING_EVENTS_STORAGE_PROP];
							}

							function addListeningElement(el, events) {
							    var elementCtx = getElementCtx(el) || {};

							    for (var i = 0; i < events.length; i++) {
							        if (!elementCtx[events[i]]) {
							            elementCtx[events[i]] = {
							                internalHandlers: [],
							                outerHandlers: [],
							                outerHandlersWrapper: null,
							                wrappers: [],
							                cancelOuterHandlers: false
							            };
							        }
							    }

							    if (!isElementListening(el)) el[ELEMENT_LISTENING_EVENTS_STORAGE_PROP] = elementCtx;
							}

							function removeListeningElement(el) {
							    delete el[ELEMENT_LISTENING_EVENTS_STORAGE_PROP];
							}

							function addFirstInternalHandler(el, events, handler) {
							    var elementCtx = getElementCtx(el);

							    for (var i = 0; i < events.length; i++) elementCtx[events[i]].internalHandlers.unshift(handler);
							}

							function addInternalHandler(el, events, handler) {
							    var elementCtx = getElementCtx(el);

							    for (var i = 0; i < events.length; i++) elementCtx[events[i]].internalHandlers.push(handler);
							}

							function removeInternalHandler(el, events, handler) {
							    var elementCtx = getElementCtx(el);

							    for (var i = 0; i < events.length; i++) {
							        var internalHandlers = elementCtx[events[i]].internalHandlers;
							        var handlerIndex = internalHandlers.indexOf(handler);

							        if (handlerIndex > -1) internalHandlers.splice(handlerIndex, 1);
							    }
							}

							function wrapEventListener(eventCtx, listener, wrapper, useCapture) {
							    eventCtx.outerHandlers.push({
							        fn: listener,
							        useCapture: useCapture || false
							    });
							    eventCtx.wrappers.push(wrapper);
							}

							function getWrapper(eventCtx, listener, useCapture) {
							    var originListeners = eventCtx.outerHandlers;
							    var wrappers = eventCtx.wrappers;
							    var wrapper = null;

							    for (var i = 0; i < originListeners.length; i++) {
							        var curListener = originListeners[i];

							        if (curListener.fn === listener && (curListener.useCapture || false) === (useCapture || false)) {
							            wrapper = wrappers[i];

							            wrappers.splice(i, 1);
							            originListeners.splice(i, 1);

							            return wrapper;
							        }
							    }
							}
						},
						"selection.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.setSelectionRangeWrapper = setSelectionRangeWrapper;
							exports.setSelection = setSelection;
							exports.getSelection = getSelection;
							exports.wrapSetterSelection = wrapSetterSelection;
							exports.selectWrapper = selectWrapper;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var _utilsDom = require('../../utils/dom');

							var DOM = _interopRequireWildcard(_utilsDom);

							var _simulator = require('./simulator');

							var EventSimulator = _interopRequireWildcard(_simulator);

							var _focusBlur = require('./focus-blur');

							var FocusBlur = _interopRequireWildcard(_focusBlur);

							var _listeners = require('./listeners');

							var Listeners = _interopRequireWildcard(_listeners);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _timeout = require('./timeout');

							var Timeout = _interopRequireWildcard(_timeout);

							function needChangeInputType(el) {
							    var tagName = el.tagName ? el.tagName.toLowerCase() : '';

							    return tagName === 'input' && (Browser.isWebKit && /^(number|email)$/.test(el.type));
							}

							function setSelectionRangeWrapper() {
							    var selectionStart = arguments[0];
							    var selectionEnd = arguments[1];
							    var selectionDirection = arguments[2] || 'none';
							    var element = this;

							    var isTextArea = this.tagName && this.tagName.toLowerCase() === 'textarea';
							    var fn = isTextArea ? _nativeMethods2.default.textAreaSetSelectionRange : _nativeMethods2.default.setSelectionRange;
							    var activeElement = DOM.getActiveElement(DOM.findDocument(element));
							    var isElementActive = false;

							    var selectionSetter = function () {
							        var changeType = needChangeInputType(element);
							        var savedType = element.type;
							        var res;

							        if (changeType) element.type = 'text';

							        //NOTE: in MSEdge error raised when setSelectionRange method calls for input with 'display = none' and selectionStart !== selectionEnd
							        //in other IEs error don't raise but selectionStart === selectionEnd === 0 in result
							        try {
							            res = fn.call(element, selectionStart, selectionEnd, selectionDirection);
							        } catch (e) {
							            res = fn.call(element, 0, 0, selectionDirection);
							        }

							        if (changeType) {
							            element.type = savedType;
							            //HACK: (the problem after Chrome update to v.33.0.1750.117, and in Mozilla 29.0 for input with type 'number' T101195)
							            // To set right selection we should change input type to text if it's 'number' or 'email' and restore it after (B254340).
							            // But type changing is async in this case, so we should call blur to raise it (and focus to restore activeElement).
							            if (isElementActive) {
							                FocusBlur.blur(element, null, true);
							                FocusBlur.focus(element, null, true);
							            }
							        }

							        //NOTE:in MSEdge event 'selectionchange' doesn't occur immediately (with some delay)
							        //so we should raise it right after 'setSelectionRange' method
							        if (Browser.isIE && Browser.version > 11) EventSimulator.selectionchange(element);

							        return res;
							    };

							    if (activeElement === element) {
							        isElementActive = true;
							        return selectionSetter();
							    }

							    //setSelectionRange leads to element focusing only in IE
							    return wrapSetterSelection(element, selectionSetter, Browser.isIE && Browser.version < 12);
							}

							function setSelection(el, start, end, direction) {
							    if (el.setSelectionRange) el.setSelectionRange(start, end, direction);else {
							        el.selectionStart = start;
							        el.selectionEnd = end;
							    }
							}

							function getSelection(el) {
							    var changeType = needChangeInputType(el);
							    var activeElement = DOM.getActiveElement(DOM.findDocument(el));
							    var isElementActive = activeElement === el;
							    var savedType = el.type;
							    var selection = null;

							    //HACK: (the problem after Chrome update to v.33.0.1750.117, and in Mozilla 29.0 for input with type 'number' T101195)
							    // To get selection we should change input type to text if it's 'number' or 'email' (B254340).
							    // But type changing is async in this case, so we should call blur to raise it (and focus to restore activeElement).
							    if (changeType) {
							        if (isElementActive) FocusBlur.blur(el, null, true);

							        el.type = 'text';
							    }

							    if (DOM.isInputWithoutSelectionPropertiesInMozilla(el)) {
							        selection = {
							            start: 0,
							            end: 0,
							            direction: 'forward'
							        };
							    } else {
							        selection = {
							            start: el.selectionStart,
							            end: el.selectionEnd,
							            direction: el.selectionDirection
							        };
							    }

							    if (changeType) {
							        el.type = savedType;

							        if (isElementActive) FocusBlur.focus(el, null, true);
							    }

							    return selection;
							}

							function wrapSetterSelection(element, selectionSetter, needFocus, isContentEditable) {
							    var curDocument = DOM.findDocument(element);
							    var activeElement = null;
							    var result = null;
							    var focusRaised = false;
							    var focusHandler = function (e) {
							        if (e.target === element || element.style.display === 'none') focusRaised = true;
							    };

							    if (needFocus) Listeners.addInternalEventListener(document, ['focus'], focusHandler);

							    //focus and blur events
							    Listeners.beforeDispatchEvent();
							    Listeners.beforeDispatchEvent();

							    result = selectionSetter();

							    //focus and blur events
							    Listeners.afterDispatchEvent();
							    Listeners.afterDispatchEvent();

							    if (needFocus) {
							        activeElement = DOM.getActiveElement(curDocument);

							        if (Browser.isWebKit && activeElement !== element) {
							            if (focusRaised) element[FocusBlur.getInternalEventFlag('focus')] = true;

							            element.focus();
							        }

							        //in MSEdge focus/blur is sync
							        if (Browser.isIE && Browser.version < 12) Timeout.internalSetTimeout.call(window, function () {
							            Timeout.internalSetTimeout.call(window, function () {
							                Listeners.removeInternalEventListener(document, ['focus'], focusHandler);

							                if (!focusRaised) EventSimulator.focus(element);
							            }, 0);
							        }, 0);else {
							            Listeners.removeInternalEventListener(document, ['focus'], focusHandler);

							            if (!focusRaised) {
							                //NOTE: in Mozilla calling dispatchEvent 'focus' does active element.
							                // We should call native focus method.
							                if (isContentEditable && Browser.isMozilla) FocusBlur.focus(element, null, true, false, true);else EventSimulator.focus(element);
							            }
							        }
							    }
							    return result;
							}

							function selectWrapper() {
							    var element = this.parentElement();

							    if (!element || DOM.getActiveElement(DOM.findDocument(element)) === element) return _nativeMethods2.default.select.call(this);

							    var result = null;
							    var focusRaised = false;
							    var focusHandler = function (e) {
							        if (e.target === element || element.style.display === 'none') focusRaised = true;
							    };

							    Listeners.addInternalEventListener(document, ['focus'], focusHandler);

							    result = _nativeMethods2.default.select.call(this);

							    Timeout.internalSetTimeout.call(window, function () {
							        Timeout.internalSetTimeout.call(window, function () {
							            Listeners.removeInternalEventListener(document, ['focus'], focusHandler);

							            if (!focusRaised) EventSimulator.focus(element);
							        }, 0);
							    }, 0);

							    return result;
							}
						},
						"simulator.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.click = click;
							exports.nativeClick = nativeClick;
							exports.dblclick = dblclick;
							exports.rightclick = rightclick;
							exports.contextmenu = contextmenu;
							exports.mousedown = mousedown;
							exports.mouseup = mouseup;
							exports.mouseover = mouseover;
							exports.mousemove = mousemove;
							exports.mouseout = mouseout;
							exports.keypress = keypress;
							exports.keyup = keyup;
							exports.keydown = keydown;
							exports.input = input;
							exports.blur = blur;
							exports.focus = focus;
							exports.change = change;
							exports.submit = submit;
							exports.selectionchange = selectionchange;
							exports.touchstart = touchstart;
							exports.touchend = touchend;
							exports.touchmove = touchmove;
							exports.isSavedWindowsEventsExists = isSavedWindowsEventsExists;
							exports.getClickedFileInput = getClickedFileInput;
							exports.setClickedFileInput = setClickedFileInput;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var _utilsDom = require('../../utils/dom');

							var DOM = _interopRequireWildcard(_utilsDom);

							var _utilsEvent = require('../../utils/event');

							var Event = _interopRequireWildcard(_utilsEvent);

							var _utilsExtend = require('../../utils/extend');

							var _utilsExtend2 = _interopRequireDefault(_utilsExtend);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _utilsPosition = require('../../utils/position');

							var Position = _interopRequireWildcard(_utilsPosition);

							var _const = require('../../../const');

							var _const2 = _interopRequireDefault(_const);

							var _utilsStyle = require('../../utils/style');

							var Style = _interopRequireWildcard(_utilsStyle);

							var DISPATCHED_EVENT_FLAG = _const2.default.PROPERTY_PREFIX + 'def';

							exports.DISPATCHED_EVENT_FLAG = DISPATCHED_EVENT_FLAG;
							var IE_BUTTONS_MAP = {
							    0: 1,
							    1: 4,
							    2: 2
							};
							var POINTER_EVENT_BUTTON = {
							    NO_BUTTON: -1,
							    LEFT_BUTTON: 0,
							    RIGHT_BUTTON: 2
							};
							var KEY_EVENT_NAME_RE = /^key\w+$/;
							var MOUSE_EVENT_NAME_RE = /^((mouse\w+)|((dbl)?click)|(contextmenu))$/;
							var TOUCH_EVENT_NAME_RE = /^touch\w+$/;

							var touchIdentifier = Date.now();
							var clickedFileInput = null;
							// NOTE: (IE only) if some event dispatching raised native click function calling we should remove window.event property
							// (that was set in the raiseDispatchEvent function). Otherwise the window.event property will be equal dispatched event
							// but not native click event. After click we should restore it. (B237144)
							var savedWindowEvents = [];
							var savedNativeClickCount = 0;

							function simulateEvent(el, event, userOptions, options) {
							    var args = null;
							    var dispatch = null;
							    // NOTE: we don't emulate click on link with modifiers (ctrl, shift, ctrl+shift, alt),
							    // because it causes the opening of additional tabs and window in browser or loading files
							    var isClickOnLink = event === 'click' && el.tagName && el.tagName.toLocaleLowerCase() === 'a';
							    var opts = _utilsExtend2.default(userOptions ? {
							        clientX: userOptions.clientX,
							        clientY: userOptions.clientY,
							        altKey: isClickOnLink ? false : userOptions.alt,
							        shiftKey: isClickOnLink ? false : userOptions.shift,
							        ctrlKey: isClickOnLink ? false : userOptions.ctrl,
							        metaKey: userOptions.meta,
							        button: userOptions.button,
							        which: userOptions.which,
							        buttons: userOptions.buttons,
							        relatedTarget: userOptions.relatedTarget
							    } : {}, options || {});

							    if (!opts.relatedTarget) opts.relatedTarget = document.body;

							    if (MOUSE_EVENT_NAME_RE.test(event)) {
							        if (userOptions && typeof userOptions.button !== 'undefined') opts = _utilsExtend2.default(opts, { button: userOptions.button });

							        args = getMouseEventArgs(event, opts);
							        dispatch = dispatchMouseEvent;
							    } else if (KEY_EVENT_NAME_RE.test(event)) {
							        if (userOptions && (typeof userOptions.keyCode !== 'undefined' || typeof userOptions.charCode !== 'undefined')) {
							            opts = _utilsExtend2.default(opts, {
							                keyCode: userOptions.keyCode || 0,
							                charCode: userOptions.charCode || 0
							            });
							        }

							        args = getKeyEventArgs(event, opts);
							        dispatch = dispatchKeyEvent;
							    } else if (TOUCH_EVENT_NAME_RE.test(event)) {
							        args = getTouchEventArgs(event, _utilsExtend2.default(opts, { target: el }));
							        dispatch = dispatchTouchEvent;
							    }

							    return dispatch(el, args);
							}

							function getMouseEventArgs(type, options) {
							    var opts = options || {};

							    return _utilsExtend2.default(getUIEventArgs(type, options), {
							        screenX: opts.screenX || 0,
							        screenY: opts.screenY || 0,
							        clientX: opts.clientX || 0,
							        clientY: opts.clientY || 0,
							        button: typeof opts.button === 'undefined' ? Event.BUTTON.LEFT : opts.button,
							        buttons: typeof opts.buttons === 'undefined' ? Event.BUTTONS_PARAMETER.LEFT_BUTTON : opts.buttons,
							        relatedTarget: opts.relatedTarget || null,
							        which: typeof opts.which === 'undefined' ? Event.WHICH_PARAMETER.LEFT_BUTTON : opts.which
							    });
							}

							function getKeyEventArgs(type, options) {
							    var opts = options || {};

							    return _utilsExtend2.default(getUIEventArgs(type, options), {
							        keyCode: opts.keyCode || 0,
							        charCode: opts.charCode || 0,
							        which: type === 'press' ? opts.charCode : opts.keyCode
							    });
							}

							function getTouchEventArgs(type, options) {
							    var opts = options || {};
							    var args = _utilsExtend2.default(getUIEventArgs(type, opts), {
							        screenX: opts.screenX || 0,
							        screenY: opts.screenY || 0,
							        clientX: opts.clientX || 0,
							        clientY: opts.clientY || 0,
							        pageX: opts.clientX || 0,
							        pageY: opts.clientY || 0
							    });

							    if (Browser.isIOS) {
							        args.touch = document.createTouch(args.view, options.target, getTouchIdentifier(args.type), args.clientX, args.clientY, 0, 0);
							    } else {
							        args.touch = document.createTouch(args.view, options.target, getTouchIdentifier(args.type), args.pageX, args.pageY, args.screenX, args.screenY, args.clientX, args.clientY, null, null, typeof args.rotation === 'undefined' ? 0 : args.rotation); //B237995
							    }

							    args.changedTouches = document.createTouchList(args.touch);
							    args.touches = args.type === 'touchend' ? document.createTouchList() : args.changedTouches; //T170088
							    args.targetTouches = args.touches;

							    return args;
							}

							function getUIEventArgs(type, options) {
							    var opts = options || {};

							    return {
							        type: type,
							        canBubble: opts.canBubble !== false,
							        cancelable: opts.cancelable !== false,
							        view: opts.view || window,
							        detail: opts.detail || 0,
							        ctrlKey: opts.ctrlKey || false,
							        altKey: opts.altKey || false,
							        shiftKey: opts.shiftKey || false,
							        metaKey: opts.metaKey || false
							    };
							}

							function getTouchIdentifier(type) {
							    //NOTE: a touch point is created on 'touchstart' event. When it's moved its id should not be changed (T112153)
							    if (type === 'touchstart') touchIdentifier++;

							    return touchIdentifier;
							}

							function raiseNativeClick(el, originClick) {
							    //B254199
							    var curWindow = DOM.isElementInIframe(el) ? DOM.getIFrameByElement(el).contentWindow : window;

							    if (Browser.isIE && Browser.version < 11) delete curWindow.event;

							    originClick.call(el);

							    if (Browser.isIE && Browser.version < 11) {
							        if (savedNativeClickCount--) savedWindowEvents.shift();

							        if (savedWindowEvents.length) {
							            Object.defineProperty(curWindow, 'event', {
							                get: function () {
							                    return savedWindowEvents[0];
							                },

							                configurable: true
							            });
							        }
							    }
							}

							function dispatchEvent(el, name, flag) {
							    var ev = null;

							    if (document.createEvent) {
							        ev = document.createEvent('Events');

							        // NOTE: the dispatchEvent funciton is used for events specific to one element (focus, blur, change, input, submit),
							        // so we set the 'bubbling' (the second) argument to false (T229732)
							        ev.initEvent(name, false, true);

							        if (flag) ev[flag] = true;

							        return raiseDispatchEvent(el, ev);
							    }
							}

							function dispatchMouseEvent(el, args) {
							    var ev = null;
							    var pointerRegExp = /mouse(down|up|move|over|out)/;

							    //NOTE: in IE submit doesn't work if a click is emulated for some submit button's children (for example img, B236676)
							    //In addition, if a test is being recorded in IE, the target of a click event is always a button, not a child, so child does not receive click event at all
							    if (Browser.isIE) {
							        if (args.type === 'click' || args.type === 'mouseup' || args.type === 'mousedown') if (el.parentNode && DOM.closest(el.parentNode, 'button')) {
							            var closestButton = DOM.closest(el.parentNode, 'button');

							            if (_nativeMethods2.default.getAttribute.call(closestButton, 'type') === 'submit') el = closestButton;
							        }
							    }

							    if (pointerRegExp.test(args.type) && (window.PointerEvent || window.MSPointerEvent)) {
							        var pointEvent = Browser.version > 10 ? document.createEvent('PointerEvent') : document.createEvent('MSPointerEvent');
							        var elPosition = Position.getOffsetPosition(el);
							        var elBorders = Style.getBordersWidth(el);
							        var elClientPosition = Position.offsetToClientCoords({
							            x: elPosition.left + elBorders.left,
							            y: elPosition.top + elBorders.top
							        });
							        var eventShortType = args.type.replace('mouse', '');
							        var pArgs = _utilsExtend2.default({
							            widthArg: Browser.version > 10 ? 1 : 0,
							            heightArg: Browser.version > 10 ? 1 : 0,
							            pressure: 0,
							            rotation: 0,
							            tiltX: 0,
							            tiltY: 0,
							            pointerIdArg: 1, //NOTE: this parameter must be "1" for mouse
							            pointerType: Browser.version > 10 ? 'mouse' : 4,
							            hwTimestampArg: Date.now(),
							            isPrimary: true
							        }, args);

							        pArgs.type = Browser.version > 10 ? 'pointer' + eventShortType : 'MSPointer' + eventShortType.charAt(0).toUpperCase() + eventShortType.substring(1);
							        pArgs.offsetXArg = args.clientX - elClientPosition.x;
							        pArgs.offsetYArg = args.clientY - elClientPosition.y;
							        pArgs.button = args.buttons === Event.BUTTONS_PARAMETER.NO_BUTTON ? POINTER_EVENT_BUTTON.NO_BUTTON : pArgs.button;

							        //NOTE: we send null as a relatedTarget argument because IE has memory leak
							        pointEvent.initPointerEvent(pArgs.type, pArgs.canBubble, pArgs.cancelable, window, pArgs.detail, pArgs.screenX, pArgs.screenY, pArgs.clientX, pArgs.clientY, pArgs.ctrlKey, pArgs.altKey, pArgs.shiftKey, pArgs.metaKey, pArgs.button, null, pArgs.offsetXArg, pArgs.offsetYArg, pArgs.widthArg, pArgs.heightArg, pArgs.pressure, pArgs.rotation, pArgs.tiltX, pArgs.tiltY, pArgs.pointerIdArg, pArgs.pointerType, pArgs.hwTimestampArg, pArgs.isPrimary);

							        //NOTE: after dispatching pointer event doesn't contain 'target' and 'relatedTarget' property
							        Object.defineProperty(pointEvent, 'target', {
							            get: function () {
							                return el;
							            },

							            configurable: true
							        });

							        Object.defineProperty(pointEvent, 'relatedTarget', {
							            get: function () {
							                return args.relatedTarget;
							            },

							            configurable: true
							        });

							        Object.defineProperty(pointEvent, 'buttons', {
							            get: function () {
							                return args.buttons;
							            }
							        });

							        raiseDispatchEvent(el, pointEvent, pArgs);
							    }

							    ev = document.createEvent('MouseEvents');
							    ev.initMouseEvent(args.type, args.canBubble, args.cancelable, window, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget);

							    if (Browser.isMozilla || Browser.isIE) {
							        Object.defineProperty(ev, 'buttons', {
							            get: function () {
							                return args.buttons;
							            }
							        });
							    }

							    //T188166 - act.hover trigger "mouseenter" event with "which" parameter 1
							    if (typeof args.which !== 'undefined' && Browser.isWebKit) {
							        Object.defineProperty(ev, _const2.default.EVENT_SANDBOX_WHICH_PROPERTY_WRAPPER, {
							            get: function () {
							                return args.which;
							            }
							        });
							    }

							    //NOTE: After the MouseEvent was created by using initMouseEvent method pageX and pageY properties equal zero (only in IE9).
							    //We can set them only by defineProperty method (B253930)
							    if (Browser.isIE9) {
							        var currentDocument = DOM.findDocument(el);
							        var documentScroll = Style.getElementScroll(currentDocument);

							        Object.defineProperty(ev, 'pageX', {
							            get: function () {
							                return ev.clientX + documentScroll.left;
							            }
							        });

							        Object.defineProperty(ev, 'pageY', {
							            get: function () {
							                return ev.clientY + documentScroll.top;
							            }
							        });
							    }

							    return raiseDispatchEvent(el, ev, args);
							}

							function raiseDispatchEvent(el, ev, args) {
							    // NOTE: in IE  when we raise event via the dispatchEvent function, the window.event object is null.
							    // After a real event happened there is the window.event object but it is not identical with the first argument
							    // of event handler. The window.Event object is identical with the object that is created when we raise event
							    // via the fireEvent function. So, when we raise event via the dispatchEvent function we should set the
							    // window.event object malually.
							    // Except IE11 - window.event is not null and its the same as in event handler (only in window.top.event).
							    // Also in iE11 window.event has not returnValue property and
							    // impossible to prevent event via assigning window.event.returnValue = false
							    var isElementInIFrame = DOM.isElementInIframe(el);

							    if (DOM.isFileInput(el) && ev.type === 'click') clickedFileInput = el;

							    if (Browser.isIE && Browser.version < 11) {
							        args = args || { type: ev.type };

							        var returnValue = true;
							        //B254199
							        var curWindow = isElementInIFrame ? DOM.getIFrameByElement(el).contentWindow : window;
							        var curWindowEvent = null;
							        var onEvent = 'on' + (Browser.isIE10 && /MSPointer(Down|Up|Move|Over|Out)/.test(ev.type) ? ev.type.toLowerCase() : ev.type);
							        var inlineHandler = el[onEvent];
							        var button = args.button;

							        //NOTE: if window.event generated after native click raised
							        if (typeof curWindow.event === 'object' && savedWindowEvents.length && curWindow.event !== savedWindowEvents[0]) {
							            savedNativeClickCount++;
							            savedWindowEvents.unshift(curWindow.event);
							        }

							        delete curWindow.event;

							        var saveWindowEventObject = function (e) {
							            curWindowEvent = curWindow.event || ev;
							            savedWindowEvents.unshift(curWindowEvent);
							            Event.preventDefault(e);
							        };

							        if (el.parentNode) {
							            // NOTE: fireEvent raises error when el.parentNode === null
							            el[onEvent] = saveWindowEventObject;
							            args.button = IE_BUTTONS_MAP[button];

							            _nativeMethods2.default.fireEvent.call(el, onEvent, _utilsExtend2.default(DOM.findDocument(el).createEventObject(), args));

							            el[onEvent] = inlineHandler;
							            args.button = button;
							        }

							        Object.defineProperty(curWindow, 'event', {
							            get: function () {
							                return savedWindowEvents[0];
							            },

							            configurable: true
							        });

							        var cancelBubble = false;

							        if (curWindowEvent) {
							            Object.defineProperty(curWindowEvent, 'returnValue', {
							                get: function () {
							                    return returnValue;
							                },

							                set: function (value) {
							                    if (value === false) ev.preventDefault();

							                    returnValue = value;
							                },

							                configurable: true
							            });

							            Object.defineProperty(curWindowEvent, 'cancelBubble', {
							                get: function () {
							                    return cancelBubble;
							                },

							                set: function (value) {
							                    ev.cancelBubble = cancelBubble = value;
							                },

							                configurable: true
							            });

							            if (curWindowEvent.type === 'mouseout' || curWindowEvent.type === 'mouseover') {
							                Object.defineProperty(curWindowEvent, 'fromElement', {
							                    get: function () {
							                        return curWindowEvent.type === 'mouseout' ? el : args.relatedTarget;
							                    },

							                    configurable: true
							                });
							                Object.defineProperty(curWindowEvent, 'toElement', {
							                    get: function () {
							                        return curWindowEvent.type === 'mouseover' ? el : args.relatedTarget;
							                    },

							                    configurable: true
							                });
							            }
							        }

							        returnValue = el.dispatchEvent(ev) && returnValue;

							        if (curWindowEvent && curWindowEvent === savedWindowEvents[0]) savedWindowEvents.shift();

							        if (!savedWindowEvents.length) delete curWindow.event;

							        return returnValue;
							    }
							    //NOTE: In IE11 iframe's window.event object is null.
							    // So we should set iframe's window.event object malually by window.event (B254199).
							    else if (Browser.isIE && Browser.version > 10 && isElementInIFrame) {
							            Object.defineProperty(DOM.getIFrameByElement(el).contentWindow, 'event', {
							                get: function () {
							                    return window.event;
							                },

							                configurable: true
							            });
							        }

							    return el.dispatchEvent(ev);
							}

							function dispatchKeyEvent(el, args) {
							    var ev = null;

							    if (document.createEvent) {
							        ev = document.createEvent('Events');
							        ev.initEvent(args.type, args.canBubble, args.cancelable);
							        ev = _utilsExtend2.default(ev, {
							            view: args.view,
							            detail: args.detail,
							            ctrlKey: args.ctrlKey,
							            altKey: args.altKey,
							            shiftKey: args.shiftKey,
							            metaKey: args.metaKey,
							            keyCode: args.keyCode,
							            charCode: args.charCode,
							            which: args.which
							        });

							        return raiseDispatchEvent(el, ev, args);
							    }
							}

							function dispatchTouchEvent(el, args) {
							    var ev = document.createEvent('TouchEvent');

							    // HACK: test for iOS using initTouchEvent args count (TODO:replace it with user agent analyzis later)
							    if (Browser.isIOS) {
							        ev.initTouchEvent(args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.pageX, args.pageY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.touches, args.targetTouches, args.changedTouches, typeof args.scale === 'undefined' ? 1.0 : args.scale, typeof args.rotation === 'undefined' ? 0.0 : args.rotation); //B237995
							    } else if (ev.initTouchEvent.length === 12) {
							            // FireFox
							            ev.initTouchEvent(args.type, args.canBubble, args.cancelable, args.view, args.detail, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.touches, args.targetTouches, args.changedTouches);
							        } else {
							            // Default android browser, Dolphin
							            ev.initTouchEvent(args.touches, args.targetTouches, args.changedTouches, args.type, args.view, args.screenX, args.screenY, args.pageX - args.view.pageXOffset, args.pageY - args.view.pageYOffset, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey);
							        }

							    return el.dispatchEvent(ev);
							}

							/* NOTE: options = {
							     [clientX: integer,]
							     [clientY: integer,]
							     [alt: true|false,]
							     [ctrl: true|false,]
							     [shift: true|false,]
							     [meta: true|false,]
							     [button: Util.BUTTON]
							 } */

							function click(el, options) {
							    return simulateEvent(el, 'click', options, {
							        button: Event.BUTTON.LEFT,
							        buttons: Event.BUTTONS_PARAMETER.LEFT_BUTTON
							    });
							}

							function nativeClick(el, originClick) {
							    raiseNativeClick(el, originClick);
							}

							function dblclick(el, options) {
							    return simulateEvent(el, 'dblclick', options, {
							        button: Event.BUTTON.LEFT,
							        buttons: Event.BUTTONS_PARAMETER.LEFT_BUTTON
							    });
							}

							function rightclick(el, options) {
							    return simulateEvent(el, 'click', options, {
							        button: Event.BUTTON.RIGHT,
							        buttons: Event.BUTTONS_PARAMETER.RIGHT_BUTTON
							    });
							}

							function contextmenu(el, options) {
							    return simulateEvent(el, 'contextmenu', options, {
							        button: Event.BUTTON.RIGHT,
							        which: Event.WHICH_PARAMETER.RIGHT_BUTTON,
							        buttons: Event.BUTTONS_PARAMETER.RIGHT_BUTTON
							    });
							}

							function mousedown(el, options) {
							    options = options || {};

							    options.button = typeof options.button === 'undefined' ? Event.BUTTON.LEFT : options.button;
							    options.which = typeof options.which === 'undefined' || options.button !== Event.BUTTON.RIGHT ? Event.WHICH_PARAMETER.LEFT_BUTTON : Event.WHICH_PARAMETER.RIGHT_BUTTON;
							    options.buttons = typeof options.buttons === 'undefined' ? Event.BUTTONS_PARAMETER.LEFT_BUTTON : options.buttons;

							    return simulateEvent(el, 'mousedown', options);
							}

							function mouseup(el, options) {
							    options = options || {};

							    options.button = typeof options.button === 'undefined' ? Event.BUTTON.LEFT : options.button;
							    options.which = typeof options.which === 'undefined' || options.button !== Event.BUTTON.RIGHT ? Event.WHICH_PARAMETER.LEFT_BUTTON : Event.WHICH_PARAMETER.RIGHT_BUTTON;
							    options.buttons = typeof options.buttons === 'undefined' ? Event.BUTTONS_PARAMETER.LEFT_BUTTON : options.buttons;

							    return simulateEvent(el, 'mouseup', options);
							}

							function mouseover(el, options) {
							    return simulateEvent(el, 'mouseover', options);
							}

							function mousemove(el, options) {
							    return simulateEvent(el, 'mousemove', options, { cancelable: false });
							}

							function mouseout(el, options) {
							    return simulateEvent(el, 'mouseout', options);
							}

							// NOTE: keyboard events

							function keypress(el, options) {
							    return simulateEvent(el, 'keypress', options);
							}

							function keyup(el, options) {
							    return simulateEvent(el, 'keyup', options);
							}

							function keydown(el, options) {
							    return simulateEvent(el, 'keydown', options);
							}

							function input(el) {
							    return dispatchEvent(el, 'input');
							}

							// NOTE: control events

							function blur(el) {
							    return dispatchEvent(el, 'blur', DISPATCHED_EVENT_FLAG);
							}

							function focus(el) {
							    return dispatchEvent(el, 'focus', DISPATCHED_EVENT_FLAG);
							}

							function change(el) {
							    return dispatchEvent(el, 'change', DISPATCHED_EVENT_FLAG);
							}

							function submit(el) {
							    return dispatchEvent(el, 'submit');
							}

							function selectionchange(el) {
							    return dispatchEvent(el, 'selectionchange');
							}

							// NOTE: touch events

							function touchstart(el, options) {
							    return simulateEvent(el, 'touchstart', options);
							}

							function touchend(el, options) {
							    return simulateEvent(el, 'touchend', options);
							}

							function touchmove(el, options) {
							    return simulateEvent(el, 'touchmove', options);
							}

							function isSavedWindowsEventsExists() {
							    return savedWindowEvents && savedWindowEvents.length;
							}

							// todo: remove this methods

							function getClickedFileInput() {
							    return clickedFileInput;
							}

							function setClickedFileInput(input) {
							    clickedFileInput = input;
							}
						},
						"timeout.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.init = init;
							exports.deferFunction = deferFunction;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							// NOTE: when you call focus/blur function of some element in IE, handlers of the event are executed it async manner,
							// but before any function that is called with the window.setTimeout function. So, we should raise handlers with
							// timeout but we should do it before other async functions calling
							var timeouts = [];
							var deferredFunctions = [];
							var nativeSetTimeout = _nativeMethods2.default.setTimeout;
							var nativeSetInterval = _nativeMethods2.default.setInterval;

							function wrapTimeoutFunctionsArguments(args) {
							    var fn = args[0];
							    var fnToRun = typeof fn === 'function' ? fn : function () {
							        window.eval(fn);
							    };

							    args[0] = function () {
							        return callDeferredFunction(fnToRun, arguments);
							    };

							    return args;
							}

							function callDeferredFunction(fn, args) {
							    if (timeouts.length) {
							        var curTimeouts = [];
							        var curHandlers = [];

							        var i = 0;

							        for (; i < timeouts.length; i++) {
							            curTimeouts.push(timeouts[i]);
							            curHandlers.push(deferredFunctions[i]);
							        }

							        timeouts = [];
							        deferredFunctions = [];

							        for (i = 0; i < curTimeouts.length; i++) {
							            window.clearInterval(curTimeouts[i]);
							            curHandlers[i]();
							        }

							        //NOTE: handlers can create new deferred functions
							        return callDeferredFunction(fn, args);
							    }

							    return fn.apply(window, args);
							}

							function init(window) {
							    if (Browser.isIE && Browser.version < 12) {
							        window.setTimeout = function () {
							            return nativeSetTimeout.apply(window, wrapTimeoutFunctionsArguments(arguments));
							        };

							        window.setInterval = function () {
							            return nativeSetInterval.apply(window, wrapTimeoutFunctionsArguments(arguments));
							        };

							        exports.internalSetTimeout = internalSetTimeout = window.setTimeout;
							    }
							}

							var internalSetTimeout = nativeSetTimeout;

							exports.internalSetTimeout = internalSetTimeout;

							function deferFunction(fn) {
							    var deferredFunction = function () {
							        fn();

							        for (var i = 0; i < deferredFunctions.length; i++) {
							            if (deferredFunctions[i] === deferredFunction) {
							                deferredFunctions.splice(i, 1);
							                timeouts.splice(i, 1);

							                break;
							            }
							        }
							    };

							    deferredFunctions.push(deferredFunction);
							    timeouts.push(nativeSetTimeout.call(window, deferredFunction, 0));
							}
						},
						"unload.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.init = init;
							exports.setOnBeforeUnload = setOnBeforeUnload;
							exports.getOnBeforeUnload = getOnBeforeUnload;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var _listeners = require('./listeners');

							var Listeners = _interopRequireWildcard(_listeners);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _utilsCreatePropertyDescJs = require('../../utils/create-property-desc.js');

							var _utilsCreatePropertyDescJs2 = _interopRequireDefault(_utilsCreatePropertyDescJs);

							var _utilsEventEmitter = require('../../utils/event-emitter');

							var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

							var BEFORE_UNLOAD_EVENT = 'beforeUnload';
							exports.BEFORE_UNLOAD_EVENT = BEFORE_UNLOAD_EVENT;
							var BEFORE_BEFORE_UNLOAD_EVENT = 'beforeBeforeUnload';
							exports.BEFORE_BEFORE_UNLOAD_EVENT = BEFORE_BEFORE_UNLOAD_EVENT;
							var UNLOAD_EVENT = 'unload';

							exports.UNLOAD_EVENT = UNLOAD_EVENT;
							var isFakeIEBeforeUnloadEvent = false;
							var storedBeforeUnloadReturnValue = '';
							var prevented = false;
							var eventEmitter = new _utilsEventEmitter2.default();

							//NOTE: this handler should be called after the others
							function emitBeforeUnloadEvent() {
							    eventEmitter.emit(BEFORE_UNLOAD_EVENT, {
							        returnValue: storedBeforeUnloadReturnValue,
							        prevented: prevented,
							        isFakeIEEvent: isFakeIEBeforeUnloadEvent
							    });

							    isFakeIEBeforeUnloadEvent = false;
							}

							function onBeforeUnloadHandler(e, originListener) {
							    //NOTE: overriding the returnValue property to prevent native dialog
							    Object.defineProperty(e, 'returnValue', _utilsCreatePropertyDescJs2.default({
							        get: function () {
							            return storedBeforeUnloadReturnValue;
							        },
							        set: function (value) {
							            //NOTE: in all browsers if any value is set it leads to preventing unload. In Mozilla only if value
							            // is an empty string it does not do it.
							            storedBeforeUnloadReturnValue = value;

							            prevented = Browser.isMozilla ? value !== '' : true;
							        }
							    }));

							    Object.defineProperty(e, 'preventDefault', _utilsCreatePropertyDescJs2.default({
							        get: function () {
							            return function () {
							                prevented = true;
							            };
							        },
							        set: function () {}
							    }));

							    var res = originListener(e);

							    if (typeof res !== 'undefined') {
							        storedBeforeUnloadReturnValue = res;
							        prevented = true;
							    }
							}

							var on = eventEmitter.on.bind(eventEmitter);
							exports.on = on;
							var off = eventEmitter.off.bind(eventEmitter);

							exports.off = off;

							function init(window, document) {
							    Listeners.setEventListenerWrapper(window, ['beforeunload'], onBeforeUnloadHandler);

							    Listeners.addInternalEventListener(window, ['unload'], function () {
							        eventEmitter.emit(UNLOAD_EVENT);
							    });

							    _nativeMethods2.default.addEventListener.call(document, 'click', function (e) {
							        var target = e.target || e.srcElement;

							        if ((Browser.isIE9 || Browser.isIE10) && target.tagName && target.tagName.toLowerCase() === 'a') {
							            var href = _nativeMethods2.default.getAttribute.call(target, 'href');

							            isFakeIEBeforeUnloadEvent = /(^javascript:)|(^mailto:)|(^tel:)|(^#)/.test(href);
							        }
							    });

							    _nativeMethods2.default.windowAddEventListener.call(window, 'beforeunload', emitBeforeUnloadEvent);

							    Listeners.addInternalEventListener(window, ['beforeunload'], function () {
							        eventEmitter.emit(BEFORE_BEFORE_UNLOAD_EVENT, {
							            isFakeIEEvent: isFakeIEBeforeUnloadEvent
							        });
							    });

							    Listeners.on(Listeners.EVENT_LISTENER_ATTACHED_EVENT, function (e) {
							        if (e.el === window && e.eventType === 'beforeunload') {

							            //NOTE: reattach listener and it'll be the last in the queue
							            _nativeMethods2.default.windowRemoveEventListener.call(window, 'beforeunload', emitBeforeUnloadEvent);
							            _nativeMethods2.default.windowAddEventListener.call(window, 'beforeunload', emitBeforeUnloadEvent);
							        }
							    });
							}

							var storedBeforeUnloadHandler = null;

							function setOnBeforeUnload(window, value) {
							    if (typeof value === 'function') {

							        storedBeforeUnloadHandler = value;

							        window.onbeforeunload = function (e) {
							            return onBeforeUnloadHandler(e, value);
							        };

							        //NOTE: reattach listener and it'll be the last in the queue
							        _nativeMethods2.default.windowRemoveEventListener.call(window, 'beforeunload', emitBeforeUnloadEvent);
							        _nativeMethods2.default.windowAddEventListener.call(window, 'beforeunload', emitBeforeUnloadEvent);
							    } else {
							        storedBeforeUnloadHandler = null;
							        window.onbeforeunload = null;
							    }
							}

							function getOnBeforeUnload() {
							    return storedBeforeUnloadHandler;
							}
						}
					},
					"iframe.js": function (exports, module, require) {
						exports.__esModule = true;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						var _utilsBrowser = require('../utils/browser');

						var Browser = _interopRequireWildcard(_utilsBrowser);

						var _utilsDom = require('../utils/dom');

						var DOM = _interopRequireWildcard(_utilsDom);

						var _nativeMethods = require('./native-methods');

						var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

						var _const = require('../../const');

						var _const2 = _interopRequireDefault(_const);

						var _serviceMsgCmd = require('../../service-msg-cmd');

						var _serviceMsgCmd2 = _interopRequireDefault(_serviceMsgCmd);

						var _settings = require('../settings');

						var _settings2 = _interopRequireDefault(_settings);

						var _transport = require('../transport');

						var _transport2 = _interopRequireDefault(_transport);

						var _utilsUrl = require('../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var _utilsEventEmitter = require('../utils/event-emitter');

						var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

						var IFRAME_READY_TO_INIT = 'iframeReadyToInit';
						var IFRAME_READY_TO_INIT_INTERNAL = 'iframeReadyToInitInternal';
						var IFRAME_DOCUMENT_CREATED = 'iframeDocumentCreated';
						var IFRAME_DOCUMENT_RECREATED = 'iframeDocumentRecreated';

						var IFRAME_WINDOW_INITED = 'hh_iwi_5d9138e9';

						var eventEmitter = new _utilsEventEmitter2.default();
						var IFrameSandbox = {};

						// For iframes without src only!
						IFrameSandbox.IFRAME_READY_TO_INIT = IFRAME_READY_TO_INIT;
						IFrameSandbox.IFRAME_READY_TO_INIT_INTERNAL = IFRAME_READY_TO_INIT_INTERNAL;
						IFrameSandbox.IFRAME_DOCUMENT_CREATED = IFRAME_DOCUMENT_CREATED;
						IFrameSandbox.IFRAME_DOCUMENT_RECREATED = IFRAME_DOCUMENT_RECREATED;

						IFrameSandbox.on = eventEmitter.on.bind(eventEmitter);
						IFrameSandbox.off = eventEmitter.off.bind(eventEmitter);

						IFrameSandbox.isIframeInitialized = function (iframe) {
						    var isFFIframeUninitialized = Browser.isMozilla && iframe.contentWindow.document.readyState === 'uninitialized';

						    return !isFFIframeUninitialized && !!iframe.contentDocument.documentElement;
						};

						IFrameSandbox.isWindowInited = function (window) {
						    return window[IFRAME_WINDOW_INITED];
						};

						IFrameSandbox.iframeReadyToInitHandler = function (e) {
						    // Get and evaluate iframe task script
						    var msg = {
						        cmd: _serviceMsgCmd2.default.GET_IFRAME_TASK_SCRIPT,
						        referer: _settings2.default.get().REFERER || window.location.toString()
						    };

						    _transport2.default.syncServiceMsg(msg, function (iFrameTaskScript) {
						        e.iframe.contentWindow.eval.apply(e.iframe.contentWindow, [iFrameTaskScript]);
						    });
						};

						eventEmitter.on(IFrameSandbox.IFRAME_READY_TO_INIT, IFrameSandbox.iframeReadyToInitHandler);

						function raiseReadyToInitEvent(iframe) {
						    if (_utilsUrl2.default.isIframeWithoutSrc(iframe)) {
						        var iframeInitialized = IFrameSandbox.isIframeInitialized(iframe);
						        var iframeWindowInitialized = iframe.contentWindow[IFRAME_WINDOW_INITED];

						        if (iframeInitialized && !iframeWindowInitialized) {
						            // Ok, iframe fully loaded now, but Hammerhead not injected
						            iframe.contentWindow[IFRAME_WINDOW_INITED] = true;

						            // Rise this internal event to eval Hammerhead code script
						            eventEmitter.emit(IFrameSandbox.IFRAME_READY_TO_INIT_INTERNAL, {
						                iframe: iframe
						            });

						            // Rise this event to eval "task" script and to call Hammerhead initialization method after
						            eventEmitter.emit(IFrameSandbox.IFRAME_READY_TO_INIT, {
						                iframe: iframe
						            });

						            iframe.contentWindow[_const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME]();
						        } else if (!iframeInitialized) {
						            // Even if iframe is not loaded (iframe.contentDocument.documentElement not exist) we should still
						            // override document.write method, without Hammerhead initializing. This method can be called
						            // before iframe fully loading, we are obliged to override it now
						            if (iframe.contentDocument.write.toString() === _nativeMethods2.default.documentWrite.toString()) {
						                eventEmitter.emit(IFrameSandbox.IFRAME_DOCUMENT_CREATED, {
						                    iframe: iframe
						                });
						            }
						        }
						        /*eslint-disable no-empty */
						        else if (iframeWindowInitialized && (Browser.isMozilla || Browser.isIE)) {}
						            // IE recreates iframe document after document.write calling.
						            // FireFox recreates iframe document during loading
						            //                if (iframe.contentDocument.write.toString() === NativeMethods.documentWrite.toString()) {
						            //                    eventEmitter.emit(IFRAME_DOCUMENT_RECREATED, {
						            //                        iframe: iframe
						            //                    });
						            //                }

						            /*eslint-enable no-empty */
						    }
						}

						IFrameSandbox.iframeAddedToDom = function (el) {
						    if (!DOM.isShadowUIElement(el)) {
						        raiseReadyToInitEvent(el);

						        if (!Browser.isWebKit && el.contentDocument) {
						            _nativeMethods2.default.documentAddEventListener.call(el.contentDocument, 'DOMContentLoaded', function () {
						                raiseReadyToInitEvent(el);
						            });
						        }
						    }
						};

						IFrameSandbox.onIframeBeganToRun = function (iframe) {
						    raiseReadyToInitEvent(iframe);
						};

						IFrameSandbox.overrideIframe = function (el) {
						    if (DOM.isShadowUIElement(el)) return;

						    var src = _nativeMethods2.default.getAttribute.call(el, 'src');

						    if (!src || !_utilsUrl2.default.isSupportedProtocol(src)) {
						        if (el.contentWindow) {
						            raiseReadyToInitEvent(el);

						            var readyHandler = function () {
						                if (el.contentWindow) raiseReadyToInitEvent(el);
						            };

						            _nativeMethods2.default.addEventListener.call(el, 'load', readyHandler);

						            if (Browser.isMozilla) _nativeMethods2.default.documentAddEventListener.call(el.contentDocument, 'ready', readyHandler);
						        } else {
						            var handler = function () {
						                if (!DOM.isShadowUIElement(el)) {
						                    if (DOM.isCrossDomainIframe(el)) _nativeMethods2.default.removeEventListener.call(el, 'load', handler);else raiseReadyToInitEvent(el);
						                }
						            };

						            if (DOM.isElementInDocument(el)) raiseReadyToInitEvent(el);

						            _nativeMethods2.default.addEventListener.call(el, 'load', handler);
						        }
						    } else {
						        if (DOM.isElementInDocument(el)) raiseReadyToInitEvent(el);

						        _nativeMethods2.default.addEventListener.call(el, 'load', function () {
						            raiseReadyToInitEvent(el);
						        });
						    }
						};

						exports.default = IFrameSandbox;
						module.exports = exports.default;
					},
					"message.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.setPingIFrameTimeout = setPingIFrameTimeout;
						exports.init = init;
						exports.setOnMessage = setOnMessage;
						exports.getOnMessage = getOnMessage;
						exports.postMessage = postMessage;
						exports.sendServiceMsg = sendServiceMsg;
						exports.pingIFrame = pingIFrame;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						/*eslint-disable no-native-reassign */

						var _utilsBrowser = require('../utils/browser');

						var Browser = _interopRequireWildcard(_utilsBrowser);

						var _utilsDom = require('../utils/dom');

						var DOM = _interopRequireWildcard(_utilsDom);

						var _json = require('../json');

						var JSON = _interopRequireWildcard(_json);

						var _eventListeners = require('./event/listeners');

						var Listeners = _interopRequireWildcard(_eventListeners);

						var _nativeMethods = require('./native-methods');

						var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

						var _utilsUrl = require('../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var _utilsEventEmitter = require('../utils/event-emitter');

						var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

						/*eslint-enable no-native-reassign */

						var messageType = {
						    SERVICE: '5Gtrb',
						    USER: 'qWip2'
						};

						var PING_DELAY = 200;

						//NOTE: published for test purposes only
						var PING_IFRAME_TIMEOUT = 7000;
						exports.PING_IFRAME_TIMEOUT = PING_IFRAME_TIMEOUT;
						var PING_IFRAME_MIN_TIMEOUT = 100;
						exports.PING_IFRAME_MIN_TIMEOUT = PING_IFRAME_MIN_TIMEOUT;
						var SERVICE_MSG_RECEIVED = 'received';
						exports.SERVICE_MSG_RECEIVED = SERVICE_MSG_RECEIVED;

						function setPingIFrameTimeout(value) {
						    exports.PING_IFRAME_TIMEOUT = PING_IFRAME_TIMEOUT = value;
						}

						var RECEIVE_MSG_FN = 'tc_rmf_375fb9e7';

						var eventEmitter = new _utilsEventEmitter2.default();
						var pingCallback = null;
						var pingCmd = null;

						//NOTE: the window.top property may be changed after an iFrame is removed from DOM in IE, so we save it on script initializing
						var topWindow = window.top;

						var on = eventEmitter.on.bind(eventEmitter);
						exports.on = on;
						var off = eventEmitter.off.bind(eventEmitter);

						exports.off = off;

						function init(window) {
						    function onMessage(e) {
						        var data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

						        if (data.type === messageType.SERVICE && e.source) {
						            /*eslint-disable indent */
						            if (pingCmd && data.message.cmd === pingCmd && data.message.isPingResponse) {
						                pingCallback();
						                pingCallback = null;
						                pingCmd = null;
						            } else eventEmitter.emit(SERVICE_MSG_RECEIVED, { message: data.message, source: e.source });
						            /*eslint-enable indent */
						        }
						    }

						    Listeners.addInternalEventListener(window, ['message'], onMessage);

						    window[RECEIVE_MSG_FN] = isIFrameWithoutSrc || topWindow === window.self ? onMessage : null;

						    Listeners.setEventListenerWrapper(window, ['message'], onWindowMessage);
						}

						function onWindowMessage(e, originListener) {
						    var resultEvt = {};

						    /* jshint ignore:start */
						    for (var key in e) resultEvt[key] = typeof e[key] === 'function' ? e[key].bind(e) : e[key];
						    /* jshint ignore:end */

						    var data = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;

						    if (data.type !== messageType.SERVICE) {
						        var originUrl = _utilsUrl2.default.OriginLocation.get();

						        if (data.targetUrl === '*' || _utilsUrl2.default.sameOriginCheck(originUrl, data.targetUrl)) {
						            resultEvt.origin = data.originUrl;

						            // IE9 can send only string values
						            if (typeof data.message !== 'string' && (Browser.isIE9 || data.isStringMessage)) resultEvt.data = JSON.stringify(data.message);else resultEvt.data = data.message;

						            return originListener.call(window, resultEvt);
						        }
						    }
						}

						function setOnMessage(window, value) {
						    if (typeof value === 'function') {
						        this.storedOnMessageHandler = value;

						        window.onmessage = function (e) {
						            return onWindowMessage(e, value);
						        };
						    } else {
						        this.storedOnMessageHandler = null;
						        window.onmessage = null;
						    }
						}

						function getOnMessage() {
						    return this.storedOnMessageHandler;
						}

						function postMessage(contentWindow, args) {
						    var targetUrl = args[1];

						    if (DOM.isCrossDomainWindows(window, contentWindow)) args[1] = _utilsUrl2.default.getCrossDomainProxyUrl();else if (!_utilsUrl2.default.isSupportedProtocol(contentWindow.location)) args[1] = '*';else {
						        args[1] = _utilsUrl2.default.formatUrl({
						            protocol: window.location.protocol,
						            host: window.location.host
						        });
						    }

						    args[0] = wrapMessage(messageType.USER, args[0], targetUrl);

						    if (isIFrameWithoutSrc) {
						        /*eslint-disable camelcase */
						        window.tc_cw_375fb9e7 = contentWindow;
						        window.tc_a_375fb9e7 = args;
						        /*eslint-disable camelcase */

						        return window.eval('window.tc_cw_375fb9e7.postMessage(window.tc_a_375fb9e7[0], window.tc_a_375fb9e7[1]); delete window.tc_cw_375fb9e7; delete window.tc_a_375fb9e7');
						    }

						    return contentWindow.postMessage(args[0], args[1]);
						}

						//NOTE: in IE after an iFrame is removed from DOM the window.top property is equal to window.self
						function isIFrameRemoved() {
						    return window.top === window.self && window !== topWindow;
						}

						function sendServiceMsg(msg, targetWindow) {
						    var message = wrapMessage(messageType.SERVICE, msg);

						    //NOTE: for iframes without src
						    if (!isIFrameRemoved() && (isIFrameWithoutSrc || !DOM.isCrossDomainWindows(targetWindow, window) && targetWindow[RECEIVE_MSG_FN])) {
						        //NOTE: postMessage delay imitation
						        _nativeMethods2.default.setTimeout.call(topWindow, function () {
						            targetWindow[RECEIVE_MSG_FN]({
						                data: JSON.parse(JSON.stringify(message)), // Cloning message to prevent this modification
						                source: window
						            });
						        }, 10);

						        return null;
						    }

						    return targetWindow.postMessage(message, '*');
						}

						function pingIFrame(targetIFrame, pingMessageCommand, callback, shortWaiting) {
						    var pingInterval = null;
						    var pingTimeout = null;
						    var targetWindow = null;

						    function sendPingRequest() {
						        if (targetIFrame.contentWindow) {
						            targetWindow = targetIFrame.contentWindow;

						            sendServiceMsg({
						                cmd: pingCmd,
						                isPingRequest: true
						            }, targetWindow);
						        }
						    }

						    function cleanTimeouts() {
						        window.clearInterval(pingInterval);
						        window.clearTimeout(pingTimeout);

						        pingCallback = null;
						        pingCmd = null;
						        pingInterval = null;
						        pingTimeout = null;
						    }

						    pingTimeout = _nativeMethods2.default.setTimeout.call(window, function () {
						        cleanTimeouts();
						        callback(true);
						    }, shortWaiting ? PING_IFRAME_MIN_TIMEOUT : PING_IFRAME_TIMEOUT);

						    if (typeof callback === 'function') {
						        pingCallback = function () {
						            cleanTimeouts();
						            callback();
						        };

						        pingCmd = pingMessageCommand;

						        sendPingRequest();
						        pingInterval = _nativeMethods2.default.setInterval.call(window, sendPingRequest, PING_DELAY);
						    }
						}

						function wrapMessage(type, message, targetUrl) {
						    var parsedOrigin = _utilsUrl2.default.OriginLocation.getParsed();
						    var originUrl = _utilsUrl2.default.formatUrl({
						        protocol: parsedOrigin.protocol,
						        host: parsedOrigin.host
						    });

						    var result = {
						        isStringMessage: typeof message === 'string',
						        message: message,
						        originUrl: originUrl,
						        targetUrl: targetUrl,
						        type: type
						    };

						    // IE9 can send only string values
						    return Browser.isIE9 ? JSON.stringify(result) : result;
						}
					},
					"native-methods.js": function (exports, module, require) {
						exports.__esModule = true;

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

						/*global Document, Window */

						var NativeMethods = (function () {
						    function NativeMethods() {
						        _classCallCheck(this, NativeMethods);

						        this.refreshDocumentMeths();
						        this.refreshElementMeths();
						        this.refreshWindowMeths();
						    }

						    NativeMethods.prototype.refreshDocumentMeths = function refreshDocumentMeths(doc) {
						        doc = doc || document;

						        // Dom
						        this.createDocumentFragment = doc.createDocumentFragment || Document.prototype.createDocumentFragment;
						        this.createElement = doc.createElement || Document.prototype.createElement;
						        this.createElementNS = doc.createElementNS || Document.prototype.createElementNS;
						        this.documentOpen = doc.open || Document.prototype.open;
						        this.documentClose = doc.close || Document.prototype.close;
						        this.documentWrite = doc.write || Document.prototype.write;
						        this.documentWriteLn = doc.writeln || Document.prototype.writeln;
						        this.elementFromPoint = doc.elementFromPoint || Document.prototype.elementFromPoint;
						        this.getElementById = doc.getElementById || Document.prototype.getElementById;
						        this.getElementsByClassName = doc.getElementsByClassName || Document.prototype.getElementsByClassName;
						        this.getElementsByName = doc.getElementsByName || Document.prototype.getElementsByName;

						        this.getElementsByTagName = doc.getElementsByTagName || Document.prototype.getElementsByTagName;
						        this.querySelector = doc.querySelector || Document.prototype.querySelector;
						        this.querySelectorAll = doc.querySelectorAll || Document.prototype.querySelectorAll;

						        // Event
						        this.documentAddEventListener = doc.addEventListener || Document.prototype.addEventListener;
						        this.documentRemoveEventListener = doc.removeEventListener || Document.prototype.removeEventListener;
						    };

						    NativeMethods.prototype.refreshElementMeths = function refreshElementMeths(doc) {
						        var _this = this;

						        var createElement = function (tagName) {
						            return _this.createElement.call(doc || document, tagName);
						        };
						        var nativeElement = createElement('div');

						        // Dom
						        this.appendChild = nativeElement.appendChild;
						        this.cloneNode = nativeElement.cloneNode;
						        this.elementGetElementsByClassName = nativeElement.getElementsByClassName;
						        this.elementGetElementsByTagName = nativeElement.getElementsByTagName;
						        this.elementQuerySelector = nativeElement.querySelector;
						        this.elementQuerySelectorAll = nativeElement.querySelectorAll;
						        this.getAttribute = nativeElement.getAttribute;
						        this.getAttributeNS = nativeElement.getAttributeNS;
						        this.insertAdjacentHTML = nativeElement.insertAdjacentHTML;
						        this.insertBefore = nativeElement.insertBefore;
						        this.insertCell = createElement('tr').insertCell;
						        this.insertTableRow = createElement('table').insertRow;
						        this.insertTBodyRow = createElement('tbody').insertRow;
						        this.removeAttribute = nativeElement.removeAttribute;
						        this.removeAttributeNS = nativeElement.removeAttributeNS;
						        this.removeChild = nativeElement.removeChild;
						        this.setAttribute = nativeElement.setAttribute;
						        this.setAttributeNS = nativeElement.setAttributeNS;

						        // Event
						        this.addEventListener = nativeElement.addEventListener;
						        this.removeEventListener = nativeElement.removeEventListener;
						        this.blur = nativeElement.blur;
						        this.click = nativeElement.click;
						        this.dispatchEvent = nativeElement.dispatchEvent;
						        this.attachEvent = nativeElement.attachEvent;
						        this.detachEvent = nativeElement.detachEvent;
						        this.fireEvent = nativeElement.fireEvent;
						        this.focus = nativeElement.focus;
						        this.select = window.TextRange ? createElement('body').createTextRange().select : null;
						        this.setSelectionRange = createElement('input').setSelectionRange;
						        this.textAreaSetSelectionRange = createElement('textarea').setSelectionRange;
						    };

						    NativeMethods.prototype.refreshWindowMeths = function refreshWindowMeths(win) {
						        win = win || window;
						        // Dom
						        this.eval = win.eval;
						        this.EventSource = win.EventSource;
						        this.formSubmit = win.HTMLFormElement.prototype.submit;
						        this.historyPushState = win.history ? win.history.pushState : null;
						        this.historyReplaceState = win.history ? win.history.replaceState : null;
						        this.Image = win.Image;
						        this.MutationObserver = win.MutationObserver;
						        this.postMessage = win.postMessage || Window.prototype.postMessage;
						        this.windowOpen = win.open || Window.prototype.open;
						        this.Worker = win.Worker;
						        this.Blob = win.Blob;
						        this.setTimeout = win.setTimeout || Window.prototype.setTimeout;
						        this.setInterval = win.setInterval || Window.prototype.setInterval;
						        this.XMLHttpRequest = win.XMLHttpRequest;
						        this.registerProtocolHandler = win.navigator.registerProtocolHandler;
						        this.registerServiceWorker = win.navigator && win.navigator.serviceWorker ? win.navigator.serviceWorker.register : null;

						        // Event
						        this.windowAddEventListener = win.addEventListener || Window.prototype.addEventListener;
						        this.windowRemoveEventListener = win.removeEventListener || Window.prototype.removeEventListener;

						        // Canvas
						        this.canvasContextDrawImage = win.CanvasRenderingContext2D.prototype.drawImage;

						        //DateTime
						        this.date = win.Date;
						        this.dateNow = win.Date.now;

						        this.refreshClasses(win);
						    };

						    NativeMethods.prototype.refreshClasses = function refreshClasses(win) {
						        var mock = function () {
						            return null;
						        };

						        this.windowClass = win.Window || mock;
						        this.documentClass = win.Document || mock;
						        this.locationClass = win.Location || mock;
						        this.styleClass = win.CSSStyleDeclaration || win.CSS2Properties || win.MSStyleCSSProperties || mock;
						    };

						    NativeMethods.prototype.restoreNativeDocumentMeth = function restoreNativeDocumentMeth(document) {
						        document.createDocumentFragment = this.createDocumentFragment;
						        document.createElement = this.createElement;
						        document.createElementNS = this.createElementNS;
						        document.open = this.documentOpen;
						        document.close = this.documentClose;
						        document.write = this.documentWrite;
						        document.writeln = this.documentWriteLn;
						        document.elementFromPoint = this.elementFromPoint;
						        document.getElementById = this.getElementById;
						        document.getElementsByClassName = this.getElementsByClassName;
						        document.getElementsByName = this.getElementsByName;
						        document.getElementsByTagName = this.getElementsByTagName;
						        document.querySelector = this.querySelector;
						        document.querySelectorAll = this.querySelectorAll;

						        // Event
						        document.addEventListener = this.documentAddEventListener;
						        document.removeEventListener = this.documentRemoveEventListener;
						    };

						    return NativeMethods;
						})();

						exports.default = new NativeMethods();
						module.exports = exports.default;
					},
					"shadow-ui.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.getRoot = getRoot;
						exports.init = init;
						exports.onBodyContentChanged = onBodyContentChanged;
						exports.onBodyElementMutation = onBodyElementMutation;
						exports.overrideElement = overrideElement;
						exports.getFirstChild = getFirstChild;
						exports.getFirstElementChild = getFirstElementChild;
						exports.getLastChild = getLastChild;
						exports.getLastElementChild = getLastElementChild;
						exports.checkElementsPosition = checkElementsPosition;
						exports.isShadowContainer = isShadowContainer;
						exports.isShadowContainerCollection = isShadowContainerCollection;
						exports.isShadowUIMutation = isShadowUIMutation;
						exports.addClass = addClass;
						exports.hasClass = hasClass;
						exports.patchClassNames = patchClassNames;
						exports.removeClass = removeClass;
						exports.select = select;
						exports.setBlind = setBlind;
						exports.getLastActiveElement = getLastActiveElement;
						exports.setLastActiveElement = setLastActiveElement;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						var _utilsDom = require('../utils/dom');

						var DOM = _interopRequireWildcard(_utilsDom);

						var _nativeMethods = require('./native-methods');

						var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

						var _domProcessorDomProcessor = require('../dom-processor/dom-processor');

						var _domProcessorDomProcessor2 = _interopRequireDefault(_domProcessorDomProcessor);

						var _utilsPosition = require('../utils/position');

						var Position = _interopRequireWildcard(_utilsPosition);

						var _const = require('../../const');

						var _const2 = _interopRequireDefault(_const);

						var _utilsStyle = require('../utils/style');

						var Style = _interopRequireWildcard(_utilsStyle);

						var _utilsEvent = require('../utils/event');

						var Event = _interopRequireWildcard(_utilsEvent);

						// Const
						var CLASSNAME_REGEX = /\.((?:\\.|[-\w]|[^\x00-\xa0])+)/g;
						var ROOT_CLASS = 'root';
						var ROOT_ID = 'root';
						var HIDDEN_CLASS = 'hidden';
						var BLIND_CLASS = 'blind';

						// Globals
						var root = null;
						var lastActiveElement = null;

						function bringRootToWindowTopLeft() {
						    var rootHasParentWithNonStaticPosition = function () {
						        var parent = root.parentNode;

						        while (parent) {
						            var elementPosition = Style.get(parent, 'position');

						            if (/fixed|relative|absolute/.test(elementPosition)) return true;

						            parent = parent.parentNode;
						        }
						        return false;
						    };

						    if (rootHasParentWithNonStaticPosition()) {
						        var rootOffset = Position.getOffsetPosition(root);

						        if (rootOffset.left !== 0 || rootOffset.top !== 0) {
						            var newLeft = ((parseFloat(Style.get(root, 'left')) || 0) - rootOffset.left).toString() + 'px';
						            var newTop = ((parseFloat(Style.get(root, 'top')) || 0) - rootOffset.top).toString() + 'px';

						            Style.set(root, 'left', newLeft);
						            Style.set(root, 'top', newTop);
						        }
						    }
						}

						function filterElement(element) {
						    if (!element || element === document || element === window) return element;

						    return DOM.isShadowUIElement(element) ? null : element;
						}

						function filterNodeList(nodeList) {
						    var filteredList = [];
						    var nlLength = nodeList.length;

						    for (var i = 0; i < nlLength; i++) {
						        var element = filterElement(nodeList[i]);

						        if (element) filteredList.push(element);
						    }

						    filteredList.item = function (index) {
						        return index >= filteredList.length ? null : filteredList[index];
						    };

						    if (nodeList.namedItem) {
						        filteredList.namedItem = function (name) {
						            return nodeList.namedItem(name);
						        };
						    }

						    return filteredList.length === nlLength ? nodeList : filteredList;
						}

						function getRoot() {
						    if (!root || /* T225944 */!document.body.contains(root)) {
						        overrideElement(document.body);

						        /*eslint-disable indent */
						        if (!root) {
						            //B254893
						            root = document.createElement('div');
						            _nativeMethods2.default.setAttribute.call(root, 'id', ROOT_ID);
						            _nativeMethods2.default.setAttribute.call(root, 'contenteditable', 'false');
						            document.body.appendChild(root);

						            _nativeMethods2.default.setAttribute.call(root, 'id', patchClassNames(ROOT_ID));

						            addClass(root, ROOT_CLASS);

						            for (var i = 0; i < _domProcessorDomProcessor2.default.EVENTS.length; i++) root.addEventListener(_domProcessorDomProcessor2.default.EVENTS[i], Event.stopPropagation);

						            bringRootToWindowTopLeft();
						            _nativeMethods2.default.documentAddEventListener.call(document, 'DOMContentLoaded', bringRootToWindowTopLeft);
						        } else document.body.appendChild(root);
						        /*eslint-enable indent */
						    }

						    return root;
						}

						function init(window, document) {
						    (function overrideDocument() {
						        document.elementFromPoint = function () {
						            //T212974
						            addClass(getRoot(), HIDDEN_CLASS);

						            var res = filterElement(_nativeMethods2.default.elementFromPoint.apply(document, arguments));

						            removeClass(getRoot(), HIDDEN_CLASS);

						            return res;
						        };

						        document.getElementById = function () {
						            return filterElement(_nativeMethods2.default.getElementById.apply(document, arguments));
						        };

						        document.getElementsByClassName = function () {
						            return filterNodeList(_nativeMethods2.default.getElementsByClassName.apply(document, arguments));
						        };

						        document.getElementsByName = function () {
						            return filterNodeList(_nativeMethods2.default.getElementsByName.apply(document, arguments));
						        };

						        document.getElementsByTagName = function () {
						            return filterNodeList(_nativeMethods2.default.getElementsByTagName.apply(document, arguments));
						        };

						        document.querySelector = function () {
						            return filterElement(_nativeMethods2.default.querySelector.apply(document, arguments));
						        };

						        document.querySelectorAll = function () {
						            return filterNodeList(_nativeMethods2.default.querySelectorAll.apply(document, arguments));
						        };

						        // T195358
						        document.querySelectorAll.toString = function () {
						            return _nativeMethods2.default.querySelectorAll.toString();
						        };

						        document.getElementsByClassName.toString = function () {
						            return _nativeMethods2.default.getElementsByClassName.toString();
						        };
						    })();
						}

						function onBodyContentChanged() {
						    if (root) {
						        if (!DOM.closest(root, 'html')) document.body.appendChild(root);
						    }
						}

						//NOTE: fix for B239138 - unroll.me 'Cannot read property 'document' of null' error raised during recording
						//There were an issue then document.body was replaced, so we need to reattach UI to new body manually

						function onBodyElementMutation() {
						    if (root) {
						        if (root.parentNode !== document.body) {
						            overrideElement(document.body);
						            document.body.appendChild(root);
						        }
						    }
						}

						function overrideElement(el) {
						    var tagName = el && el.tagName && el.tagName.toLowerCase();

						    if (tagName && (tagName === 'body' || tagName === 'head')) {
						        el.getElementsByClassName = function () {
						            return filterNodeList(_nativeMethods2.default.elementGetElementsByClassName.apply(el, arguments));
						        };

						        el.getElementsByTagName = function () {
						            return filterNodeList(_nativeMethods2.default.elementGetElementsByTagName.apply(el, arguments));
						        };

						        el.querySelector = function () {
						            return filterElement(_nativeMethods2.default.elementQuerySelector.apply(el, arguments));
						        };

						        el.querySelectorAll = function () {
						            return filterNodeList(_nativeMethods2.default.elementQuerySelectorAll.apply(el, arguments));
						        };
						    }
						}

						// Accessors

						function getFirstChild(el) {
						    var childNodes = filterNodeList(el.childNodes);

						    return childNodes.length && childNodes[0] ? childNodes[0] : null;
						}

						function getFirstElementChild(el) {
						    var childNodes = filterNodeList(el.childNodes);
						    var cnLength = childNodes.length;

						    for (var i = 0; i < cnLength; i++) {
						        if (childNodes[i].nodeType === 1) return childNodes[i];
						    }

						    return null;
						}

						function getLastChild(el) {
						    var childNodes = filterNodeList(el.childNodes);
						    var index = childNodes.length - 1;

						    return index >= 0 ? childNodes[index] : null;
						}

						function getLastElementChild(el) {
						    var childNodes = filterNodeList(el.childNodes);
						    var cnLength = childNodes.length;

						    for (var i = cnLength - 1; i >= 0; i--) {
						        if (childNodes[i].nodeType === 1) return childNodes[i];
						    }

						    return null;
						}

						// Utils

						function checkElementsPosition(collection) {
						    if (collection.length) {
						        var parent = collection[0].parentNode || collection[0].parentElement;
						        var shadowUIElements = [];

						        if (parent) {
						            for (var i = 0; i < collection.length; i++) {
						                if (DOM.isShadowUIElement(collection[i])) shadowUIElements.push(collection[i]);
						            }

						            for (var j = 0; j < shadowUIElements.length; j++) _nativeMethods2.default.appendChild.call(parent, shadowUIElements[j]);
						        }
						    }
						}

						function isShadowContainer(el) {
						    if (DOM.isDomElement(el)) {
						        var tagName = el.tagName.toLowerCase();

						        return tagName === 'head' || tagName === 'body';
						    }

						    return false;
						}

						function isShadowContainerCollection(collection) {
						    var parent = null;

						    try {
						        if (collection.length && !DOM.isWindowInstance(collection) && collection[0] && collection[0].nodeType) {
						            parent = collection[0].parentNode || collection[0].parentElement;

						            if (parent && (parent.childNodes === collection || parent.children === collection)) return isShadowContainer(parent);
						        }
						    }
						    /*eslint-disable no-empty */
						    catch (e) {}
						    /*eslint-disable no-empty */

						    return false;
						}

						function isShadowUIMutation(mutation) {
						    if (mutation.removedNodes && mutation.removedNodes.length === 1) {
						        if (DOM.isShadowUIElement(mutation.removedNodes[0])) return true;
						    }

						    if (mutation.addedNodes && mutation.addedNodes.length === 1) {
						        if (DOM.isShadowUIElement(mutation.addedNodes[0])) return true;
						    }

						    return false;
						}

						// API

						function addClass(elem, value) {
						    var patchedClass = patchClassNames(value);

						    DOM.addClass(elem, patchedClass);
						}

						function hasClass(elem, value) {
						    var patchedClass = patchClassNames(value);

						    return DOM.hasClass(elem, patchedClass);
						}

						function patchClassNames(value) {
						    var names = value.split(/\s+/);

						    for (var i = 0; i < names.length; i++) names[i] += _const2.default.SHADOW_UI_CLASSNAME_POSTFIX;

						    return names.join(' ');
						}

						function removeClass(elem, value) {
						    var patchedClass = patchClassNames(value);

						    DOM.removeClass(elem, patchedClass);
						}

						function select(selector, context) {
						    var patchedSelector = selector.replace(CLASSNAME_REGEX, function (className) {
						        return className + _const2.default.SHADOW_UI_CLASSNAME_POSTFIX;
						    });

						    return context ? _nativeMethods2.default.elementQuerySelectorAll.call(context, patchedSelector) : _nativeMethods2.default.querySelectorAll.call(document, patchedSelector);
						}

						function setBlind(value) {
						    if (value) addClass(getRoot(), BLIND_CLASS);else removeClass(getRoot(), BLIND_CLASS);
						}

						function getLastActiveElement() {
						    return lastActiveElement;
						}

						function setLastActiveElement(el) {
						    lastActiveElement = el;
						}
					},
					"upload": {
						"hidden-info.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.addInputInfo = addInputInfo;
							exports.getFormInfo = getFormInfo;
							exports.setFormInfo = setFormInfo;
							exports.removeInputInfo = removeInputInfo;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							var _const = require('../../../const');

							var _const2 = _interopRequireDefault(_const);

							function createInput(form) {
							    var hiddenInput = document.createElement('input');

							    hiddenInput.type = 'hidden';
							    hiddenInput.name = _const2.default.UPLOAD_SANDBOX_HIDDEN_INPUT_NAME;
							    hiddenInput.value = '[]';

							    form.appendChild(hiddenInput);

							    return hiddenInput;
							}

							function getInput(form) {
							    return form.querySelector('[name="' + _const2.default.UPLOAD_SANDBOX_HIDDEN_INPUT_NAME + '"]') || createInput(form);
							}

							function indexOf(info, input) {
							    for (var index = 0; index < info.length; index++) {
							        if (info[index].id === input.id || info[index].name === input.name) return index;
							    }

							    return -1;
							}

							function addInputInfo(input, fileList, value) {
							    var formInfo = getFormInfo(input);

							    if (formInfo) {
							        var files = [];

							        Array.prototype.slice.call(fileList).forEach(function (file) {
							            files.push({
							                name: file.name,
							                type: file.type,
							                data: file.base64
							            });
							        });

							        var inputInfoIndex = indexOf(formInfo, input);
							        var inputInfo = {
							            id: input.id,
							            name: input.name,
							            files: files,
							            value: value
							        };

							        if (inputInfoIndex === -1) formInfo.push(inputInfo);else formInfo[inputInfoIndex] = inputInfo;

							        setFormInfo(input, formInfo);
							    }
							}

							function getFormInfo(input) {
							    return input.form ? JSON.parse(getInput(input.form).value) : null;
							}

							function setFormInfo(input, info) {
							    if (input.form) {
							        var hiddenInput = getInput(input.form);

							        hiddenInput.value = JSON.stringify(info);
							    }
							}

							function removeInputInfo(input) {
							    var uploadInfo = getFormInfo(input);

							    if (uploadInfo) {
							        var inputInfoIndex = indexOf(uploadInfo, input);

							        if (inputInfoIndex !== -1) {
							            uploadInfo.splice(inputInfoIndex, 1);
							            setFormInfo(input, uploadInfo);

							            return true;
							        }
							    }

							    return false;
							}
						},
						"info-manager.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.clearUploadInfo = clearUploadInfo;
							exports.formatValue = formatValue;
							exports.getFileNames = getFileNames;
							exports.getFiles = getFiles;
							exports.getUploadInfo = getUploadInfo;
							exports.getValue = getValue;
							exports.loadFileListData = loadFileListData;
							exports.loadFilesInfoFromServer = loadFilesInfoFromServer;
							exports.prepareFileListWrapper = prepareFileListWrapper;
							exports.setUploadInfo = setUploadInfo;
							exports.sendFilesInfoToServer = sendFilesInfoToServer;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							/*global atob, Blob, FileReader*/

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var _hiddenInfo = require('./hidden-info');

							var HiddenInfo = _interopRequireWildcard(_hiddenInfo);

							var _nativeMethods = require('../native-methods');

							var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

							var _serviceMsgCmd = require('../../../service-msg-cmd');

							var _serviceMsgCmd2 = _interopRequireDefault(_serviceMsgCmd);

							var _const = require('../../../const');

							var _const2 = _interopRequireDefault(_const);

							var _transport = require('../../transport');

							var _transport2 = _interopRequireDefault(_transport);

							var _settings = require('../../settings');

							var _settings2 = _interopRequireDefault(_settings);

							var FAKE_PATH_STRING = 'C:\\fakepath\\';
							var UPLOAD_IFRAME_FOR_IE9_ID = 'uploadIFrameForIE9' + _const2.default.SHADOW_UI_CLASSNAME_POSTFIX;

							var uploadInfo = [];

							function FileListWrapper(length) {
							    this.length = length;
							    this.item = function (index) {
							        return this[index];
							    };
							}

							function base64ToBlob(base64Data, mimeType, sliceSize) {
							    mimeType = mimeType || '';
							    sliceSize = sliceSize || 512;

							    var byteCharacters = atob(base64Data);
							    var byteArrays = [];

							    for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
							        var slice = byteCharacters.slice(offset, offset + sliceSize);
							        var byteNumbers = new Array(slice.length);

							        for (var i = 0; i < slice.length; i++) byteNumbers[i] = slice.charCodeAt(i);

							        byteArrays.push(new Uint8Array(byteNumbers));
							    }

							    return new Blob(byteArrays, { type: mimeType });
							}

							function createFileListWrapper(fileList) {
							    var fileListWrapper = new FileListWrapper(fileList.length);

							    for (var i = 0; i < fileList.length; i++) fileListWrapper[i] = createFileWrapper(fileList[i]);

							    return fileListWrapper;
							}

							function createFileWrapper(fileInfo) {
							    var wrapper = null;

							    /*eslint-disable indent */
							    if (!window.Blob) {
							        wrapper = {
							            size: fileInfo.info.size,
							            type: fileInfo.info.type
							        };
							    } else if (fileInfo.blob) wrapper = new Blob([fileInfo.blob], { type: fileInfo.info.type });else wrapper = base64ToBlob(fileInfo.data, fileInfo.info.type);
							    /*eslint-enable indent*/

							    wrapper.name = fileInfo.info.name;
							    wrapper.lastModifiedDate = new Date(fileInfo.info.lastModifiedDate);
							    wrapper.base64 = fileInfo.data;

							    return wrapper;
							}

							function getFileListData(fileList) {
							    var data = [];

							    for (var i = 0; i < fileList.length; i++) data.push(fileList[i].base64);

							    return data;
							}

							function getUploadIFrameForIE9() {
							    var uploadIFrame = _nativeMethods2.default.querySelector.call(document, '#' + UPLOAD_IFRAME_FOR_IE9_ID);

							    if (!uploadIFrame) {
							        uploadIFrame = _nativeMethods2.default.createElement.call(document, 'iframe');

							        _nativeMethods2.default.setAttribute.call(uploadIFrame, 'id', UPLOAD_IFRAME_FOR_IE9_ID);
							        _nativeMethods2.default.setAttribute.call(uploadIFrame, 'name', UPLOAD_IFRAME_FOR_IE9_ID);
							        uploadIFrame.style.display = 'none';

							        _nativeMethods2.default.querySelector.call(document, '#root' + _const2.default.SHADOW_UI_CLASSNAME_POSTFIX).appendChild(uploadIFrame);
							    }

							    return uploadIFrame;
							}

							function loadFileListDataForIE9(input, callback) {
							    var form = input.form;

							    /*eslint-disable indent */
							    if (form && input.value) {
							        var sourceTarget = form.target;
							        var sourceActionString = form.action;
							        var sourceMethod = form.method;
							        var uploadIFrame = getUploadIFrameForIE9();

							        var loadHandler = function () {
							            var fileListWrapper = new FileListWrapper(1);

							            fileListWrapper[0] = createFileWrapper(JSON.parse(uploadIFrame.contentWindow.document.body.innerHTML));
							            uploadIFrame.removeEventListener('load', loadHandler);
							            callback(fileListWrapper);
							        };

							        uploadIFrame.addEventListener('load', loadHandler);

							        form.action = _settings2.default.get().IE9_FILE_READER_SHIM_URL + '?input-name=' + input.name + '&filename=' + input.value;
							        form.target = UPLOAD_IFRAME_FOR_IE9_ID;
							        form.method = 'post';

							        form.submit();

							        form.action = sourceActionString;
							        form.target = sourceTarget;
							        form.method = sourceMethod;
							    } else callback(new FileListWrapper(0));
							    /*eslint-enable indent */
							}

							function clearUploadInfo(input) {
							    var inputInfo = getUploadInfo(input);

							    if (inputInfo) {
							        inputInfo.files = createFileListWrapper([]);
							        inputInfo.value = '';

							        return HiddenInfo.removeInputInfo(input);
							    }
							}

							function formatValue(fileNames) {
							    var value = '';

							    fileNames = typeof fileNames === 'string' ? [fileNames] : fileNames;

							    if (fileNames && fileNames.length) {
							        /*eslint-disable indent */
							        if (Browser.isWebKit) value = FAKE_PATH_STRING + fileNames[0].split('/').pop();else if (Browser.isIE9 || Browser.isIE10) {
							            var filePaths = [];

							            for (var i = 0; i < fileNames.length; i++) filePaths.push(FAKE_PATH_STRING + fileNames[i].split('/').pop());

							            value = filePaths.join(', ');
							        } else return fileNames[0].split('/').pop();
							        /*eslint-enable indent */
							    }

							    return value;
							}

							function getFileNames(fileList, value) {
							    var result = [];

							    /*eslint-disable indent */
							    if (fileList) {
							        for (var i = 0; i < fileList.length; i++) result.push(fileList[i].name);
							    } else if (value.lastIndexOf('\\') !== -1) result.push(value.substr(value.lastIndexOf('\\') + 1));
							    /*eslint-enable indent */

							    return result;
							}

							function getFiles(input) {
							    var inputInfo = getUploadInfo(input);

							    return inputInfo ? inputInfo.files : createFileListWrapper([]);
							}

							function getUploadInfo(input) {
							    for (var i = 0; i < uploadInfo.length; i++) {
							        if (uploadInfo[i].input === input) return uploadInfo[i];
							    }

							    return null;
							}

							function getValue(input) {
							    var inputInfo = getUploadInfo(input);

							    return inputInfo ? inputInfo.value : '';
							}

							function loadFileListData(input, fileList, callback) {
							    if (Browser.isIE9) loadFileListDataForIE9(input, callback);else if (!fileList.length) callback(new FileListWrapper(0));else {
							        var index = 0;
							        var fileReader = new FileReader();
							        var file = fileList[index];
							        var fileListWrapper = new FileListWrapper(fileList.length);

							        fileReader.addEventListener('load', function (e) {
							            fileListWrapper[index] = createFileWrapper({
							                data: e.target.result.substr(e.target.result.indexOf(',') + 1),
							                blob: file.slice(0, file.size),
							                info: {
							                    type: file.type,
							                    name: file.name,
							                    lastModifiedDate: file.lastModifiedDate
							                }
							            });

							            /*eslint-disable indent */
							            if (fileList[++index]) {
							                file = fileList[index];
							                fileReader.readAsDataURL(file);
							            } else callback(fileListWrapper);
							            /*eslint-enable indent */
							        });
							        fileReader.readAsDataURL(file);
							    }
							}

							function loadFilesInfoFromServer(filePaths, callback) {
							    _transport2.default.asyncServiceMsg({
							        cmd: _serviceMsgCmd2.default.GET_UPLOADED_FILES,
							        filePaths: typeof filePaths === 'string' ? [filePaths] : filePaths
							    }, callback);
							}

							function prepareFileListWrapper(filesInfo, callback) {
							    var errs = [];
							    var validFilesInfo = [];

							    for (var i = 0; i < filesInfo.length; i++) {
							        if (filesInfo[i].err) errs.push(filesInfo[i]);else validFilesInfo.push(filesInfo[i]);
							    }

							    callback(errs, createFileListWrapper(validFilesInfo));
							}

							function setUploadInfo(input, fileList, value) {
							    var inputInfo = getUploadInfo(input);

							    if (!inputInfo) {
							        inputInfo = { input: input };
							        uploadInfo.push(inputInfo);
							    }

							    inputInfo.files = fileList;
							    inputInfo.value = value;

							    HiddenInfo.addInputInfo(input, fileList, value);
							}

							function sendFilesInfoToServer(fileList, fileNames, callback) {
							    _transport2.default.asyncServiceMsg({
							        cmd: _serviceMsgCmd2.default.UPLOAD_FILES,
							        data: getFileListData(fileList),
							        fileNames: fileNames
							    }, callback);
							}
						},
						"upload.js": function (exports, module, require) {
							exports.__esModule = true;
							exports.init = init;
							exports.getFiles = getFiles;
							exports.getUploadElementValue = getUploadElementValue;
							exports.setUploadElementValue = setUploadElementValue;
							exports.upload = upload;

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

							var _utilsBrowser = require('../../utils/browser');

							var Browser = _interopRequireWildcard(_utilsBrowser);

							var _utilsDom = require('../../utils/dom');

							var DOM = _interopRequireWildcard(_utilsDom);

							var _utilsEvent = require('../../utils/event');

							var Event = _interopRequireWildcard(_utilsEvent);

							var _eventSimulator = require('../event/simulator');

							var EventSimulator = _interopRequireWildcard(_eventSimulator);

							var _utilsEventEmitter = require('../../utils/event-emitter');

							var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

							var _eventListeners = require('../event/listeners');

							var Listeners = _interopRequireWildcard(_eventListeners);

							var _const = require('../../../const');

							var _const2 = _interopRequireDefault(_const);

							var eventEmitter = new _utilsEventEmitter2.default();

							var START_FILE_UPLOADING_EVENT = 'startFileUploading';
							exports.START_FILE_UPLOADING_EVENT = START_FILE_UPLOADING_EVENT;
							var END_FILE_UPLOADING_EVENT = 'endFileUploading';

							exports.END_FILE_UPLOADING_EVENT = END_FILE_UPLOADING_EVENT;
							var on = eventEmitter.on.bind(eventEmitter);
							exports.on = on;
							var off = eventEmitter.off.bind(eventEmitter);

							exports.off = off;
							function riseChangeEvent(input) {
							    EventSimulator.change(input);
							}

							function getCurrentInfoManager(input) {
							    var contextWindow = input[_const2.default.DOM_SANDBOX_PROCESSED_CONTEXT];

							    return contextWindow.Hammerhead._UploadManager;
							}

							/*eslint-disable max-nested-callbacks */

							function init(window) {
							    Listeners.addInternalEventListener(window, ['change'], function (e, dispatched) {
							        var input = e.target || e.srcElement;
							        var currentInfoManager = getCurrentInfoManager(input);

							        if (DOM.isFileInput(input) && !dispatched) {
							            Event.stopPropagation(e);
							            Event.preventDefault(e);

							            if (!!input.value || !!currentInfoManager.getValue(input)) {
							                var fileNames = currentInfoManager.getFileNames(input.files, input.value);

							                eventEmitter.emit(START_FILE_UPLOADING_EVENT, fileNames, input);

							                currentInfoManager.loadFileListData(input, input.files, function (fileList) {
							                    currentInfoManager.setUploadInfo(input, fileList, input.value);
							                    currentInfoManager.sendFilesInfoToServer(fileList, fileNames, function (errs) {
							                        riseChangeEvent(input);
							                        eventEmitter.emit(END_FILE_UPLOADING_EVENT, errs);
							                    });
							                });
							            }
							        }
							    });
							}

							/*eslint-enable max-nested-callbacks */

							function getFiles(input) {
							    return input.files !== void 0 ? getCurrentInfoManager(input).getFiles(input) : void 0;
							}

							function getUploadElementValue(input) {
							    return getCurrentInfoManager(input).getValue(input);
							}

							function setUploadElementValue(input, value) {
							    if (value === '') {
							        if (getCurrentInfoManager(input).clearUploadInfo(input) && Browser.isIE && Browser.version > 10) riseChangeEvent(input);
							    }

							    return value;
							}

							function upload(input, filePaths, callback) {
							    var currentInfoManager = getCurrentInfoManager(input);

							    filePaths = filePaths || [];

							    currentInfoManager.loadFilesInfoFromServer(filePaths, function (filesInfo) {
							        currentInfoManager.prepareFileListWrapper(filesInfo, function (errs, fileList) {
							            if (!errs.length) {
							                var value = currentInfoManager.formatValue(filePaths);

							                currentInfoManager.setUploadInfo(input, fileList, value);
							                riseChangeEvent(input);
							            }

							            callback(errs);
							        });
							    });
							}
						}
					},
					"xhr.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.init = init;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						var _nativeMethods = require('./native-methods');

						var _nativeMethods2 = _interopRequireDefault(_nativeMethods);

						var _const = require('../../const');

						var _const2 = _interopRequireDefault(_const);

						var _utilsUrl = require('../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var _settings = require('../settings');

						var _settings2 = _interopRequireDefault(_settings);

						var _utilsEventEmitter = require('../utils/event-emitter');

						var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

						var SERVICE_MSG_REQUEST_FLAG = 'is_tc_req-c8f5bd4f';
						var XHR_PROPERTY_ACCESS_ERROR = 'INVALID_STATE_ERR';

						var corsSupported = false;

						//Event
						var XHR_COMPLETED = 'xhrCompleted';
						exports.XHR_COMPLETED = XHR_COMPLETED;
						var XHR_ERROR = 'xhrError';
						exports.XHR_ERROR = XHR_ERROR;
						var XHR_SEND = 'xhrSend';

						exports.XHR_SEND = XHR_SEND;
						var eventEmitter = new _utilsEventEmitter2.default();

						var on = eventEmitter.on.bind(eventEmitter);

						exports.on = on;
						// NOTE: We should wrap xhr response (B236741)
						function XMLHttpRequestWrapper(xhr) {
						    var eventHandlers = [];

						    function wrapFunc(xhr, xhrWrapper, funcName) {
						        xhrWrapper[funcName] = function () {
						            var args = Array.prototype.slice.call(arguments);
						            var isFunc = typeof args[1] === 'function';

						            if (funcName === 'addEventListener' && isFunc) {
						                var originHandler = args[1];
						                var wrappedHandler = function () {
						                    originHandler.apply(xhrWrapper, arguments);
						                };

						                args[1] = wrappedHandler;

						                eventHandlers.push({
						                    origin: originHandler,
						                    wrapped: wrappedHandler
						                });
						            } else if (funcName === 'removeEventListener' && isFunc) {
						                for (var i = 0; i < eventHandlers.length; i++) {
						                    if (eventHandlers[i].origin === args[1]) {
						                        args[1] = eventHandlers[i].wrapped;
						                        eventHandlers.splice(i, 1);

						                        break;
						                    }
						                }
						            }

						            return xhr[funcName].apply(xhr, args);
						        };
						    }

						    function wrapProp(xhr, xhrWrapper, propName) {
						        Object.defineProperty(xhrWrapper, propName, {
						            get: function () {
						                if (propName.indexOf('on') === 0) return typeof xhr[propName] === 'function' ? xhr[propName]('get') : xhr[propName];

						                return xhr[propName];
						            },
						            set: function (value) {
						                /*eslint-disable indent */
						                if (propName.indexOf('on') === 0) {
						                    xhr[propName] = typeof value !== 'function' ? value : (function (func) {
						                        return function () {
						                            return arguments[0] === 'get' ? func : func.apply(xhrWrapper, arguments);
						                        };
						                    })(value);
						                } else xhr[propName] = value;
						                /*eslint-enable indent */

						                return xhr[propName];
						            }
						        });
						    }

						    for (var prop in xhr) {
						        if (!Object.prototype.hasOwnProperty(prop)) {
						            var isFunction = false;

						            //in some cases xhr properties reading leads to error throwing (B253550, T177746)
						            //if it happens we wrap these properties without reading them
						            try {
						                isFunction = typeof xhr[prop] === 'function';
						            } catch (e) {
						                if (e.message.indexOf(XHR_PROPERTY_ACCESS_ERROR) < 0) throw e;
						            }

						            if (isFunction) wrapFunc(xhr, this, prop);else wrapProp(xhr, this, prop);
						        }
						    }
						}

						//Barrier
						function proxyXhrMethods(xhr) {
						    var open = xhr.open;
						    var send = xhr.send;
						    var abort = xhr.abort;

						    xhr.abort = function () {
						        abort.call(xhr);
						        eventEmitter.emit(XHR_ERROR, {
						            err: new Error('XHR aborted'),
						            xhr: xhr
						        });
						    };

						    //NOTE: redirect all requests to TestCafe proxy and ensure that request don't violate Same Origin Policy
						    xhr.open = function (method, url, async, user, password) {
						        if (url === _settings2.default.get().SERVICE_MSG_URL) xhr[SERVICE_MSG_REQUEST_FLAG] = true;else {
						            try {
						                url = _utilsUrl2.default.getProxyUrl(url);
						            } catch (err) {
						                eventEmitter.emit(XHR_ERROR, {
						                    err: err,
						                    xhr: xhr
						                });

						                return;
						            }
						        }

						        //NOTE: the 'async' argument is true by default. But when you send 'undefined' as the 'async' argument
						        // a browser (Chrome, FF) casts it to 'false', and request becomes synchronous (B238528).
						        if (arguments.length === 2) open.call(xhr, method, url);else open.call(xhr, method, url, async, user, password);
						    };

						    xhr.send = function () {
						        if (!xhr[SERVICE_MSG_REQUEST_FLAG]) {
						            eventEmitter.emit(XHR_SEND, { xhr: xhr });

						            var orscHandler = function () {
						                if (xhr.readyState === 4) eventEmitter.emit(XHR_COMPLETED, { xhr: xhr });
						            };

						            //NOTE: if we're in sync mode or it's in cache and has been retrieved directly (IE6 & IE7)
						            //we need to manually fire the callback
						            if (xhr.readyState === 4) orscHandler();else {
						                //NOTE: get out of current execution tick and when proxy onreadystatechange.
						                //Because e.g. jQuery assigns handler after send() was called.
						                _nativeMethods2.default.setTimeout.call(window, function () {
						                    //NOTE: if state already changed we just call handler without onreadystatechange proxying
						                    /*eslint-disable indent */
						                    if (xhr.readyState === 4) orscHandler();else if (typeof xhr.onreadystatechange === 'function') {
						                        var originalHandler = xhr.onreadystatechange;

						                        xhr.onreadystatechange = function (progress) {
						                            orscHandler();
						                            originalHandler.call(xhr, progress);
						                        };
						                    } else xhr.addEventListener('readystatechange', orscHandler, false);
						                    /*eslint-enable indent */
						                }, 0);
						            }
						        }

						        /*jshint bitwise: false*/
						        //NOTE: add XHR request mark, so proxy can recognize it as XHR request.
						        //Due to the fact that all requests are passed to the proxy we need to perform all Same Origin Policy
						        //compliance checks on server side. So we pass CORS support flag as well to inform proxy that it can
						        //analyze Access-Control_Allow_Origin flag and skip "preflight" requests.
						        xhr.setRequestHeader(_const2.default.XHR_REQUEST_MARKER_HEADER, (corsSupported ? _const2.default.XHR_CORS_SUPPORTED_FLAG : 0) | (xhr.withCredentials ? _const2.default.XHR_WITH_CREDENTIALS_FLAG : 0));
						        /*jshint bitwise: true*/

						        send.apply(xhr, arguments);
						    };
						}

						function init(window) {
						    window.XMLHttpRequest = function () {
						        var xhr = new _nativeMethods2.default.XMLHttpRequest();

						        proxyXhrMethods(xhr);

						        corsSupported = typeof xhr.withCredentials !== 'undefined';

						        //NOTE: emulate CORS, so 3rd party libs (e.g. jQuery) will allow requests with proxy host and
						        //origin page host as well
						        if (!corsSupported) xhr.withCredentials = false;

						        XMLHttpRequestWrapper.prototype = xhr;

						        return new XMLHttpRequestWrapper(xhr);
						    };
						}
					}
				},
				"settings.js": function (exports, module, require) {
					exports.__esModule = true;
					var Settings = {
					    settings: {},

					    set: function (value) {
					        this.settings = value;
					    },

					    get: function () {
					        return this.settings;
					    }
					};

					exports.default = Settings;
					module.exports = exports.default;
				},
				"transport.js": function (exports, module, require) {
					exports.__esModule = true;

					function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

					function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

					/*eslint-disable no-native-reassign*/

					var _json = require('./json');

					var JSON = _interopRequireWildcard(_json);

					var _sandboxesNativeMethods = require('./sandboxes/native-methods');

					var _sandboxesNativeMethods2 = _interopRequireDefault(_sandboxesNativeMethods);

					var _serviceMsgCmd = require('../service-msg-cmd');

					var _serviceMsgCmd2 = _interopRequireDefault(_serviceMsgCmd);

					var _utilsBrowser = require('./utils/browser');

					var Browser = _interopRequireWildcard(_utilsBrowser);

					var _utilsEventEmitter = require('./utils/event-emitter');

					var _utilsEventEmitter2 = _interopRequireDefault(_utilsEventEmitter);

					var _settings = require('./settings');

					var _settings2 = _interopRequireDefault(_settings);

					/*eslint-enable no-native-reassign*/

					var Promise = require('es6-promise').Promise;

					//Const
					var SWITCH_BACK_TO_ASYNC_XHR_DELAY = 2000;
					var SERVICE_MESSAGES_WAITING_INTERVAL = 50;
					var MSG_RECEIVED = 'received';

					//Globals
					var eventEmitter = new _utilsEventEmitter2.default();
					var msgQueue = {};
					var useAsyncXhr = true;
					var activeServiceMessagesCounter = 0;
					var Transport = {};

					//NOTE: if we are unloading we should switch to sync XHR to be sure that we will not lost any service msgs
					window.addEventListener('beforeunload', function () {
					    useAsyncXhr = false;

					    //NOTE: if unloading was canceled switch back to async XHR
					    _sandboxesNativeMethods2.default.setTimeout.call(window, function () {
					        useAsyncXhr = true;
					    }, SWITCH_BACK_TO_ASYNC_XHR_DELAY);
					}, true);

					Transport.sendNextQueuedMsg = function (queueId) {
					    var queueItem = msgQueue[queueId][0];

					    Transport.asyncServiceMsg(queueItem.msg, function (res) {
					        if (queueItem.callback) queueItem.callback(res);

					        msgQueue[queueId].shift();

					        eventEmitter.emit(MSG_RECEIVED, {});

					        if (msgQueue[queueId].length) Transport.sendNextQueuedMsg(queueId);
					    });
					};

					function storeMessage(msg) {
					    var storedMessages = getStoredMessages();

					    storedMessages.push(msg);

					    window.localStorage.setItem(_settings2.default.get().JOB_UID, JSON.stringify(storedMessages));
					}

					function getStoredMessages() {
					    var storedMessagesStr = window.localStorage.getItem(_settings2.default.get().JOB_UID);

					    return storedMessagesStr ? JSON.parse(storedMessagesStr) : [];
					}

					function removeMessageFromStore(cmd) {
					    var messages = getStoredMessages();

					    for (var i = 0; i < messages.length; i++) {
					        if (messages[i].cmd === cmd) {
					            messages.splice(i, 1);

					            break;
					        }
					    }

					    window.localStorage.setItem(_settings2.default.get().JOB_UID, JSON.stringify(messages));
					}

					function createXMLHttpRequest(async) {
					    var xhr = new _sandboxesNativeMethods2.default.XMLHttpRequest();

					    xhr.open('POST', _settings2.default.get().SERVICE_MSG_URL, async);
					    xhr.setRequestHeader('Cache-Control', 'no-cache, no-store, must-revalidate');

					    return xhr;
					}

					function cookieMsgInProgress() {
					    return msgQueue[_serviceMsgCmd2.default.SET_COOKIE] && !!msgQueue[_serviceMsgCmd2.default.SET_COOKIE].length;
					}

					Transport.waitCookieMsg = function (callback) {
					    /*eslint-disable indent*/
					    if (cookieMsgInProgress()) {
					        var handler = function () {
					            if (!cookieMsgInProgress()) {
					                eventEmitter.off(MSG_RECEIVED, handler);

					                callback();
					            }
					        };

					        eventEmitter.on(MSG_RECEIVED, handler);
					    } else callback();
					    /*eslint-enable indent*/
					};

					//NOTE: use sync method for most important things only
					Transport.syncServiceMsg = function (msg, callback) {
					    var storedSync = useAsyncXhr;

					    useAsyncXhr = false;

					    Transport.asyncServiceMsg(msg, function (res) {
					        useAsyncXhr = storedSync;
					        callback(res);
					    });
					};

					Transport.waitForServiceMessagesCompleted = function (callback, timeout) {
					    if (!activeServiceMessagesCounter) {
					        callback();
					        return;
					    }

					    var intervalId = null;
					    var timeoutId = window.setTimeout(function () {
					        window.clearInterval(intervalId);
					        callback();
					    }, timeout);

					    intervalId = window.setInterval(function () {
					        if (!activeServiceMessagesCounter) {
					            window.clearInterval(intervalId);
					            window.clearTimeout(timeoutId);
					            callback();
					        }
					    }, SERVICE_MESSAGES_WAITING_INTERVAL);
					};

					Transport.asyncServiceMsg = function (msg, callback) {
					    msg.jobUid = _settings2.default.get().JOB_UID;
					    msg.jobOwnerToken = _settings2.default.get().JOB_OWNER_TOKEN;

					    if (isIFrameWithoutSrc) msg.referer = _settings2.default.get().REFERER;

					    var sendMsg = function (forced) {
					        activeServiceMessagesCounter++;

					        var requestIsAsync = useAsyncXhr;

					        if (forced) requestIsAsync = false;

					        var request = createXMLHttpRequest(requestIsAsync);
					        var msgCallback = function () {
					            activeServiceMessagesCounter--;

					            if (callback) callback(this.responseText && JSON.parse(this.responseText));
					        };
					        var errorHandler = function () {
					            /*eslint-disable indent*/
					            if (Browser.isWebKit) {
					                storeMessage(msg);
					                msgCallback();
					            } else sendMsg(true);
					            /*eslint-enable indent*/
					        };

					        if (forced) request.addEventListener('readystatechange', function () {
					            if (this.readyState !== 4) return;

					            msgCallback();
					        });else if (Browser.isIE9) {
					            //aborted ajax request in IE9 not raise error, abort or timeout events
					            //also getting status code raise error c00c023f
					            request.addEventListener('readystatechange', function () {
					                if (this.readyState !== 4) return;

					                var status = 0;

					                try {
					                    status = this.status;
					                } catch (e) {
					                    errorHandler();
					                }

					                if (status === 200) msgCallback.call(this);
					            });
					        } else {
					            request.addEventListener('load', msgCallback);
					            request.addEventListener('abort', errorHandler);
					            request.addEventListener('error', errorHandler);
					            request.addEventListener('timeout', errorHandler);
					        }

					        request.send(JSON.stringify(msg));
					    };

					    removeMessageFromStore(msg.cmd);
					    sendMsg();
					};

					Transport.batchUpdate = function (updateCallback) {
					    var storedMessages = getStoredMessages();

					    /*eslint-disable indent*/
					    if (storedMessages.length) {
					        window.localStorage.removeItem(_settings2.default.get().JOB_UID);

					        var tasks = storedMessages.map(function (item) {
					            return new Promise(function (resolve) {
					                Transport.queuedAsyncServiceMsg(item, resolve);
					            });
					        });

					        Promise.all(tasks).then(updateCallback);
					    } else updateCallback();
					    /*eslint-enable indent*/
					};

					Transport.queuedAsyncServiceMsg = function (msg, callback) {
					    if (!msgQueue[msg.cmd]) msgQueue[msg.cmd] = [];

					    msgQueue[msg.cmd].push({
					        msg: msg,
					        callback: callback
					    });

					    //NOTE: if we don't have pending msgs except this one then send it immediately
					    if (msgQueue[msg.cmd].length === 1) Transport.sendNextQueuedMsg(msg.cmd);
					};

					exports.default = Transport;
					module.exports = exports.default;
				},
				"utils": {
					"browser.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.init = init;
						function getMSEdgeVersion(userAgent) {
						    var edgeStrIndex = userAgent.indexOf('edge/');

						    return parseInt(userAgent.substring(edgeStrIndex + 5, userAgent.indexOf('.', edgeStrIndex)), 10);
						}

						function calculateBrowserAndVersion(userAgent) {
						    var webkitRegEx = /(webkit)[ \/]([\w.]+)/;
						    var operaRegEx = /(opera)(?:.*version)?[ \/]([\w.]+)/;
						    var msieRegEx = /(msie) ([\w.]+)/;
						    var firefoxRegEx = /(firefox)/;

						    var match = webkitRegEx.exec(userAgent) || operaRegEx.exec(userAgent) || msieRegEx.exec(userAgent) || userAgent.indexOf('compatible') < 0 && firefoxRegEx.exec(userAgent) || [];

						    return {
						        name: match[1] || '',
						        version: match[2] || '0'
						    };
						}

						function init(win) {
						    win = win || window;

						    var userAgent = win.navigator.userAgent.toLowerCase();
						    var browser = calculateBrowserAndVersion(userAgent);
						    var majorBrowserVersion = parseInt(browser.version, 10);
						    var isIE11 = /trident\/7.0/.test(userAgent) && !(browser.name === 'msie' && (majorBrowserVersion === 9 || majorBrowserVersion === 10));

						    if (isIE11) majorBrowserVersion = 11;

						    var exports = module.exports;

						    exports.isAndroid = /android/.test(userAgent);
						    exports.isMSEdge = !!/edge\//.test(userAgent);
						    exports.version = exports.isMSEdge ? getMSEdgeVersion(userAgent) : majorBrowserVersion;
						    exports.isIOS = /(iphone|ipod|ipad)/.test(userAgent);
						    exports.isIE11 = isIE11;
						    exports.isIE = browser.name === 'msie' || isIE11 || exports.isMSEdge;
						    exports.isIE10 = exports.isIE && exports.version === 10;
						    exports.isIE9 = exports.isIE && exports.version === 9;
						    exports.isMozilla = browser.name === 'firefox' && !isIE11;
						    exports.isOpera = browser.name === 'opera';
						    exports.isOperaWithWebKit = /opr/.test(userAgent);
						    exports.isSafari = exports.isIOS || /safari/.test(userAgent) && !/chrome/.test(userAgent);
						    exports.isWebKit = browser.name === 'webkit' && !exports.isMSEdge && !exports.isSafari;
						    exports.hasTouchEvents = !!('ontouchstart' in win);

						    //NOTE: we need check of touch points only for IE, because it has PointerEvent and MSPointerEvent (IE10, IE11) instead TouchEvent (T109295)
						    exports.isTouchDevice = exports.hasTouchEvents || exports.isIE && (win.navigator.maxTouchPoints > 0 || win.navigator.msMaxTouchPoints > 0);

						    exports.isMacPlatform = /^Mac/.test(win.navigator.platform);
						}

						init();
					},
					"cookie.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.parse = parse;
						exports.format = format;
						exports.get = get;
						exports.del = del;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						var _utilsStringTrim = require('../../utils/string-trim');

						var _utilsStringTrim2 = _interopRequireDefault(_utilsStringTrim);

						//NOTE: The name/key cannot be empty but the value can
						var COOKIE_PAIR_REGEX = /^([^=;]+)\s*=\s*(("?)[^\n\r\0]*\3)/;
						var TRAILING_SEMICOLON_REGEX = /;+$/;

						//Exports
						//-------------------------------------------------------------------------------------

						function parse(str) {
						    str = _utilsStringTrim2.default(str);

						    var trailingSemicolonCheck = TRAILING_SEMICOLON_REGEX.exec(str);

						    if (trailingSemicolonCheck) str = str.slice(0, trailingSemicolonCheck.index);

						    var firstSemicolonIdx = str.indexOf(';');
						    var keyValueString = firstSemicolonIdx > -1 ? str.substr(0, firstSemicolonIdx) : str;
						    var keyValueParsingResult = COOKIE_PAIR_REGEX.exec(keyValueString);

						    if (!keyValueParsingResult) return null;

						    var parsedCookie = {
						        key: keyValueParsingResult[1],
						        value: keyValueParsingResult[2]
						    };

						    parsedCookie.key = _utilsStringTrim2.default(parsedCookie.key);
						    parsedCookie.value = _utilsStringTrim2.default(parsedCookie.value);

						    if (firstSemicolonIdx === -1) return parsedCookie;

						    var attributesString = _utilsStringTrim2.default(str.slice(firstSemicolonIdx).replace(/^\s*;\s*/, ''));

						    if (attributesString.length === 0) return parsedCookie;

						    var attrValStrings = attributesString.split(/\s*;\s*/);

						    while (attrValStrings.length) {
						        var attrValueStr = attrValStrings.shift();
						        var separatorIdx = attrValueStr.indexOf('=');
						        var key = null;
						        var value = null;

						        if (separatorIdx === -1) key = attrValueStr;else {
						            key = attrValueStr.substr(0, separatorIdx);
						            value = _utilsStringTrim2.default(attrValueStr.substr(separatorIdx + 1));
						        }

						        key = _utilsStringTrim2.default(key.toLowerCase());

						        switch (key) {
						            case 'expires':
						            case 'max-age':
						            case 'path':
						                parsedCookie[key] = value;
						                break;

						            case 'secure':
						            case 'httponly':
						                parsedCookie[key] = true;
						                break;

						            case 'domain':
						                //NOTE: remove leading '.'
						                parsedCookie.domain = _utilsStringTrim2.default(value.replace(/^\./, ''));
						                break;

						            default:
						                break;
						        }
						    }

						    return parsedCookie;
						}

						function format(parsedCookie) {
						    var cookieStr = parsedCookie.key;

						    if (parsedCookie.value !== null) cookieStr += '=' + parsedCookie.value;

						    cookieStr += ';';

						    for (var attrName in parsedCookie) {
						        if (parsedCookie.hasOwnProperty(attrName)) {
						            if (attrName !== 'key' && attrName !== 'value') {
						                cookieStr += attrName;

						                //NOTE: skip attrs without value and boolean attrs (e.g. Secure)
						                if (typeof parsedCookie[attrName] !== 'undefined' && parsedCookie[attrName] !== true) cookieStr += '=' + parsedCookie[attrName];

						                cookieStr += ';';
						            }
						        }
						    }

						    return cookieStr;
						}

						function get(document, name) {
						    var cookies = document.cookie.split(';');

						    for (var i = 0; i < cookies.length; i++) {
						        var cookie = _utilsStringTrim2.default(cookies[i]);

						        if (cookie.indexOf(name + '=') === 0 || cookie === name) return cookie;
						    }

						    return null;
						}

						function del(document, parsedCookie) {
						    parsedCookie.expires = 'Thu, 01 Jan 1970 00:00:01 GMT';
						    parsedCookie.value = '';

						    document.cookie = format(parsedCookie);
						}
					},
					"create-property-desc.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.default = createPropertyDesc;

						function createPropertyDesc(descBase) {
						    descBase.configurable = true;
						    descBase.enumerable = true;

						    return descBase;
						}

						module.exports = exports.default;
					},
					"dom.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.getActiveElement = getActiveElement;
						exports.getChildVisibleIndex = getChildVisibleIndex;
						exports.getIFrameByElement = getIFrameByElement;
						exports.getIFrameByWindow = getIFrameByWindow;
						exports.getMapContainer = getMapContainer;
						exports.getScrollbarSize = getScrollbarSize;
						exports.getSelectParent = getSelectParent;
						exports.getSelectVisibleChildren = getSelectVisibleChildren;
						exports.getTopSameDomainWindow = getTopSameDomainWindow;
						exports.find = find;
						exports.findDocument = findDocument;
						exports.isContentEditableElement = isContentEditableElement;
						exports.isCrossDomainIframe = isCrossDomainIframe;
						exports.isCrossDomainWindows = isCrossDomainWindows;
						exports.isDocumentInstance = isDocumentInstance;
						exports.isDomElement = isDomElement;
						exports.isElementInDocument = isElementInDocument;
						exports.isElementInIframe = isElementInIframe;
						exports.isFileInput = isFileInput;
						exports.isHammerheadAttr = isHammerheadAttr;
						exports.isIframe = isIframe;
						exports.isInputElement = isInputElement;
						exports.isInputWithoutSelectionPropertiesInMozilla = isInputWithoutSelectionPropertiesInMozilla;
						exports.isMapElement = isMapElement;
						exports.isRenderedNode = isRenderedNode;
						exports.isShadowUIElement = isShadowUIElement;
						exports.isSvgElement = isSvgElement;
						exports.isTextEditableInput = isTextEditableInput;
						exports.isTextEditableElement = isTextEditableElement;
						exports.isTextEditableElementAndEditingAllowed = isTextEditableElementAndEditingAllowed;
						exports.isTextNode = isTextNode;
						exports.isWindowInstance = isWindowInstance;
						exports.matches = matches;
						exports.closest = closest;
						exports.addClass = addClass;
						exports.removeClass = removeClass;
						exports.hasClass = hasClass;

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						var _utilsStringTrim = require('../../utils/string-trim');

						var _utilsStringTrim2 = _interopRequireDefault(_utilsStringTrim);

						var _browser = require('./browser');

						var Browser = _interopRequireWildcard(_browser);

						var _sandboxesNativeMethods = require('../sandboxes/native-methods');

						var _sandboxesNativeMethods2 = _interopRequireDefault(_sandboxesNativeMethods);

						var _const = require('../../const');

						var _const2 = _interopRequireDefault(_const);

						var _utilsUrl = require('../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var scrollbarSize = null;

						function getActiveElement(currentDocument) {
						    var doc = currentDocument || document;
						    var activeElement = doc.activeElement && doc.activeElement.tagName ? doc.activeElement : doc.body;

						    if (activeElement.tagName.toLowerCase() === 'iframe') {
						        try {
						            return getActiveElement(activeElement.contentDocument);
						        }
						        /*eslint-disable no-empty */
						        catch (e) {}
						        /*eslint-enable no-empty */
						    }

						    return activeElement;
						}

						function getChildVisibleIndex(select, child) {
						    var childrenArray = getSelectVisibleChildren(select);

						    return childrenArray.indexOf(child);
						}

						function getIFrameByElement(el) {
						    var currentDocument = el.documentElement ? el : findDocument(el);
						    var currentWindow = window !== window.top && isCrossDomainWindows(window.top, window) ? window : window.top;

						    var iframes = currentWindow.document.getElementsByTagName('iframe');

						    for (var i = 0; i < iframes.length; i++) {
						        if (iframes[i].contentDocument === currentDocument) return iframes[i];
						    }

						    return null;
						}

						function getIFrameByWindow(win) {
						    var iframes = window.top.document.getElementsByTagName('iframe');

						    for (var i = 0; i < iframes.length; i++) {
						        if (iframes[i].contentWindow === win) return iframes[i];
						    }

						    return null;
						}

						function getMapContainer(el) {
						    var closestMap = closest(el, 'map');
						    var closestMapName = _sandboxesNativeMethods2.default.getAttribute.call(closestMap, 'name');
						    var containerSelector = '[usemap=#' + closestMapName + ']';

						    return _sandboxesNativeMethods2.default.querySelector.call(findDocument(el), containerSelector);
						}

						function getScrollbarSize() {
						    if (!scrollbarSize) {
						        var scrollDiv = _sandboxesNativeMethods2.default.createElement.call(document, 'div');

						        scrollDiv.style.height = '100px';
						        scrollDiv.style.overflow = 'scroll';
						        scrollDiv.style.position = 'absolute';
						        scrollDiv.style.top = '-9999px';
						        scrollDiv.style.width = '100px';
						        document.body.appendChild(scrollDiv);

						        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;

						        scrollbarSize = scrollbarWidth;
						        scrollDiv.parentNode.removeChild(scrollDiv);
						    }

						    return scrollbarSize;
						}

						function getSelectParent(child) {
						    var parent = child.parentNode;

						    while (parent) {
						        if (parent.tagName && parent.tagName.toLowerCase() === 'select') return parent;

						        parent = parent.parentNode;
						    }
						    return null;
						}

						function getSelectVisibleChildren(select) {
						    var children = _sandboxesNativeMethods2.default.elementQuerySelectorAll.call(select, 'optgroup, option');

						    children = Array.prototype.slice.call(children);

						    if (Browser.isMozilla) {
						        //NOTE: Mozilla does not display group without label and with empty label
						        children = children.filter(function (item) {
						            return item.tagName.toLowerCase() !== 'optgroup' || !!item.label;
						        });
						    }

						    return children;
						}

						function getTopSameDomainWindow(window) {
						    try {
						        if (window !== window.top && _utilsUrl2.default.isIframeWithoutSrc(window.frameElement)) return getTopSameDomainWindow(window.parent);
						    }
						    /*eslint-disable no-empty */
						    catch (e) {}
						    /*eslint-enable no-empty */

						    return window;
						}

						function find(parent, selector, handler) {
						    var elms = _sandboxesNativeMethods2.default.elementQuerySelectorAll.call(parent, selector);

						    if (handler) {
						        for (var i = 0; i < elms.length; i++) handler(elms[i]);
						    }

						    return elms;
						}

						function findDocument(el) {
						    if (el.documentElement) return el;

						    if (el.ownerDocument && el.ownerDocument.defaultView) return el.ownerDocument;

						    return el.parentNode ? findDocument(el.parentNode) : document;
						}

						function isContentEditableElement(el) {
						    var isAlwaysNotEditableElement = function (el) {
						        var tagName = el.tagName.toLowerCase();
						        var notContentEditableElementsRegExp = /select|option|applet|area|audio|canvas|datalist|keygen|map|meter|object|progress|source|track|video|img/;
						        var inputElementsRegExp = /input|textarea|button/;

						        return tagName && (notContentEditableElementsRegExp.test(tagName) || inputElementsRegExp.test(tagName));
						    };

						    var isContentEditable = false;
						    var element = null;

						    if (isTextNode(el)) element = el.parentElement || el.parentNode;else element = el;

						    if (element) {
						        isContentEditable = element.isContentEditable && !isAlwaysNotEditableElement(element) && !isTextEditableElement(element);
						    }

						    return isRenderedNode(element) && (isContentEditable || findDocument(el).designMode === 'on');
						}

						function isCrossDomainIframe(iframe, bySrc) {
						    var iframeLocation = _utilsUrl2.default.getIframeLocation(iframe);

						    if (!bySrc && iframeLocation.documentLocation === null) return true;

						    var currentLocation = bySrc ? iframeLocation.srcLocation : iframeLocation.documentLocation;

						    if (currentLocation && _utilsUrl2.default.isSupportedProtocol(currentLocation)) return !_utilsUrl2.default.sameOriginCheck(location.toString(), currentLocation);

						    return false;
						}

						function isCrossDomainWindows(window1, window2) {
						    try {
						        if (window1 === window2) return false;

						        var window1Location = window1.location.toString();
						        var window2Location = window2.location.toString();

						        if (window1Location === 'about:blank' || window2Location === 'about:blank') return false;

						        return !_utilsUrl2.default.sameOriginCheck(window1Location, window2Location);
						    } catch (e) {
						        return true;
						    }
						}

						function isDocumentInstance(instance) {
						    if (instance instanceof _sandboxesNativeMethods2.default.documentClass) return true;

						    return instance && typeof instance === 'object' && typeof instance.referrer !== 'undefined' && instance.toString && (instance.toString() === '[object HTMLDocument]' || instance.toString() === '[object Document]');
						}

						function isDomElement(el) {
						    // T184805
						    if (el && typeof el.toString === 'function' && el.toString.toString().indexOf('[native code]') !== -1 && el.constructor && (el.constructor.toString().indexOf(' Element') !== -1 || el.constructor.toString().indexOf(' Node') !== -1)) return false;

						    //B252941
						    return el && (typeof el === 'object' || Browser.isMozilla && typeof el === 'function') && el.nodeType !== 11 && typeof el.nodeName === 'string' && el.tagName;
						}

						function isElementInDocument(el, currentDocument) {
						    var doc = currentDocument || document;
						    var curElement = el.parentNode;

						    while (curElement) {
						        if (curElement === doc) return true;

						        curElement = curElement.parentNode;
						    }

						    return false;
						}

						function isElementInIframe(el, currentDocument) {
						    var doc = currentDocument || findDocument(el);

						    return window.document !== doc;
						}

						function isFileInput(el) {
						    return isInputElement(el) && el.type.toLowerCase() === 'file';
						}

						function isHammerheadAttr(attr) {
						    return attr === _const2.default.HOVER_PSEUDO_CLASS_ATTR || attr.indexOf(_const2.default.DOM_SANDBOX_STORED_ATTR_POSTFIX) !== -1;
						}

						function isIframe(el) {
						    return isDomElement(el) && el.tagName.toLowerCase() === 'iframe';
						}

						function isInputElement(el) {
						    return isDomElement(el) && el.tagName.toLowerCase() === 'input';
						}

						function isInputWithoutSelectionPropertiesInMozilla(el) {
						    //T101195, T133144, T101195
						    return Browser.isMozilla && matches(el, 'input[type=number]');
						}

						function isMapElement(el) {
						    return (/^map$|^area$/i.test(el.tagName)
						    );
						}

						function isRenderedNode(node) {
						    return !(node.nodeType === 7 || node.nodeType === 8 || /^(script|style)$/i.test(node.nodeName));
						}

						function isShadowUIElement(element) {
						    while (element) {
						        if (element.tagName === 'BODY' || element.tagName === 'HEAD') return false;

						        //NOTE: check className type to avoid issues with SVG elements className property
						        if (typeof element.className === 'string' && element.className.indexOf(_const2.default.SHADOW_UI_CLASSNAME_POSTFIX) > -1) return true;

						        element = element.parentNode;
						    }

						    return false;
						}

						function isSvgElement(el) {
						    return !!closest(el, 'svg');
						}

						function isTextEditableInput(el) {
						    var editableInputTypesRegEx = /^(datetime|email|number|password|search|tel|text|url)$/;
						    var tagName = el.tagName ? el.tagName.toLowerCase() : '';

						    return tagName === 'input' && editableInputTypesRegEx.test(el.type);
						}

						function isTextEditableElement(el) {
						    var tagName = el.tagName ? el.tagName.toLowerCase() : '';

						    return isTextEditableInput(el) || tagName === 'textarea';
						}

						function isTextEditableElementAndEditingAllowed(el) {
						    var isElementEditingAllowed = function () {
						        return !el.readOnly && el.getAttribute('readonly') !== 'readonly';
						    };

						    return isTextEditableElement(el) && isElementEditingAllowed();
						}

						function isTextNode(node) {
						    return node && typeof node === 'object' && node.nodeType === 3 && typeof node.nodeName === 'string';
						}

						function isWindowInstance(instance) {
						    if (instance instanceof _sandboxesNativeMethods2.default.windowClass) return true;

						    var result = instance && typeof instance === 'object' && typeof instance.top !== 'undefined' && (Browser.isMozilla ? true : instance.toString && (instance.toString() === '[object Window]' || instance.toString() === '[object global]'));

						    if (result && instance.top !== instance) return isWindowInstance(instance.top);

						    return result;
						}

						function matches(el, selector) {
						    if (!el) return false;

						    var matchesSelector = el.matches || el.webkitMatchesSelector || el.msMatchesSelector;

						    if (!matchesSelector) return false;

						    return matchesSelector.call(el, selector);
						}

						function closest(el, selector) {
						    if (el && el.closest) return el.closest(selector);

						    var closestFallback = function (el, selector) {
						        while (el) {
						            if (matches(el, selector)) return el;

						            el = el.parentNode;
						        }

						        return null;
						    };

						    return closestFallback(el, selector);
						}

						function addClass(el, className) {
						    if (!el) return;

						    //IE10+
						    if (el && el.classList) {
						        var classNames = className.split(/\s+/);

						        classNames.forEach(function (item) {
						            el.classList.add(item);
						        });
						    } else {
						        var addClassFallback = function (el, className) {
						            if (className) {
						                var classNames = className.split(/\s+/);
						                var setClass = ' ' + el.className + ' ';

						                for (var i = 0; i < classNames.length; i++) {
						                    if (setClass.indexOf(' ' + classNames[i] + ' ') === -1) setClass += classNames[i] + ' ';
						                }

						                el.className = _utilsStringTrim2.default(setClass);
						            }
						        };

						        addClassFallback(el, className);
						    }
						}

						function removeClass(el, className) {
						    if (!el) return;

						    //IE10+
						    if (el.classList) {
						        var classNames = className.split(/\s+/);

						        classNames.forEach(function (item) {
						            el.classList.remove(item);
						        });
						    } else {
						        var removeClassFallback = function (el, className) {
						            if (el.className && className) {
						                var classNames = (className || '').split(/\s+/);

						                className = (' ' + el.className + ' ').replace(/[\n\t\r]/g, ' ');

						                for (var i = 0; i < classNames.length; i++) className = className.replace(' ' + classNames[i] + ' ', ' ');

						                el.className = _utilsStringTrim2.default(className);
						            }
						        };

						        removeClassFallback(el, className);
						    }
						}

						function hasClass(el, className) {
						    if (!el) return false;

						    //IE10+
						    if (el.classList) return el.classList.contains(className);

						    var hasClassFallback = function (el, className) {
						        var preparedElementClassName = (' ' + el.className + ' ').replace(/[\n\t\r]/g, ' ');

						        className = ' ' + className + ' ';

						        return preparedElementClassName.indexOf(className) !== -1;
						    };

						    return hasClassFallback(el, className);
						}
					},
					"event-emitter.js": function (exports, module, require) {
						exports.__esModule = true;
						var EventEmitter = function () {
						    this.eventsListeners = [];
						};

						EventEmitter.prototype.emit = function (evt) {
						    var listeners = this.eventsListeners[evt];

						    if (listeners) {
						        for (var i = 0; i < listeners.length; i++) {
						            try {
						                if (listeners[i]) listeners[i].apply(this, Array.prototype.slice.apply(arguments, [1]));
						            } catch (e) {
						                // Hack for IE: after document.write calling IFrameSandbox event handlers
						                // rises 'Can't execute code from a freed script' exception because document has been
						                // recreated
						                if (e.message && e.message.indexOf('freed script') > -1) listeners[i] = null;else throw e;
						            }
						        }
						    }
						};

						EventEmitter.prototype.off = function (evt, listener) {
						    var listeners = this.eventsListeners[evt];

						    if (listeners) {
						        this.eventsListeners[evt] = listeners.filter(function (item) {
						            return item !== listener;
						        });
						    }
						};

						EventEmitter.prototype.on = function (evt, listener) {
						    if (!this.eventsListeners[evt]) this.eventsListeners[evt] = [];

						    this.eventsListeners[evt].push(listener);
						};

						exports.default = EventEmitter;
						module.exports = exports.default;
					},
					"event.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.preventDefault = preventDefault;
						exports.stopPropagation = stopPropagation;
						var BUTTON = {
						    LEFT: 0,
						    MIDDLE: 1,
						    RIGHT: 2
						};

						exports.BUTTON = BUTTON;
						var BUTTONS_PARAMETER = {
						    NO_BUTTON: 0,
						    LEFT_BUTTON: 1,
						    RIGHT_BUTTON: 2
						};

						exports.BUTTONS_PARAMETER = BUTTONS_PARAMETER;
						var WHICH_PARAMETER = {
						    NO_BUTTON: 0,
						    LEFT_BUTTON: 1,
						    MIDDLE_BUTTON: 2,
						    RIGHT_BUTTON: 3
						};

						exports.WHICH_PARAMETER = WHICH_PARAMETER;
						var DOM_EVENTS = ['click', 'mousedown', 'mouseup', 'dblclick', 'contextmenu', 'mousemove', 'mouseover', 'mouseout', 'touchstart', 'touchmove', 'touchend', 'keydown', 'keypress', 'input', 'keyup', 'change', 'focus', 'blur', 'MSPointerDown', 'MSPointerMove', 'MSPointerOver', 'MSPointerOut', 'MSPointerUp', 'pointerdown', 'pointermove', 'pointerover', 'pointerout', 'pointerup', 'focusin', 'focusout', 'mouseenter', 'mouseleave', 'pointerenter', 'pointerleave'];

						exports.DOM_EVENTS = DOM_EVENTS;

						function preventDefault(ev, allowBubbling) {
						    if (ev.preventDefault) ev.preventDefault();else ev.returnValue = false;

						    if (!allowBubbling) stopPropagation(ev);
						}

						function stopPropagation(ev) {
						    if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();else if (ev.stopPropagation) ev.stopPropagation();

						    ev.cancelBubble = true;
						}
					},
					"extend.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.default = extend;

						function extend() {
						    var target = arguments[0] || {};

						    if (typeof target !== 'object' && target.toString() !== '[object Function]') target = {};

						    for (var i = 1; i < arguments.length; i++) {
						        for (var key in arguments[i]) {
						            if (arguments[i].hasOwnProperty(key)) target[key] = arguments[i][key];
						        }
						    }

						    return target;
						}

						module.exports = exports.default;
					},
					"html.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.isPageHtml = isPageHtml;
						exports.cleanUpHtml = cleanUpHtml;
						exports.processHtml = processHtml;
						exports.isWellFormattedHtml = isWellFormattedHtml;

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						var _sandboxesNativeMethods = require('../sandboxes/native-methods');

						var _sandboxesNativeMethods2 = _interopRequireDefault(_sandboxesNativeMethods);

						var _dom = require('./dom');

						var DOM = _interopRequireWildcard(_dom);

						var _domProcessorDomProcessor = require('../dom-processor/dom-processor');

						var _domProcessorDomProcessor2 = _interopRequireDefault(_domProcessorDomProcessor);

						var _processingScript = require('../../processing/script');

						var _processingScript2 = _interopRequireDefault(_processingScript);

						var _const = require('../../const');

						var Const = _interopRequireWildcard(_const);

						var _utilsUrl = require('../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var TEXT_NODE_COMMENT_MARKER = '16c959db8754';

						var INIT_SCRIPT_FOR_IFRAME_TEMPLATE = '<script class="' + Const.SHADOW_UI_SCRIPT_CLASSNAME + '" type="text/javascript">' + 'var parentHammerhead = null;' + 'try {' + '   parentHammerhead = window.parent.Hammerhead;' + '} catch(e) {}' + 'if (parentHammerhead) parentHammerhead._rebindDomSandboxToIframe(window.frameElement);' + 'var script = document.currentScript || document.scripts[document.scripts.length - 1];' + 'script.parentNode.removeChild(script);' + '<\/script>';

						exports.INIT_SCRIPT_FOR_IFRAME_TEMPLATE = INIT_SCRIPT_FOR_IFRAME_TEMPLATE;
						var htmlDocument = document.implementation.createHTMLDocument('title');
						var htmlParser = htmlDocument.createDocumentFragment();

						_domProcessorDomProcessor2.default.on(_domProcessorDomProcessor2.default.HTML_PROCESSING_REQUIRED, function (html, callback) {
						    if (!isPageHtml(html)) html = '<html><body>' + html + '</body></html>';

						    callback(processHtml(html));
						});

						function getHtmlDocument() {
						    try {
						        // IE bug: access denied
						        if (htmlDocument.location) htmlDocument.location.toString();
						    } catch (e) {
						        htmlDocument = document.implementation.createHTMLDocument('title');
						        htmlParser = htmlDocument.createDocumentFragment();
						    }

						    return htmlDocument;
						}

						function isPageHtml(html) {
						    return (/^\s*(<\s*(!doctype|html|head|body)[^>]*>)/i.test(html)
						    );
						}

						function processPageTag(pageTagHtml, process) {
						    pageTagHtml = pageTagHtml.replace(/^(\s*<\s*)(head|body|html)/i, '$1fakeTagName_$2');

						    return process(pageTagHtml).replace(/<\/fakeTagName_[\s\S]+$/i, '').replace(/fakeTagName_/i, '');
						}

						function processPageHtml(html, process) {
						    var doctypeRegEx = /^(\s*<\s*!doctype[^>]*>)([\s\S]*)$/i;
						    var headBodyRegEx = /^(\s*<\s*(head|body)[^>]*>)([\s\S]*?)(<\s*\/(head|body)\s*>\s*)?$/i;
						    var htmlContentRegEx = /^(\s*<\s*head[^>]*>)([\s\S]*?)(<\s*\/head\s*>\s*)(<\s*body[^>]*>)([\s\S]*?)(<\s*\/body\s*>\s*)?$/i;
						    var htmlRegEx = /^(\s*<\s*html[^>]*>)([\s\S]*?)(<\s*\/html\s*>\s*)?$/i;

						    var doctypeMatches = html.match(doctypeRegEx);

						    if (doctypeMatches) return doctypeMatches[1] + process(doctypeMatches[2]);

						    var htmlMatches = html.match(htmlRegEx);

						    if (htmlMatches) {
						        return processPageTag(htmlMatches[1], process) + process(htmlMatches[2], 'html') + (htmlMatches[3] || '');
						    }

						    var htmlContentMatches = html.match(htmlContentRegEx);

						    if (htmlContentMatches) {
						        return processPageTag(htmlContentMatches[1], process) + process(htmlContentMatches[2], 'head') + (htmlContentMatches[3] || '') + processPageTag(htmlContentMatches[4], process) + process(htmlContentMatches[5], 'body') + (htmlContentMatches[6] || '');
						    }

						    var headBodyMatches = html.match(headBodyRegEx);

						    if (headBodyMatches) {
						        return processPageTag(headBodyMatches[1], process) + process(headBodyMatches[3], headBodyMatches[2]) + (headBodyMatches[4] || '');
						    }
						}

						function wrapTextNodes(html) {
						    var textNodeRegEx = /(<\s*(table|tbody|\/tbody|\/tfoot|\/thead|\/tr|tfoot|thead|tr|\/td)[^>]*>)(\s*[^<\s]+[^<]*)(?=<)/ig;
						    var index = 0;

						    return html.replace(textNodeRegEx, function (str, p1, p2, p3) {
						        var marker = TEXT_NODE_COMMENT_MARKER + (index++).toString();

						        return p1 + '<!--' + marker + p3 + marker + '-->';
						    });
						}

						function unwrapTextNodes(html) {
						    var i = 0;
						    var marker = '';

						    do {
						        marker = TEXT_NODE_COMMENT_MARKER + i;
						        html = html.replace('<!--' + marker, '').replace(marker + '-->', '');
						    } while (html.indexOf(TEXT_NODE_COMMENT_MARKER + ++i) !== -1);

						    return html;
						}

						function processHtmlInternal(html, parentTag, process) {
						    html = wrapTextNodes(html);

						    var container = getHtmlDocument().createElement('div');

						    htmlParser.innerHTML = '';
						    _sandboxesNativeMethods2.default.appendChild.call(htmlParser, container);

						    parentTag = parentTag ? parentTag.toLowerCase() : '';

						    var isRow = parentTag === 'tr';
						    var isTable = parentTag === 'table' || parentTag === 'tbody';
						    var isScript = parentTag === 'script';

						    if (isTable) html = '<table>' + html + '</table>';else if (isRow) html = '<table><tr>' + html + '</tr></table>';else if (isScript) html = '<script>' + html + '</script>';

						    container.innerHTML = html;

						    if (process(container)) html = container.innerHTML;

						    if (isTable) html = html.replace(/^<table>(<tbody>)?|(<\/tbody>)?<\/table>$/ig, '');else if (isRow) html = html.replace(/^<table>(<tbody>)?<tr>|<\/tr>(<\/tbody>)?<\/table>$/ig, '');else if (isScript) html = html.replace(/^<script>|<\/script>$/ig, '');

						    return unwrapTextNodes(html);
						}

						function cleanUpHtml(html, parentTag) {
						    if (isPageHtml(html)) return processPageHtml(html, cleanUpHtml);

						    return processHtmlInternal(html, parentTag, function (container) {
						        var changed = false;

						        /*eslint-disable no-loop-func */
						        for (var i = 0; i < _domProcessorDomProcessor2.default.URL_ATTRS.length; i++) {
						            var attr = _domProcessorDomProcessor2.default.URL_ATTRS[i];
						            var storedAttr = _domProcessorDomProcessor2.default.getStoredAttrName(attr);

						            DOM.find(container, '[' + storedAttr + ']', function (el) {
						                if (el.hasAttribute(attr)) {
						                    _sandboxesNativeMethods2.default.setAttribute.call(el, attr, _sandboxesNativeMethods2.default.getAttribute.call(el, storedAttr));
						                    _sandboxesNativeMethods2.default.removeAttribute.call(el, storedAttr);

						                    changed = true;
						                }
						            });
						        }
						        /*eslint-disable no-loop-func */

						        DOM.find(container, '[class*="' + Const.SHADOW_UI_CLASSNAME_POSTFIX + '"]', function (el) {
						            if (el.parentNode) {
						                el.parentNode.removeChild(el);
						                changed = true;
						            }
						        });

						        DOM.find(container, 'script', function (el) {
						            var innerHTML = el.innerHTML;

						            if (_processingScript2.default.SCRIPT_HEADER_REG_EX.test(innerHTML)) {
						                el.innerHTML = innerHTML.replace(_processingScript2.default.SCRIPT_HEADER_REG_EX, '');

						                changed = true;
						            }
						        });

						        DOM.find(container, '[' + Const.HOVER_PSEUDO_CLASS_ATTR + ']', function (el) {
						            _sandboxesNativeMethods2.default.removeAttribute.call(el, Const.HOVER_PSEUDO_CLASS_ATTR);

						            changed = true;
						        });

						        if (parentTag === 'head' || parentTag === 'body') {
						            if (container.innerHTML.indexOf(INIT_SCRIPT_FOR_IFRAME_TEMPLATE) !== -1) {
						                container.innerHTML = container.innerHTML.replace(INIT_SCRIPT_FOR_IFRAME_TEMPLATE, '');

						                changed = true;
						            }
						        }

						        return changed;
						    });
						}

						function processHtml(html, parentTag) {
						    if (isPageHtml(html)) return processPageHtml(html, processHtml);

						    return processHtmlInternal(html, parentTag, function (container) {
						        //NOTE: we check this condition to avoid unnecessary calling the querySelectorAll function
						        if (container.children.length === 1 && container.children[0].children && !container.children[0].children.length) _domProcessorDomProcessor2.default.processElement(container.children[0], _utilsUrl2.default.convertToProxyUrl);else {
						            var children = container.querySelectorAll('*');

						            for (var i = 0; i < children.length; i++) _domProcessorDomProcessor2.default.processElement(children[i], _utilsUrl2.default.convertToProxyUrl);
						        }

						        if (parentTag === 'head' || parentTag === 'body') container.innerHTML = INIT_SCRIPT_FOR_IFRAME_TEMPLATE + container.innerHTML;

						        return true;
						    });
						}

						function isWellFormattedHtml(html) {
						    var tagStack = [];

						    //http://www.w3.org/TR/html5/syntax.html#void-elements
						    var voidElements = ['area', 'base', 'basefont', 'br', 'col', 'embed', 'frame', 'hr', 'img', 'input', 'keygen', 'isindex', 'link', 'meta', 'param', 'source', 'track', 'wbr'];

						    //Real cases are very hard - http://www.w3.org/TR/html5/syntax.html#optional-tags
						    //Use a simplified algorithm
						    //Also not check self-closed elements for SVG(http://www.w3.org/TR/SVG/struct.html) and MathML(http://www.w3.org/wiki/MathML/Elements)
						    var selfClosedTags = ['colgroup', 'dd', 'dt', 'li', 'options', 'p', 'td', 'tfoot', 'th', 'thead', 'tr'];

						    var lastItem = function (arr) {
						        return arr[arr.length - 1];
						    };

						    var contains = function (arr, item) {
						        return arr.indexOf(item) !== -1;
						    };

						    var parseStartTag = function (tag, tagName, attributes, unary) {
						        if (!contains(voidElements, tagName)) {
						            if (!unary) {
						                tagName = tagName.toLowerCase();
						                tagStack.push(tagName);
						            }
						        }
						    };

						    var parseEndTag = function (tag, tagName) {
						        tagName = tagName.toLowerCase();

						        /*eslint-disable indent */
						        if (tagName === lastItem(tagStack)) tagStack.pop();else if (contains(selfClosedTags, lastItem(tagStack))) {
						            tagStack.pop();
						            parseEndTag(tag, tagName);
						        } else if (contains(voidElements, tagName)) throw new Error('Empty tags cannot have end-closed tag part');else throw new Error('Cannot find open tag for ' + lastItem(tagStack));
						        /*eslint-enable indent */
						    };

						    var startTagReg = /^<(\w+)([\s\S]*?)(\/?)>/;
						    var endTagReg = /^<\/(\w+)[^>]*>/;
						    var doctypeReg = /^<!doctype[^>]*>/i;

						    //http://www.w3.org/TR/html5/syntax.html#raw-text-elements
						    var rawTextElements = ['script', 'style'];

						    var BEGIN_COMMENT = '<!--';
						    var END_COMMENT = '-->';
						    var BEGIN_TAG = '<';
						    var END_TAG = '</';
						    var DOCTYPE_DECLARATION = '<!';

						    var charIndex = null;
						    var isPlanText = null;
						    var match = null;
						    var previousStepHtml = html;
						    var wellFormatted = true;

						    try {
						        while (html) {
						            isPlanText = true;

						            // Not in a script or style element
						            if (!lastItem(tagStack) || !contains(rawTextElements, lastItem(tagStack))) {
						                // html comment
						                if (html.indexOf(BEGIN_COMMENT) === 0) {
						                    charIndex = html.indexOf(END_COMMENT);
						                    html = html.substring(charIndex + 3);
						                    isPlanText = false;
						                }
						                // doctype declaration
						                else if (html.indexOf(DOCTYPE_DECLARATION) === 0) {
						                        match = html.match(doctypeReg);

						                        if (match) {
						                            html = html.substring(match[0].length);
						                            isPlanText = false;
						                        }
						                    }
						                    // end tag
						                    else if (html.indexOf(END_TAG) === 0) {
						                            match = html.match(endTagReg);

						                            if (match) {
						                                html = html.substring(match[0].length);
						                                match[0].replace(endTagReg, parseEndTag);
						                                isPlanText = false;
						                            }
						                        } else if (html.indexOf(BEGIN_TAG) === 0) {
						                            match = html.match(startTagReg);

						                            if (match) {
						                                html = html.substring(match[0].length);
						                                match[0].replace(startTagReg, parseStartTag);
						                                isPlanText = false;
						                            }
						                        }

						                if (isPlanText) {
						                    charIndex = html.indexOf(BEGIN_TAG);
						                    html = charIndex === -1 ? '' : html.substring(charIndex);
						                }
						            } else {
						                var tagContentReg = new RegExp('^([\\s\\S]*?)<\/' + lastItem(tagStack) + '[^>]*>');

						                match = html.match(tagContentReg);

						                /*eslint-disable indent */
						                if (match) {
						                    html = html.substring(match[0].length);
						                    parseEndTag('', lastItem(tagStack));
						                } else throw new Error('Cannot process rawTextElement content');
						                /*eslint-enable indent */
						            }

						            if (html === previousStepHtml) throw new Error('Html parser error');

						            previousStepHtml = html;
						        }
						        if (lastItem(tagStack)) throw new Error('There are non closed tag -' + lastItem(tagStack));
						    } catch (err) {
						        wellFormatted = false;
						    }

						    return wellFormatted;
						}
					},
					"is-jquery-object.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.default = isJQueryObj;
						// We can't use 'obj instanceof $' check because it depends on instance of the jQuery.

						function isJQueryObj(obj) {
						    return obj && !!obj.jquery;
						}

						module.exports = exports.default;
					},
					"position.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.getElementRectangle = getElementRectangle;
						exports.getOffsetPosition = getOffsetPosition;
						exports.offsetToClientCoords = offsetToClientCoords;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						var _browser = require('./browser');

						var Browser = _interopRequireWildcard(_browser);

						var _dom = require('./dom');

						var DOM = _interopRequireWildcard(_dom);

						var _style = require('./style');

						var Style = _interopRequireWildcard(_style);

						var _sandboxesNativeMethods = require('../sandboxes/native-methods');

						var _sandboxesNativeMethods2 = _interopRequireDefault(_sandboxesNativeMethods);

						function getAreaElementRectangle(el, mapContainer) {
						    var shape = el.getAttribute('shape');
						    var coords = el.getAttribute('coords');
						    var i = 0;

						    if (shape === 'default') return getElementRectangle(mapContainer);

						    if (!shape || !coords) return null;

						    coords = coords.split(',');

						    if (!coords.length) return null;

						    for (i = 0; i < coords.length; i++) {
						        coords[i] = parseInt(coords[i], 10);

						        if (typeof coords[i] !== 'number') return null;
						    }

						    var rectangle = null;

						    switch (shape) {
						        case 'rect':
						            if (coords.length === 4) {
						                rectangle = {
						                    height: coords[3] - coords[1],
						                    left: coords[0],
						                    top: coords[1],
						                    width: coords[2] - coords[0]
						                };
						            }
						            break;

						        case 'circle':
						            if (coords.length === 3) {
						                rectangle = {
						                    height: coords[2] * 2,
						                    left: coords[0] - coords[2],
						                    top: coords[1] - coords[2],
						                    width: coords[2] * 2
						                };
						            }

						            break;

						        case 'poly':
						            if (coords.length >= 6 && coords.length % 2 === 0) {
						                rectangle = {};
						                rectangle.left = rectangle.right = coords[0];
						                rectangle.top = rectangle.bottom = coords[1];

						                for (i = 2; i < coords.length; i += 2) {
						                    rectangle.left = coords[i] < rectangle.left ? coords[i] : rectangle.left;
						                    rectangle.right = coords[i] > rectangle.right ? coords[i] : rectangle.right;
						                }

						                for (i = 3; i < coords.length; i += 2) {
						                    rectangle.top = coords[i] < rectangle.top ? coords[i] : rectangle.top;
						                    rectangle.bottom = coords[i] > rectangle.bottom ? coords[i] : rectangle.bottom;
						                }

						                rectangle.height = rectangle.bottom - rectangle.top;
						                rectangle.width = rectangle.right - rectangle.left;
						            }

						            break;
						    }

						    if (rectangle) {
						        var containerOffset = getOffsetPosition(mapContainer);

						        rectangle.left += containerOffset.left;
						        rectangle.top += containerOffset.top;
						    }

						    return rectangle;
						}

						function getMapElementRectangle(el) {
						    var mapContainer = DOM.getMapContainer(el);

						    if (mapContainer) {
						        if (/^map$/i.test(el.tagName)) return getElementRectangle(mapContainer);else if (/^area$/i.test(el.tagName)) {
						            var areaElementRectangle = getAreaElementRectangle(el, mapContainer);

						            if (areaElementRectangle) return areaElementRectangle;
						        }
						    }

						    return {
						        height: 0,
						        left: 0,
						        top: 0,
						        width: 0
						    };
						}

						function getSelectChildRectangle(el) {
						    var select = DOM.getSelectParent(el);

						    if (select) {
						        var selectRectangle = getElementRectangle(select);
						        var selectBorders = Style.getBordersWidth(select);
						        var selectRightScrollbar = Style.getInnerWidth(select) === select.clientWidth ? 0 : DOM.getScrollbarSize();
						        var optionHeight = Style.getOptionHeight(select);
						        var optionRealIndex = DOM.getChildVisibleIndex(select, el);
						        var optionVisibleIndex = Math.max(optionRealIndex - Style.getScrollTop(select) / optionHeight, 0);

						        return {
						            height: optionHeight,
						            left: selectRectangle.left + selectBorders.left,
						            top: selectRectangle.top + selectBorders.top + Style.getElementPadding(select).top + optionVisibleIndex * optionHeight,

						            width: selectRectangle.width - (selectBorders.left + selectBorders.right) - selectRightScrollbar
						        };
						    }

						    return getElementRectangle(el);
						}

						function getSvgElementRelativeRectangle(el) {
						    var isSvgTextElement = DOM.matches(el, 'tspan') || DOM.matches(el, 'tref') || el.tagName && el.tagName.toLowerCase() === 'textpath';
						    var boundingClientRect = el.getBoundingClientRect();
						    var elementRect = {
						        height: !isSvgTextElement ? boundingClientRect.height : el.offsetHeight,
						        left: boundingClientRect.left + (document.body.scrollLeft || document.documentElement.scrollLeft),
						        top: boundingClientRect.top + (document.body.scrollTop || document.documentElement.scrollTop),
						        width: !isSvgTextElement ? boundingClientRect.width : el.offsetWidth
						    };

						    if (isSvgTextElement) {
						        var offsetParent = Style.getOffsetParent(el);
						        var elOffset = Style.getOffset(el);
						        var offsetParentOffset = Style.getOffset(offsetParent);
						        var offsetParentIsBody = DOM.matches(offsetParent, 'body');

						        return {
						            height: elementRect.height || boundingClientRect.height,
						            left: offsetParentIsBody ? el.offsetLeft || elOffset.left : offsetParentOffset.left + el.offsetLeft,
						            top: offsetParentIsBody ? el.offsetTop || elOffset.top : offsetParentOffset.top + el.offsetTop,
						            width: elementRect.width || boundingClientRect.width
						        };
						    }

						    if (Browser.isMozilla || Browser.isIE) return elementRect;

						    var strokeWidth = _sandboxesNativeMethods2.default.getAttribute.call(el, 'stroke-width') || Style.get(el, 'stroke-width');

						    //NOTE: we think that 'stroke-width' attribute can only be set in pixels
						    strokeWidth = strokeWidth ? +strokeWidth.replace(/px|em|ex|pt|pc|cm|mm|in/, '') : 1;

						    if (strokeWidth && +strokeWidth % 2 !== 0) strokeWidth = +strokeWidth + 1;

						    if ((DOM.matches(el, 'line') || DOM.matches(el, 'polyline') || DOM.matches(el, 'polygon') || DOM.matches(el, 'path')) && (!elementRect.width || !elementRect.height)) {
						        if (!elementRect.width && elementRect.height) {
						            elementRect.left -= strokeWidth / 2;
						            elementRect.width = strokeWidth;
						        } else if (elementRect.width && !elementRect.height) {
						            elementRect.height = strokeWidth;
						            elementRect.top -= strokeWidth / 2;
						        }
						    } else {
						        if (DOM.matches(el, 'polygon')) {
						            elementRect.height += 2 * strokeWidth;
						            elementRect.left -= strokeWidth;
						            elementRect.top -= strokeWidth;
						            elementRect.width += 2 * strokeWidth;
						        }

						        elementRect.height += strokeWidth;
						        elementRect.left -= strokeWidth / 2;
						        elementRect.top -= strokeWidth / 2;
						        elementRect.width += strokeWidth;
						    }

						    return elementRect;
						}

						function getElementRectangle(el) {
						    var rectangle = {};

						    if (DOM.isMapElement(el)) rectangle = getMapElementRectangle(el);else if (Style.isVisibleChild(el)) rectangle = getSelectChildRectangle(el);else {
						        var elementOffset = getOffsetPosition(el);
						        var relativeRectangle = DOM.isSvgElement(el) ? getSvgElementRelativeRectangle(el) : el.getBoundingClientRect();

						        rectangle = {
						            height: relativeRectangle.height,
						            left: elementOffset.left,
						            top: elementOffset.top,
						            width: relativeRectangle.width
						        };
						    }

						    rectangle.height = Math.round(rectangle.height);
						    rectangle.left = Math.round(rectangle.left);
						    rectangle.top = Math.round(rectangle.top);
						    rectangle.width = Math.round(rectangle.width);

						    return rectangle;
						}

						function getOffsetPosition(el) {
						    if (DOM.isMapElement(el)) {
						        var rectangle = getMapElementRectangle(el);

						        return {
						            left: rectangle.left,
						            top: rectangle.top
						        };
						    }

						    var doc = DOM.findDocument(el);
						    var isInIFrame = DOM.isElementInIframe(el, doc);
						    var currentIFrame = isInIFrame ? DOM.getIFrameByElement(doc) : null;
						    var offsetPosition = doc === el ? Style.getOffset(doc.documentElement) : Style.getOffset(el);
						    var relativeRectangle = null;

						    // NOTE: jquery .offset() function doesn't take body's border into account (except IE7)
						    // http://bugs.jquery.com/ticket/7948

						    //NOTE: Sometimes in IE method getElementFromPoint returns cross-domain iframe's documentElement, but we can't get his body
						    var borders = doc.body ? Style.getBordersWidth(doc.body) : {
						        left: 0,
						        top: 0
						    };

						    if (!isInIFrame || !currentIFrame) {
						        var isSvg = DOM.isSvgElement(el);

						        relativeRectangle = isSvg ? getSvgElementRelativeRectangle(el) : null;

						        return {
						            left: Math.round(isSvg ? relativeRectangle.left + borders.left : offsetPosition.left + borders.left),
						            top: Math.round(isSvg ? relativeRectangle.top + borders.top : offsetPosition.top + borders.top)
						        };
						    }

						    var iframeBorders = Style.getBordersWidth(currentIFrame);

						    borders.left += iframeBorders.left;
						    borders.top += iframeBorders.top;

						    var iframeOffset = getOffsetPosition(currentIFrame);
						    var iframePadding = Style.getElementPadding(currentIFrame);
						    var clientPosition = null;

						    if (DOM.isSvgElement(el)) {
						        relativeRectangle = getSvgElementRelativeRectangle(el);

						        clientPosition = {
						            x: relativeRectangle.left - (document.body.scrollLeft || document.documentElement.scrollLeft) + borders.left,
						            y: relativeRectangle.top - (document.body.scrollTop || document.documentElement.scrollTop) + borders.top
						        };
						    } else {
						        clientPosition = offsetToClientCoords({
						            x: offsetPosition.left + borders.left,
						            y: offsetPosition.top + borders.top
						        }, doc);
						    }

						    return {
						        left: Math.round(iframeOffset.left + clientPosition.x + iframePadding.left),
						        top: Math.round(iframeOffset.top + clientPosition.y + iframePadding.top)
						    };
						}

						function offsetToClientCoords(coords, currentDocument) {
						    var doc = currentDocument || document;

						    return {
						        x: coords.x - Style.getScrollLeft(doc),
						        y: coords.y - Style.getScrollTop(doc)
						    };
						}
					},
					"style.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.get = get;
						exports.set = set;
						exports.getBordersWidth = getBordersWidth;
						exports.getComputedStyle = getComputedStyle;
						exports.getElementMargin = getElementMargin;
						exports.getElementPadding = getElementPadding;
						exports.getElementScroll = getElementScroll;
						exports.getHeight = getHeight;
						exports.getInnerWidth = getInnerWidth;
						exports.getOptionHeight = getOptionHeight;
						exports.getSelectElementSize = getSelectElementSize;
						exports.isVisibleChild = isVisibleChild;
						exports.getScrollLeft = getScrollLeft;
						exports.getScrollTop = getScrollTop;
						exports.setScrollLeft = setScrollLeft;
						exports.setScrollTop = setScrollTop;
						exports.getOffsetParent = getOffsetParent;
						exports.getOffset = getOffset;

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						var _browser = require('./browser');

						var Browser = _interopRequireWildcard(_browser);

						var _dom = require('./dom');

						var DOM = _interopRequireWildcard(_dom);

						//NOTE: for Chrome
						var MIN_SELECT_SIZE_VALUE = 4;

						function getIntValue(value) {
						    value = value || '';

						    var parsedValue = parseInt(value.replace('px', ''), 10);

						    return isNaN(parsedValue) ? 0 : parsedValue;
						}

						function get(el, property) {
						    el = el.documentElement || el;

						    var computedStyle = getComputedStyle(el);

						    return computedStyle[property];
						}

						function set(el, property, value) {
						    el = el.documentElement || el;
						    el.style[property] = value;
						}

						function getBordersWidth(el) {
						    return {
						        bottom: getIntValue(get(el, 'borderBottomWidth')),
						        left: getIntValue(get(el, 'borderLeftWidth')),
						        right: getIntValue(get(el, 'borderRightWidth')),
						        top: getIntValue(get(el, 'borderTopWidth'))
						    };
						}

						function getComputedStyle(el, doc) {
						    doc = doc || document;

						    return doc.defaultView.getComputedStyle(el, null);
						}

						function getElementMargin(el) {
						    return {
						        bottom: getIntValue(get(el, 'marginBottom')),
						        left: getIntValue(get(el, 'marginLeft')),
						        right: getIntValue(get(el, 'marginRight')),
						        top: getIntValue(get(el, 'marginTop'))
						    };
						}

						function getElementPadding(el) {
						    return {
						        bottom: getIntValue(get(el, 'paddingBottom')),
						        left: getIntValue(get(el, 'paddingLeft')),
						        right: getIntValue(get(el, 'paddingRight')),
						        top: getIntValue(get(el, 'paddingTop'))
						    };
						}

						function getElementScroll(el) {
						    var isHtmlElement = /html/i.test(el.tagName);
						    var currentWindow = window;

						    if (isHtmlElement && DOM.isElementInIframe(el)) {
						        var currentIFrame = DOM.getIFrameByElement(el);

						        if (currentIFrame) currentWindow = currentIFrame.contentWindow;
						    }

						    var targetEl = isHtmlElement ? currentWindow : el;

						    return {
						        left: getScrollLeft(targetEl),
						        top: getScrollTop(targetEl)
						    };
						}

						function getHeight(el) {
						    if (!el) return null;

						    if (el.nodeType === 9) {
						        var doc = el.documentElement;
						        var clientProp = 'clientHeight';
						        var scrollProp = 'scrollHeight';
						        var offsetProp = 'offsetHeight';

						        if (doc[clientProp] >= doc[scrollProp]) return doc[clientProp];

						        return Math.max(el.body[scrollProp], doc[scrollProp], el.body[offsetProp], doc[offsetProp]);
						    }

						    var value = el.offsetHeight;

						    value -= getIntValue(get(el, 'paddingTop'));
						    value -= getIntValue(get(el, 'paddingBottom'));
						    value -= getIntValue(get(el, 'borderTopWidth'));
						    value -= getIntValue(get(el, 'borderBottomWidth'));

						    return value;
						}

						function getInnerWidth(el) {
						    if (!el) return null;

						    if (DOM.isWindowInstance(el)) return el.document.documentElement.clientWidth;

						    if (DOM.isDocumentInstance(el)) return el.documentElement.clientWidth;

						    var value = el.offsetWidth;

						    value -= getIntValue(get(el, 'borderLeftWidth'));
						    value -= getIntValue(get(el, 'borderRightWidth'));

						    return value;
						}

						function getOptionHeight(select) {
						    var realSizeValue = getSelectElementSize(select);
						    var selectPadding = getElementPadding(select);
						    var selectScrollHeight = select.scrollHeight - (selectPadding.top + selectPadding.bottom);
						    var childrenCount = DOM.getSelectVisibleChildren(select).length;

						    if (realSizeValue === 1) return getHeight(select);

						    return Browser.isIE && realSizeValue > childrenCount ? Math.round(selectScrollHeight / childrenCount) : Math.round(selectScrollHeight / Math.max(childrenCount, realSizeValue));
						}

						function getSelectElementSize(select) {
						    var sizeAttr = select.getAttribute('size');
						    var multipleAttr = select.getAttribute('multiple');
						    var size = !sizeAttr ? 1 : parseInt(sizeAttr, 10);

						    if (multipleAttr && (!sizeAttr || size < 1)) size = MIN_SELECT_SIZE_VALUE;

						    return size;
						}

						function isVisibleChild(el) {
						    var select = DOM.getSelectParent(el);
						    var tagName = el.tagName.toLowerCase();

						    return select && select.tagName.toLowerCase() === 'select' && getSelectElementSize(select) > 1 && (tagName === 'option' || tagName === 'optgroup') && (
						    //NOTE: Mozilla does not display group without label and with empty label
						    !Browser.isMozilla || el.label);
						}

						function getScrollLeft(el) {
						    if (!el) return null;

						    if (DOM.isWindowInstance(el)) return el.pageXOffset;

						    if (DOM.isDocumentInstance(el)) return el.defaultView.pageXOffset;

						    return el.scrollLeft;
						}

						function getScrollTop(el) {
						    if (!el) return null;

						    if (DOM.isWindowInstance(el)) return el.pageYOffset;

						    if (DOM.isDocumentInstance(el)) return el.defaultView.pageYOffset;

						    return el.scrollTop;
						}

						function setScrollLeft(el, value) {
						    if (el) {
						        var win = DOM.findDocument(el).defaultView;
						        var scrollTop = getScrollTop(el);

						        win.scrollTo(value, scrollTop);
						    }
						}

						function setScrollTop(el, value) {
						    if (el) {
						        var win = DOM.findDocument(el).defaultView;
						        var scrollLeft = getScrollLeft(el);

						        win.scrollTo(scrollLeft, value);
						    }
						}

						function getOffsetParent(el) {
						    if (el) {
						        var offsetParent = el.offsetParent || document.body;

						        while (offsetParent && (!/^(?:body|html)$/i.test(offsetParent.nodeName) && get(offsetParent, 'position') === 'static')) {
						            offsetParent = offsetParent.offsetParent;
						        }

						        return offsetParent;
						    }
						}

						function getOffset(el) {
						    if (!el || DOM.isWindowInstance(el) || DOM.isDocumentInstance(el)) return null;

						    var clientRect = el.getBoundingClientRect();

						    //Detached node or documentElement
						    var doc = el.ownerDocument;
						    var docElement = doc.documentElement;

						    if (!docElement.contains(el) || el === docElement) {
						        return {
						            top: clientRect.top,
						            left: clientRect.left
						        };
						    }

						    var win = doc.defaultView;
						    var clientTop = docElement.clientTop || doc.body.clientTop || 0;
						    var clientLeft = docElement.clientLeft || doc.body.clientLeft || 0;
						    var scrollTop = win.pageYOffset || docElement.scrollTop || doc.body.scrollTop;
						    var scrollLeft = win.pageXOffset || docElement.scrollLeft || doc.body.scrollLeft;

						    clientRect = el.getBoundingClientRect();

						    return {
						        top: clientRect.top + scrollTop - clientTop,
						        left: clientRect.left + scrollLeft - clientLeft
						    };
						}
					},
					"url.js": function (exports, module, require) {
						exports.__esModule = true;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						var _sandboxesNativeMethods = require('../sandboxes/native-methods');

						var _sandboxesNativeMethods2 = _interopRequireDefault(_sandboxesNativeMethods);

						var _const = require('../../const');

						var _const2 = _interopRequireDefault(_const);

						var _utilsUrl = require('../../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var _settings = require('../settings');

						var _settings2 = _interopRequireDefault(_settings);

						var UrlUtil = {};

						//URL processing funcs
						UrlUtil.DOCUMENT_URL_RESOLVER = 'doc_url_resolver_8ff20d5e';
						UrlUtil.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = _utilsUrl2.default.REQUEST_DESCRIPTOR_VALUES_SEPARATOR;

						UrlUtil.IFRAME = _utilsUrl2.default.IFRAME;
						UrlUtil.SCRIPT = _utilsUrl2.default.SCRIPT;

						document[UrlUtil.DOCUMENT_URL_RESOLVER] = document.createElement('a');

						function getResolver(doc) {
						    // IE clean up document after document.open call
						    if (!doc[UrlUtil.DOCUMENT_URL_RESOLVER]) doc[UrlUtil.DOCUMENT_URL_RESOLVER] = doc.createElement('a');

						    return doc[UrlUtil.DOCUMENT_URL_RESOLVER];
						}

						UrlUtil.getProxyUrl = function (url, proxyHostname, proxyPort, jobUid, jobOwnerToken, resourceType) {
						    if (!UrlUtil.isSupportedProtocol(url)) return url;

						    // NOTE: resolve relative URLs
						    url = UrlUtil.resolveUrl(url);

						    // NOTE: if we have a relative URL without slash (e.g. 'img123') resolver will keep
						    // original proxy information, so we can return such URL as is. TODO: implement is proxy URL func
						    var parsedAsProxy = _utilsUrl2.default.parseProxyUrl(url);
						    var isValidProxyUrl = !!parsedAsProxy;

						    if (isValidProxyUrl) {
						        if (resourceType && parsedAsProxy.resourceType === resourceType) return url;

						        // NOTE: we need to change proxy url resource type
						        var destUrl = _utilsUrl2.default.formatUrl(parsedAsProxy.originResourceInfo);

						        return UrlUtil.getProxyUrl(destUrl, proxyHostname, proxyPort, jobUid, jobOwnerToken, resourceType);
						    }

						    proxyHostname = proxyHostname || location.hostname;
						    proxyPort = proxyPort || location.port.toString();
						    jobUid = jobUid || _settings2.default.get().JOB_UID;
						    jobOwnerToken = jobOwnerToken || _settings2.default.get().JOB_OWNER_TOKEN;

						    var parsedUrl = _utilsUrl2.default.parseUrl(url);

						    // NOTE: seems like we've had a relative URL with leading slash or dots,
						    // so our proxy info path part was removed by resolver and we have an origin URL,
						    // but with incorrect host and protocol.
						    if (parsedUrl.protocol === 'http:' && parsedUrl.hostname === proxyHostname && parsedUrl.port === proxyPort) {
						        var parsedOriginLocation = UrlUtil.OriginLocation.getParsed();

						        parsedUrl.protocol = parsedOriginLocation.protocol;
						        parsedUrl.host = parsedOriginLocation.host;
						        parsedUrl.hostname = parsedOriginLocation.hostname;
						        parsedUrl.port = parsedOriginLocation.port || '';

						        url = _utilsUrl2.default.formatUrl(parsedUrl);
						    }

						    return _utilsUrl2.default.getProxyUrl(url, proxyHostname, proxyPort, jobUid, jobOwnerToken, resourceType);
						};

						UrlUtil.getCrossDomainIframeProxyUrl = function (url) {
						    return UrlUtil.getProxyUrl(url, null, _settings2.default.get().CROSS_DOMAIN_PROXY_PORT, null, null, UrlUtil.IFRAME);
						};

						UrlUtil.getCrossDomainProxyUrl = function () {
						    return location.protocol + '//' + location.hostname + ':' + _settings2.default.get().CROSS_DOMAIN_PROXY_PORT + '/';
						};

						UrlUtil.resolveUrl = function (url, doc) {
						    url = _utilsUrl2.default.prepareUrl(url);

						    if (url && url.indexOf('//') === 0) url = UrlUtil.OriginLocation.getParsed().protocol + url;

						    var urlResolver = getResolver(doc || document);

						    if (url === null) urlResolver.removeAttribute('href');else {
						        urlResolver.href = url;

						        //NOTE: it looks like a chrome bug: in nested iframe without src (when iframe is placed in another iframe) you
						        //cannot set relative link href for some time while the iframe loading is not completed. So, we'll do it with
						        //parent's urlResolver
						        //In Safari presents equal behaviour,
						        // but urlResolver.href has relative url value
						        var needUseParentResolver = url && isIFrameWithoutSrc && window.parent && window.parent.document && (!urlResolver.href || urlResolver.href.indexOf('/') === 0);

						        if (needUseParentResolver) return UrlUtil.resolveUrl(url, window.parent.document);
						    }

						    return urlResolver.href;
						};

						UrlUtil.resolveUrlAsOrigin = function (url) {
						    return _utilsUrl2.default.resolveUrlAsOrigin(url, UrlUtil.getProxyUrl);
						};

						UrlUtil.formatUrl = function (parsedUrl) {
						    return _utilsUrl2.default.formatUrl(parsedUrl);
						};

						UrlUtil.parseProxyUrl = function (proxyUrl) {
						    return _utilsUrl2.default.parseProxyUrl(proxyUrl);
						};

						UrlUtil.parseUrl = function (url) {
						    return _utilsUrl2.default.parseUrl(url);
						};

						UrlUtil.convertToProxyUrl = function (url, resourceType) {
						    return UrlUtil.getProxyUrl(url, null, null, null, null, resourceType);
						};

						UrlUtil.changeOriginUrlPart = function (proxyUrl, prop, value, resourceType) {
						    var parsed = _utilsUrl2.default.parseProxyUrl(proxyUrl);

						    if (parsed) {
						        var resolver = getResolver(document);
						        var job = parsed.jobInfo;
						        var proxy = parsed.proxy;

						        resolver.href = parsed.originUrl;
						        resolver[prop] = value;

						        return UrlUtil.getProxyUrl(resolver.href, proxy.hostname, proxy.port, job.uid, job.ownerToken, resourceType);
						    }

						    return proxyUrl;
						};

						UrlUtil.isSubDomain = function (domain, subDomain) {
						    return _utilsUrl2.default.isSubDomain(domain, subDomain);
						};

						UrlUtil.sameOriginCheck = function (location, checkedUrl) {
						    if (checkedUrl) checkedUrl = UrlUtil.resolveUrl(checkedUrl);

						    return _utilsUrl2.default.sameOriginCheck(location, checkedUrl);
						};

						UrlUtil.isSupportedProtocol = function (url) {
						    return _utilsUrl2.default.isSupportedProtocol(url);
						};

						UrlUtil.isIframeWithoutSrc = function (iframe) {
						    var iFrameLocation = UrlUtil.getIframeLocation(iframe);
						    var iFrameSrcLocation = iFrameLocation.srcLocation;
						    var iFrameDocumentLocation = iFrameLocation.documentLocation;

						    if (iFrameDocumentLocation === null) // is a cross-domain iframe
						        return false;

						    var window = iframe[_const2.default.DOM_SANDBOX_PROCESSED_CONTEXT] || iframe.contentWindow.parent;
						    var windowLocation = window.location.toString();
						    var parsedWindowLocation = _utilsUrl2.default.parseProxyUrl(windowLocation);

						    if (iFrameDocumentLocation === (parsedWindowLocation ? parsedWindowLocation.originUrl : windowLocation) || iFrameSrcLocation === (parsedWindowLocation ? parsedWindowLocation.originUrl : windowLocation)) return true;

						    var iFrameDocumentLocationHaveSupportedProtocol = UrlUtil.isSupportedProtocol(iFrameDocumentLocation);

						    //NOTE: when an iFrame have empty src attribute (<iframe src></iframe>) the iframe.src property doesn't empty but it has different values
						    //in different browsers. Its document location is 'about:blank'. Therefore we should check the src attribute.
						    if (!iFrameDocumentLocationHaveSupportedProtocol && !(iframe.attributes['src'] && iframe.attributes['src'].value)) return true;

						    //NOTE: is Chrome an iFrame with src has documentLocation 'about:blank' when it is just created. So, we should check
						    // srcLocation in this case.
						    if (iFrameSrcLocation && UrlUtil.isSupportedProtocol(iFrameSrcLocation)) return false;

						    return !iFrameDocumentLocationHaveSupportedProtocol;
						};

						UrlUtil.getIframeLocation = function (iframe) {
						    var documentLocation = null;

						    try {
						        documentLocation = iframe.contentDocument.location.href;
						    } catch (e) {
						        documentLocation = null;
						    }

						    var srcLocation = _sandboxesNativeMethods2.default.getAttribute.call(iframe, 'src' + _const2.default.DOM_SANDBOX_STORED_ATTR_POSTFIX) || _sandboxesNativeMethods2.default.getAttribute.call(iframe, 'src') || iframe.src;

						    var parsedProxyDocumentLocation = documentLocation && UrlUtil.isSupportedProtocol(documentLocation) && _utilsUrl2.default.parseProxyUrl(documentLocation);
						    var parsedProxySrcLocation = srcLocation && UrlUtil.isSupportedProtocol(srcLocation) && _utilsUrl2.default.parseProxyUrl(srcLocation);

						    return {
						        documentLocation: parsedProxyDocumentLocation ? parsedProxyDocumentLocation.originUrl : documentLocation,
						        srcLocation: parsedProxySrcLocation ? parsedProxySrcLocation.originUrl : srcLocation
						    };
						};

						function getLocation() {
						    try {
						        // NOTE: fallback to the owner page's URL if we are in the iFrame without src
						        if (window.frameElement && UrlUtil.isIframeWithoutSrc(window.frameElement)) return _settings2.default.get().REFERER;
						    }
						    /*eslint-disable no-empty */
						    catch (e) {}
						    // NOTE: Cross-domain iframe

						    /*eslint-enable no-empty */

						    return window.location.toString();
						}

						UrlUtil.OriginLocation = {
						    get: function () {
						        var location = getLocation();

						        return _utilsUrl2.default.parseProxyUrl(location).originUrl;
						    },

						    withHash: function (hash) {
						        var location = this.get();

						        // NOTE: remove previous hash if we have one
						        location = location.replace(/(#.*)$/, '');

						        return location + hash;
						    },

						    getCookiePathPrefix: function () {
						        var parsedLocation = _utilsUrl2.default.parseProxyUrl(getLocation());

						        return parsedLocation.partAfterHost.replace(parsedLocation.originResourceInfo.partAfterHost, '');
						    },

						    getParsed: function () {
						        var resolver = getResolver(document);
						        var origin = this.get();
						        var parsedOrigin = _utilsUrl2.default.parseUrl(origin);

						        // NOTE: IE "browser" adds default port for the https protocol while resolving
						        resolver.href = this.get();

						        // NOTE: IE ignores first '/' symbol in the pathname
						        var pathname = resolver.pathname.indexOf('/') === 0 ? resolver.pathname : '/' + resolver.pathname;

						        //TODO describe default ports logic
						        return {
						            protocol: resolver.protocol,
						            // NOTE: remove default port
						            port: parsedOrigin.port ? resolver.port : '',
						            hostname: resolver.hostname,
						            // NOTE: remove default port form the host
						            host: parsedOrigin.port ? resolver.host : resolver.host.replace(/:\d+$/, ''),
						            pathname: pathname,
						            hash: resolver.hash,
						            search: resolver.search
						        };
						    }
						};

						exports.default = UrlUtil;
						module.exports = exports.default;
					}
				}
			},
			"const.js": function (exports, module, require) {
				exports.__esModule = true;
				// -------------------------------------------------------------
				// WARNING: this file is used by both the client and the server.
				// Do not use any browser or node-specific API!
				// -------------------------------------------------------------

				var Const = {};

				Const.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME = 'tc_odm_e01a2ff5';
				Const.DOM_SANDBOX_PROCESSED_CONTEXT = 'tc-spc-c1208da2';
				Const.DOM_SANDBOX_STORED_ATTR_POSTFIX = '_e01a2f_stored';
				Const.EVENT_SANDBOX_WHICH_PROPERTY_WRAPPER = 'tc-e01a2f-which';

				Const.IS_STYLESHEET_PROCESSED_COMMENT = '/* stylesheet processed via hammerhead */';

				Const.UPLOAD_SANDBOX_HIDDEN_INPUT_NAME = 'upload-89fc3-info';

				Const.HOVER_PSEUDO_CLASS_ATTR = 'data-1b082a6cec-hover';

				Const.XHR_CORS_SUPPORTED_FLAG = 0x10;
				Const.XHR_REQUEST_MARKER_HEADER = 'x-tc-xm-cd46977f';
				Const.XHR_WITH_CREDENTIALS_FLAG = 0x01;

				Const.PROPERTY_PREFIX = 'tc-1b082a6cec-51966-';

				Const.SHADOW_UI_CLASSNAME_POSTFIX = '-TC2b9a6d';
				Const.SHADOW_UI_SCRIPT_CLASSNAME = 'script' + Const.SHADOW_UI_CLASSNAME_POSTFIX;
				Const.SHADOW_UI_STYLESHEET_CLASSNAME = 'ui-stylesheet';
				Const.SHADOW_UI_STYLESHEET_FULL_CLASSNAME = Const.SHADOW_UI_STYLESHEET_CLASSNAME + Const.SHADOW_UI_CLASSNAME_POSTFIX;

				exports.default = Const;
				module.exports = exports.default;
			},
			"processing": {
				"dom": {
					"base-dom-adapter.js": function (exports, module, require) {
						exports.__esModule = true;

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						var BaseDomAdapter = (function () {
						    function BaseDomAdapter() {
						        _classCallCheck(this, BaseDomAdapter);

						        this.EVENTS = ['onblur', 'onchange', 'onclick', 'oncontextmenu', 'oncopy', 'oncut', 'ondblclick', 'onerror', 'onfocus', 'onfocusin', 'onfocusout', 'onhashchange', 'onkeydown', 'onkeypress', 'onkeyup', 'onload', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onpaste', 'onreset', 'onresize', 'onscroll', 'onselect', 'onsubmit', 'ontextinput', 'onunload', 'onwheel', 'onpointerdown', 'onpoi nterup', 'onpointercancel', 'onpointermove', 'onpointerover', 'onpointerout', 'onpointerenter', 'onpointerleave', 'ongotpointercapture', 'onlostpointercapture', 'onmspointerdown', 'onmspointerup', 'onmspointercancel', 'onmspointermove', 'onmspointerover', 'onmspointerout', 'onmspointerenter', 'onmspointerleave', 'onmsgotpointercapture', 'onmslostpointercapture'];

						        this.IFRAME_FLAG_TAGS = ['a', 'form'];
						    }

						    BaseDomAdapter.prototype.getAttr = function getAttr() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.hasAttr = function hasAttr() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.hasEventHandler = function hasEventHandler() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.getTagName = function getTagName() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.setAttr = function setAttr() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.setScriptContent = function setScriptContent() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.getScriptContent = function getScriptContent() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.getStyleContent = function getStyleContent() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.setStyleContent = function setStyleContent() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.getElementForSelectorCheck = function getElementForSelectorCheck() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.needToProcessUrl = function needToProcessUrl() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.attachEventEmitter = function attachEventEmitter() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.hasIFrameParent = function hasIFrameParent() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.getCrossDomainPort = function getCrossDomainPort() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.getProxyUrl = function getProxyUrl() {
						        throw new Error('Not implemented');
						    };

						    BaseDomAdapter.prototype.isTopParentIFrame = function isTopParentIFrame() {
						        throw new Error('Not implemented');
						    };

						    return BaseDomAdapter;
						})();

						exports.default = BaseDomAdapter;
						module.exports = exports.default;
					},
					"index.js": function (exports, module, require) {
						exports.__esModule = true;

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						var _utilsUrl = require('../../utils/url');

						var _utilsUrl2 = _interopRequireDefault(_utilsUrl);

						var _const = require('../../const');

						var _const2 = _interopRequireDefault(_const);

						var _jsIndex = require('../js/index');

						var _jsIndex2 = _interopRequireDefault(_jsIndex);

						var _processingScript = require('../../processing/script');

						var _processingScript2 = _interopRequireDefault(_processingScript);

						var _processingStyle = require('../../processing/style');

						var _processingStyle2 = _interopRequireDefault(_processingStyle);

						var CDATA_REG_EX = /^(\s)*\/\/<!\[CDATA\[([\s\S]*)\/\/\]\]>(\s)*$/;
						// Ignore '//:0/' url (http://www.myntra.com/)
						var EMPTY_URL_REG_EX = /^(\w+:)?\/\/\:0/;
						var HTML_COMMENT_POSTFIX_REG_EX = /(\/\/[^\n]*|\n\s*)-->[^\n]*([\n\s]*)?$/;
						var HTML_COMMENT_PREFIX_REG_EX = /^(\s)*<!--[^\n]*\n/;
						var HTML_COMMENT_SIMPLE_POSTFIX_REG_EX = /-->\s*$/;
						var HTML_STRING_REG_EX = /^\s*('|")\s*(<[\s\S]+>)\s*('|")\s*$/;
						var JAVASCRIPT_PROTOCOL_REG_EX = /^\s*javascript\s*:/i;
						var URL_ATTRS = ['href', 'src', 'action', 'manifest', 'data'];

						var URL_ATTR_TAGS = {
						    href: ['a', 'link', 'image', 'area', 'base'],
						    src: ['img', 'embed', 'script', 'source', 'video', 'audio', 'input', 'frame', 'iframe'],
						    action: ['form'],
						    manifest: ['html'],
						    data: ['object']
						};

						var TARGET_ATTR_TAGS = {
						    a: true,
						    form: true,
						    area: true,
						    base: true
						};

						var HTML_PROCESSING_REQUIRED = 'HTML_PROCESSING_REQUIRED';

						var DomProcessor = (function () {
						    function DomProcessor(adapter) {
						        _classCallCheck(this, DomProcessor);

						        this.adapter = adapter;
						        this.adapter.attachEventEmitter(this);

						        this.HTML_STRING_REG_EX = HTML_STRING_REG_EX;
						        this.JAVASCRIPT_PROTOCOL_REG_EX = JAVASCRIPT_PROTOCOL_REG_EX;
						        this.TARGET_ATTR_TAGS = TARGET_ATTR_TAGS;
						        this.URL_ATTR_TAGS = URL_ATTR_TAGS;
						        this.URL_ATTRS = URL_ATTRS;
						        this.HTML_PROCESSING_REQUIRED = HTML_PROCESSING_REQUIRED;

						        this.EVENTS = this.adapter.EVENTS;

						        this.elementProcessorPatterns = this._createProcessorPatterns(this.adapter);
						    }

						    DomProcessor.prototype._createProcessorPatterns = function _createProcessorPatterns(adapter) {
						        var selectors = {
						            HAS_HREF_ATTR: function (el) {
						                var tagName = adapter.getTagName(el).toLowerCase();

						                return URL_ATTR_TAGS.href.indexOf(tagName) !== -1;
						            },

						            HAS_SRC_ATTR: function (el) {
						                var tagName = adapter.getTagName(el).toLowerCase();

						                return URL_ATTR_TAGS.src.indexOf(tagName) !== -1;
						            },

						            HAS_ACTION_ATTR: function (el) {
						                var tagName = adapter.getTagName(el).toLowerCase();

						                return URL_ATTR_TAGS.action.indexOf(tagName) !== -1;
						            },

						            HAS_MANIFEST_ATTR: function (el) {
						                var tagName = adapter.getTagName(el).toLowerCase();

						                return URL_ATTR_TAGS.manifest.indexOf(tagName) !== -1;
						            },

						            HAS_DATA_ATTR: function (el) {
						                var tagName = adapter.getTagName(el).toLowerCase();

						                return URL_ATTR_TAGS.data.indexOf(tagName) !== -1;
						            },

						            HTTP_EQUIV_META: function (el) {
						                var tagName = adapter.getTagName(el).toLowerCase();

						                return tagName === 'meta' && adapter.hasAttr(el, 'http-equiv');
						            },

						            ALL: function () {
						                return true;
						            },

						            IS_SCRIPT: function (el) {
						                return adapter.getTagName(el).toLowerCase() === 'script';
						            },

						            IS_INPUT: function (el) {
						                return adapter.getTagName(el).toLowerCase() === 'input';
						            },

						            IS_STYLE: function (el) {
						                return adapter.getTagName(el).toLowerCase() === 'style';
						            },

						            HAS_EVENT_HANDLER: function (el) {
						                return adapter.hasEventHandler(el);
						            },

						            IS_SANDBOXED_IFRAME: function (el) {
						                return adapter.getTagName(el).toLowerCase() === 'iframe' && adapter.hasAttr(el, 'sandbox');
						            }
						        };

						        return [{
						            selector: selectors.HAS_HREF_ATTR,
						            urlAttr: 'href',
						            elementProcessors: [this._processTargetBlank, this._processUrlAttrs, this._processUrlJsAttr]
						        }, {
						            selector: selectors.HAS_SRC_ATTR,
						            urlAttr: 'src',
						            elementProcessors: [this._processTargetBlank, this._processUrlAttrs, this._processUrlJsAttr]
						        }, {
						            selector: selectors.HAS_ACTION_ATTR,
						            urlAttr: 'action',
						            elementProcessors: [this._processTargetBlank, this._processUrlAttrs, this._processUrlJsAttr]
						        }, {
						            selector: selectors.HAS_MANIFEST_ATTR,
						            urlAttr: 'manifest',
						            elementProcessors: [this._processUrlAttrs, this._processUrlJsAttr]
						        }, {
						            selector: selectors.HAS_DATA_ATTR,
						            urlAttr: 'data',
						            elementProcessors: [this._processUrlAttrs, this._processUrlJsAttr]
						        }, {
						            selector: selectors.HTTP_EQUIV_META,
						            urlAttr: 'content',
						            elementProcessors: [this._processMetaElement]
						        }, { selector: selectors.ALL, elementProcessors: [this._processStyleAttr] }, { selector: selectors.IS_SCRIPT, elementProcessors: [this._processScriptElement] }, { selector: selectors.IS_STYLE, elementProcessors: [this._processStylesheetElement] }, { selector: selectors.IS_INPUT, elementProcessors: [this._processAutoComplete] }, { selector: selectors.HAS_EVENT_HANDLER, elementProcessors: [this._processEvtAttr] }, { selector: selectors.IS_SANDBOXED_IFRAME, elementProcessors: [this._processSandboxedIframe] }];
						    };

						    // API

						    DomProcessor.prototype.processPage = function processPage($, urlReplacer) {
						        var $base = $('base');
						        var baseUrl = $base.length ? this.adapter.getAttr($base[0], 'href') : '';
						        var domProc = this;

						        var replacer = function (resourceUrl, resourceType) {
						            return urlReplacer(resourceUrl, resourceType, baseUrl);
						        };
						        var $all = $('*');

						        for (var i = 0; i < this.elementProcessorPatterns.length; i++) {
						            var pattern = this.elementProcessorPatterns[i];

						            /*eslint-disable no-loop-func*/
						            $all.filter(function () {
						                return pattern.selector(this);
						            }).each(function () {
						                if (!this[_const2.default.ELEMENT_PROCESSED_FLAG]) {
						                    for (var j = 0; j < pattern.elementProcessors.length; j++) pattern.elementProcessors[j].call(domProc, this, replacer, pattern);
						                }
						            });
						            /*eslint-enable no-loop-func*/
						        }
						    };

						    DomProcessor.prototype.processElement = function processElement(el, urlReplacer) {
						        // NOTE: When the 'script' element created it is not executed. It occurs after the element is appended to a
						        // document. But in IE 9 only, if you get script's 'document', 'children' or 'all' property, the script is executed
						        // at the same time (before it is appended to a document). JQuery element's 'is' function implementation gets
						        // 'document' property and the script is executed too early. Therefore we should check clone element instead it. (B237231)
						        var elementForSelectorCheck = this.adapter.getElementForSelectorCheck(el);

						        for (var i = 0; i < this.elementProcessorPatterns.length; i++) {
						            var pattern = this.elementProcessorPatterns[i];

						            if (pattern.selector(elementForSelectorCheck) && !this._isShadowElement(el)) {
						                for (var j = 0; j < pattern.elementProcessors.length; j++) pattern.elementProcessors[j].call(this, el, urlReplacer, pattern);
						            }
						        }
						    };

						    // Utils

						    DomProcessor.prototype.getStoredAttrName = function getStoredAttrName(attr) {
						        return attr + _const2.default.DOM_SANDBOX_STORED_ATTR_POSTFIX;
						    };

						    DomProcessor.prototype.isOpenLinkInIFrame = function isOpenLinkInIFrame(el) {
						        var tagName = this.adapter.getTagName(el).toLowerCase();
						        var target = this.adapter.getAttr(el, 'target');

						        if (target !== '_top') {
						            var mustProcessTag = this.adapter.IFRAME_FLAG_TAGS.indexOf(tagName) !== -1;
						            var isNameTarget = target ? target[0] !== '_' : false;

						            if (target === '_parent') return mustProcessTag && !this.adapter.isTopParentIFrame(el);

						            if (mustProcessTag && (this.adapter.hasIFrameParent(el) || isNameTarget)) return true;
						        }

						        return false;
						    };

						    DomProcessor.prototype._isShadowElement = function _isShadowElement(el) {
						        return typeof el.className === 'string' && el.className.indexOf(_const2.default.SHADOW_UI_CLASSNAME_POSTFIX) > -1;
						    };

						    // Element processors

						    DomProcessor.prototype._processAutoComplete = function _processAutoComplete(el) {
						        var storedUrlAttr = this.getStoredAttrName('autocomplete');
						        var processed = this.adapter.hasAttr(el, storedUrlAttr);
						        var attrValue = this.adapter.getAttr(el, processed ? storedUrlAttr : 'autocomplete');

						        if (!processed) this.adapter.setAttr(el, storedUrlAttr, attrValue || attrValue === '' ? attrValue : 'none');

						        this.adapter.setAttr(el, 'autocomplete', 'off');
						    };

						    DomProcessor.prototype._processJsAttr = function _processJsAttr(el, attr, jsProtocol) {
						        var storedUrlAttr = this.getStoredAttrName(attr);
						        var processed = this.adapter.hasAttr(el, storedUrlAttr);
						        var attrValue = this.adapter.getAttr(el, processed ? storedUrlAttr : attr);

						        var code = jsProtocol ? attrValue.replace(JAVASCRIPT_PROTOCOL_REG_EX, '') : attrValue;
						        var matches = code.match(HTML_STRING_REG_EX);

						        var domProc = this;

						        var setAttributes = function (value, processedValue, processedAttrValue) {
						            if (value !== processedValue) {
						                if (!processed) domProc.adapter.setAttr(el, storedUrlAttr, attrValue);

						                domProc.adapter.setAttr(el, attr, processedAttrValue);
						            }
						        };

						        if (matches && jsProtocol) {
						            var html = matches[2];

						            this.emit(this.HTML_PROCESSING_REQUIRED, html, function (processedHTML) {
						                /*eslint-disable no-script-url*/
						                var processedAttrValue = 'javascript:\'' + processedHTML.replace(/'/g, "\\'") + '\'';

						                /*eslint-enable no-script-url*/
						                setAttributes(html, processedHTML, processedAttrValue);
						            });
						        } else {
						            var processedCode = _processingScript2.default.process(code, true);
						            var processedAttrValue = processedCode;

						            /*eslint-disable no-script-url*/
						            if (jsProtocol) processedAttrValue = 'javascript:' + processedAttrValue;
						            /*eslint-enable no-script-url*/

						            setAttributes(code, processedCode, processedAttrValue);
						        }
						    };

						    DomProcessor.prototype._processEvtAttr = function _processEvtAttr(el) {
						        var events = this.adapter.EVENTS;

						        for (var i = 0; i < events.length; i++) {
						            var attrValue = this.adapter.getAttr(el, events[i]);

						            if (attrValue) this._processJsAttr(el, events[i], JAVASCRIPT_PROTOCOL_REG_EX.test(attrValue));
						        }
						    };

						    DomProcessor.prototype._processMetaElement = function _processMetaElement(el, urlReplacer, pattern) {
						        if (this.adapter.getAttr(el, 'http-equiv').toLowerCase() === 'refresh') {
						            var attr = this.adapter.getAttr(el, pattern.urlAttr);

						            attr = attr.replace(/(url=)(.*)$/i, function () {
						                return arguments[1] + urlReplacer(arguments[2]);
						            });

						            this.adapter.setAttr(el, pattern.urlAttr, attr);
						        }
						    };

						    DomProcessor.prototype._processSandboxedIframe = function _processSandboxedIframe(el) {
						        var attrValue = this.adapter.getAttr(el, 'sandbox');

						        if (attrValue.indexOf('allow-scripts') === -1) {
						            var storedAttr = this.getStoredAttrName('sandbox');

						            this.adapter.setAttr(el, storedAttr, attrValue);
						            this.adapter.setAttr(el, 'sandbox', attrValue + ' allow-scripts');
						        }
						    };

						    DomProcessor.prototype._processScriptElement = function _processScriptElement(script) {
						        var scriptContent = this.adapter.getScriptContent(script);

						        if (!scriptContent) return;

						        var scriptProcessedOnServer = _jsIndex2.default.isScriptProcessed(scriptContent);

						        if (scriptProcessedOnServer) return;

						        // NOTE: we do not process scripts that are not executed during a page loading. We process scripts with type
						        // text/javascript, application/javascript etc. (list of MIME types is specified in the w3c.org html5
						        // specification). If type is not set, it 'text/javascript' by default.
						        var scriptType = this.adapter.getAttr(script, 'type');
						        var executableScriptTypesRegEx = /(application\/((x-)?ecma|(x-)?java)script)|(text\/)(javascript(1\.{0-5})?|((x-)?ecma|x-java|js|live)script)/;
						        var isExecutableScript = !scriptType || executableScriptTypesRegEx.test(scriptType);

						        if (isExecutableScript) {
						            var result = scriptContent;
						            var commentPrefix = '';
						            var commentPrefixMatch = result.match(HTML_COMMENT_PREFIX_REG_EX);
						            var commentPostfix = '';
						            var commentPostfixMatch = null;
						            var hasCDATA = CDATA_REG_EX.test(result);

						            if (commentPrefixMatch) {
						                commentPrefix = commentPrefixMatch[0];
						                commentPostfixMatch = result.match(HTML_COMMENT_POSTFIX_REG_EX);

						                if (commentPostfixMatch) commentPostfix = commentPostfixMatch[0];else if (!HTML_COMMENT_SIMPLE_POSTFIX_REG_EX.test(commentPrefix)) commentPostfix = '//-->';

						                result = result.replace(commentPrefix, '').replace(commentPostfix, '');
						            }

						            if (hasCDATA) result = result.replace(CDATA_REG_EX, '$2');

						            result = commentPrefix + _processingScript2.default.process(result) + commentPostfix;

						            if (hasCDATA) result = '\n//<![CDATA[\n' + result + '//]]>';

						            this.adapter.setScriptContent(script, result);
						        }
						    };

						    DomProcessor.prototype._processStyleAttr = function _processStyleAttr(el, urlReplacer) {
						        var style = this.adapter.getAttr(el, 'style');

						        if (style) this.adapter.setAttr(el, 'style', _processingStyle2.default.process(style, urlReplacer));
						    };

						    DomProcessor.prototype._processStylesheetElement = function _processStylesheetElement(el, urlReplacer) {
						        var content = this.adapter.getStyleContent(el);

						        if (content && urlReplacer) {
						            content = _processingStyle2.default.process(content, urlReplacer, true);

						            this.adapter.setStyleContent(el, content);
						        }
						    };

						    DomProcessor.prototype._processTargetBlank = function _processTargetBlank(el) {
						        // NOTE: replace target='_blank' to avoid popups
						        var attrValue = this.adapter.getAttr(el, 'target');

						        // NOTE: Value may have whitespace
						        attrValue = attrValue && attrValue.replace(/\s/g, '');

						        if (attrValue === '_blank' || attrValue === 'blank') this.adapter.setAttr(el, 'target', '_self');
						    };

						    DomProcessor.prototype._processUrlAttrs = function _processUrlAttrs(el, urlReplacer, pattern) {
						        if (urlReplacer && pattern.urlAttr) {
						            var storedUrlAttr = this.getStoredAttrName(pattern.urlAttr);
						            var resourceUrl = this.adapter.getAttr(el, pattern.urlAttr);
						            var processedOnServer = !!this.adapter.getAttr(el, storedUrlAttr);

						            // NOTE: page resource URL with proxy URL
						            if ((resourceUrl || resourceUrl === '') && !processedOnServer) {
						                if (_utilsUrl2.default.isSupportedProtocol(resourceUrl) && !EMPTY_URL_REG_EX.test(resourceUrl)) {
						                    var elTagName = this.adapter.getTagName(el).toLowerCase();
						                    var isIframe = elTagName === 'iframe';
						                    var isScript = elTagName === 'script';
						                    var resourceType = null;
						                    var target = this.adapter.getAttr(el, 'target');

						                    // On the server the elements shouldn't process with target=_parent,
						                    // because we don't know who is the parent of the processing page (iframe or top window)
						                    if (!this.adapter.needToProcessUrl(elTagName, target)) return;

						                    if (isIframe || this.isOpenLinkInIFrame(el)) resourceType = _utilsUrl2.default.IFRAME;else if (isScript) resourceType = _utilsUrl2.default.SCRIPT;

						                    var parsedResourceUrl = _utilsUrl2.default.parseUrl(resourceUrl);
						                    var isRelativePath = !parsedResourceUrl.host;
						                    var proxyUrl = '';

						                    // NOTE: Only non relative iframe src can be cross-domain
						                    if (isIframe && !isRelativePath) {
						                        var location = urlReplacer('/');
						                        var proxyUrlObj = _utilsUrl2.default.parseProxyUrl(location);
						                        var originUrl = proxyUrlObj.originUrl;

						                        if (!parsedResourceUrl.protocol) resourceUrl = proxyUrlObj.originResourceInfo.protocol + resourceUrl;

						                        // Cross-domain iframe
						                        if (!_utilsUrl2.default.sameOriginCheck(originUrl, resourceUrl)) {
						                            var proxyHostname = _utilsUrl2.default.parseUrl(location).hostname;

						                            proxyUrl = resourceUrl ? this.adapter.getProxyUrl(resourceUrl, proxyHostname, this.adapter.getCrossDomainPort(), proxyUrlObj.jobInfo.uid, proxyUrlObj.jobInfo.ownerToken, _utilsUrl2.default.IFRAME) : '';
						                        }
						                    }
						                    proxyUrl = proxyUrl === '' && resourceUrl ? urlReplacer(resourceUrl, resourceType) : proxyUrl;

						                    this.adapter.setAttr(el, storedUrlAttr, resourceUrl);

						                    if (elTagName === 'img' && proxyUrl !== '') this.adapter.setAttr(el, pattern.urlAttr, _utilsUrl2.default.resolveUrlAsOrigin(resourceUrl, urlReplacer));else this.adapter.setAttr(el, pattern.urlAttr, proxyUrl);
						                }
						            }
						        }
						    };

						    DomProcessor.prototype._processUrlJsAttr = function _processUrlJsAttr(el, urlReplacer, pattern) {
						        if (JAVASCRIPT_PROTOCOL_REG_EX.test(this.adapter.getAttr(el, pattern.urlAttr))) this._processJsAttr(el, pattern.urlAttr, true);
						    };

						    return DomProcessor;
						})();

						exports.default = DomProcessor;
						module.exports = exports.default;
					}
				},
				"js": {
					"index.js": function (exports, module, require) {
						exports.__esModule = true;

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

						function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						var _parsingTools = require('./parsing-tools');

						var _modifiers = require('./modifiers');

						var _modifiers2 = _interopRequireDefault(_modifiers);

						var _instructions = require('./instructions');

						var instructs = _interopRequireWildcard(_instructions);

						// Const
						var HTML_COMMENT_REG_EXP = /(^|\n)\s*<!--[.\r]*(\n|$)/g;

						var codegenOpts = {
						    format: {
						        quotes: 'double',
						        escapeless: true
						    }
						};

						var MOCK_ACCESSORS = ['var __w$undef_ = typeof window === "undefined",\r\n', instructs.GET_LOCATION_METH_NAME, '=__w$undef_?function(l){return l}:window.', instructs.GET_LOCATION_METH_NAME, ',\r\n', instructs.SET_LOCATION_METH_NAME, '=__w$undef_?function(l,v){return l = v}:window.', instructs.SET_LOCATION_METH_NAME, ',\r\n', instructs.SET_PROPERTY_METH_NAME, '=__w$undef_?function(o,p,v){return o[p] = v}:window.', instructs.SET_PROPERTY_METH_NAME, ',\r\n', instructs.GET_PROPERTY_METH_NAME, '=__w$undef_?function(o,p){return o[p]}:window.', instructs.GET_PROPERTY_METH_NAME, ',\r\n', instructs.CALL_METHOD_METH_NAME, '=__w$undef_?function(o,p,a){return o[p].apply(o,a)}:window.', instructs.CALL_METHOD_METH_NAME, ',\r\n', instructs.PROCESS_SCRIPT_METH_NAME, '=__w$undef_?function(s){return s}:window.', instructs.PROCESS_SCRIPT_METH_NAME, ';\r\n'].join('');

						var JsProcessor = (function () {
						    function JsProcessor() {
						        _classCallCheck(this, JsProcessor);

						        this.GET_LOCATION_METH_NAME = instructs.GET_LOCATION_METH_NAME;
						        this.SET_LOCATION_METH_NAME = instructs.SET_LOCATION_METH_NAME;
						        this.SET_PROPERTY_METH_NAME = instructs.SET_PROPERTY_METH_NAME;
						        this.GET_PROPERTY_METH_NAME = instructs.GET_PROPERTY_METH_NAME;
						        this.CALL_METHOD_METH_NAME = instructs.CALL_METHOD_METH_NAME;
						        this.PROCESS_SCRIPT_METH_NAME = instructs.PROCESS_SCRIPT_METH_NAME;
						        this.DOCUMENT_WRITE_BEGIN_PARAM = instructs.DOCUMENT_WRITE_BEGIN_PARAM;
						        this.DOCUMENT_WRITE_END_PARAM = instructs.DOCUMENT_WRITE_END_PARAM;

						        this.MOCK_ACCESSORS = MOCK_ACCESSORS;

						        this.wrappedProperties = instructs.wrappedProperties;
						        this.wrappedMethods = instructs.wrappedMethods;
						    }

						    JsProcessor.prototype._htmlCommentsReplacer = function _htmlCommentsReplacer(code) {
						        code = code.replace(HTML_COMMENT_REG_EXP, '\n');

						        if (HTML_COMMENT_REG_EXP.test(code)) code = this._htmlCommentsReplacer(code);

						        return code;
						    };

						    JsProcessor.prototype._modify = function _modify(ast, parent, key) {
						        var modified = false;

						        if (!ast || typeof ast !== 'object') return modified;

						        if (ast.type) {
						            for (var i = 0; i < _modifiers2.default.length; i++) {
						                if (_modifiers2.default[i].condition(ast, parent)) {
						                    var needToModify = _modifiers2.default[i].modifier(ast, parent, key);

						                    modified = true;

						                    if (needToModify) modified = this._modify(parent[key], parent, key) || modified;
						                }
						            }
						        }

						        for (var astKey in ast) {
						            if (ast.hasOwnProperty(astKey)) {
						                var childNode = ast[astKey];

						                /*eslint-disable indent*/
						                if (Object.prototype.toString.call(childNode) === '[object Array]') {
						                    for (var j = 0; j < childNode.length; j++) modified = this._modify(childNode[j], ast, astKey) || modified;
						                } else modified = this._modify(childNode, ast, astKey) || modified;
						                /*eslint-enable indent*/
						            }
						        }

						        return modified;
						    };

						    JsProcessor.prototype._isArray = function _isArray(code) {
						        return (/^\s*\[[\s\S]*\]\s*$/.test(code)
						        );
						    };

						    JsProcessor.prototype._isObject = function _isObject(code) {
						        return (/^\s*\{[\s\S]*\}\s*$/.test(code)
						        );
						    };

						    JsProcessor.prototype.isJSON = function isJSON(code) {
						        if (this._isObject(code)) {
						            try {
						                JSON.parse(code);

						                return true;
						            } catch (e) {
						                return false;
						            }
						        }

						        return false;
						    };

						    JsProcessor.prototype.isScriptProcessed = function isScriptProcessed(code) {
						        return new RegExp([instructs.GET_LOCATION_METH_NAME, instructs.SET_LOCATION_METH_NAME, instructs.SET_PROPERTY_METH_NAME, instructs.GET_PROPERTY_METH_NAME, instructs.CALL_METHOD_METH_NAME, instructs.PROCESS_SCRIPT_METH_NAME].join('|').replace(/\$/, '\\$')).test(code);
						    };

						    JsProcessor.prototype.isDataScript = function isDataScript(code) {
						        return this._isObject(code) || this._isArray(code);
						    };

						    JsProcessor.prototype.process = function process(code, beautify) {
						        var isJSON = this.isJSON(code);
						        var isObject = this._isObject(code);

						        codegenOpts.json = isJSON;

						        // T226589. Js parser removes next line after '<!--'
						        var result = this._htmlCommentsReplacer(code);
						        var ast = null;

						        try {
						            ast = _parsingTools.parse(isObject && !isJSON ? '(' + result + ')' : 'function temp(){\n' + result + '\n}');
						        } catch (e) {
						            try {
						                /*eslint-disable indent*/
						                if (isObject && !isJSON) {
						                    ast = _parsingTools.parse('function temp(){\n' + result + '\n}');
						                    isObject = false;
						                } else return code;
						                /*eslint-enable indent*/
						            } catch (err) {
						                return code;
						            }
						        }

						        var modified = this._modify(ast);

						        if (!modified) return code;

						        codegenOpts.format.compact = !beautify;

						        result = _parsingTools.generate(ast, codegenOpts);

						        if (isObject && !isJSON) result = result.replace(/^\(|\);\s*$/g, '');else result = result.replace(/^\s*function\s+temp\s*\(\s*\)\s*{\s*/, '').replace(/\s*}\s*$/, '');

						        if (!/;\s*$/.test(code)) result = result.replace(/;\s*$/, '');

						        return result;
						    };

						    return JsProcessor;
						})();

						exports.default = new JsProcessor();
						module.exports = exports.default;
					},
					"instructions.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.needToWrapProperty = needToWrapProperty;
						exports.needToWrapMethod = needToWrapMethod;
						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						var wrappedMethods = {
						    postMessage: true,
						    write: true,
						    writeln: true
						};

						exports.wrappedMethods = wrappedMethods;
						var wrappedProperties = {
						    action: true,
						    activeElement: true,
						    attributes: true,
						    autocomplete: true,
						    background: true,
						    backgroundImage: true,
						    borderImage: true,
						    cookie: true,
						    cssText: true,
						    cursor: true,
						    data: true,
						    domain: true,
						    files: true,
						    firstChild: true,
						    firstElementChild: true,
						    host: true,
						    hostname: true,
						    href: true,
						    innerHTML: true,
						    lastChild: true,
						    lastElementChild: true,
						    length: true,
						    listStyle: true,
						    listStyleImage: true,
						    location: true,
						    manifest: true,
						    onbeforeunload: true,
						    onerror: true,
						    onmessage: true,
						    origin: true,
						    pathname: true,
						    port: true,
						    protocol: true,
						    referrer: true,
						    sandbox: true,
						    search: true,
						    src: true,
						    target: true,
						    text: true,
						    textContent: true,
						    URL: true,
						    value: true,
						    which: true
						};

						exports.wrappedProperties = wrappedProperties;
						var GET_LOCATION_METH_NAME = '__get$Loc';
						exports.GET_LOCATION_METH_NAME = GET_LOCATION_METH_NAME;
						var SET_LOCATION_METH_NAME = '__set$Loc';
						exports.SET_LOCATION_METH_NAME = SET_LOCATION_METH_NAME;
						var SET_PROPERTY_METH_NAME = '__set$';
						exports.SET_PROPERTY_METH_NAME = SET_PROPERTY_METH_NAME;
						var GET_PROPERTY_METH_NAME = '__get$';
						exports.GET_PROPERTY_METH_NAME = GET_PROPERTY_METH_NAME;
						var CALL_METHOD_METH_NAME = '__call$';
						exports.CALL_METHOD_METH_NAME = CALL_METHOD_METH_NAME;
						var PROCESS_SCRIPT_METH_NAME = '__proc$Script';

						exports.PROCESS_SCRIPT_METH_NAME = PROCESS_SCRIPT_METH_NAME;
						var DOCUMENT_WRITE_BEGIN_PARAM = '__begin$';
						exports.DOCUMENT_WRITE_BEGIN_PARAM = DOCUMENT_WRITE_BEGIN_PARAM;
						var DOCUMENT_WRITE_END_PARAM = '__end$';
						exports.DOCUMENT_WRITE_END_PARAM = DOCUMENT_WRITE_END_PARAM;
						var FOR_IN_TEMP_VAR_NAME = '__set$temp';

						exports.FOR_IN_TEMP_VAR_NAME = FOR_IN_TEMP_VAR_NAME;

						function needToWrapProperty(property) {
						    return wrappedProperties[property] && wrappedProperties.hasOwnProperty(property);
						}

						function needToWrapMethod(meth) {
						    return wrappedMethods[meth] && wrappedMethods.hasOwnProperty(meth);
						}
					},
					"modifiers.js": function (exports, module, require) {
						exports.__esModule = true;

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						var _parsingTools = require('./parsing-tools');

						var _templates = require('./templates');

						var templates = _interopRequireWildcard(_templates);

						var _instructions = require('./instructions');

						var instructs = _interopRequireWildcard(_instructions);

						function updateAstNode(node, newNode, parent, key) {
						    /*eslint-disable indent*/
						    if (key === 'arguments' || key === 'elements' || key === 'expressions') {
						        var index = parent[key].indexOf(node);

						        parent[key][index] = newNode;
						    } else parent[key] = newNode;
						    /*eslint-enable indent*/
						}

						// for(obj[i++] in src), for(obj['href'] in src), for(obj.href in src)
						function forin(astNode) {
						    // for(obj[i++] in src) --> for(__set$temp in src) { __set$(obj, i++, __set$temp); }
						    var tempVarAst = {
						        type: _parsingTools.Syntax.Identifier,
						        name: instructs.FOR_IN_TEMP_VAR_NAME
						    };

						    astNode.body.body.unshift({
						        type: _parsingTools.Syntax.ExpressionStatement,

						        expression: {
						            type: _parsingTools.Syntax.AssignmentExpression,
						            operator: '=',
						            left: astNode.left,
						            right: tempVarAst
						        }
						    });

						    astNode.left = {
						        type: _parsingTools.Syntax.VariableDeclaration,

						        declarations: [{
						            type: _parsingTools.Syntax.VariableDeclarator,
						            id: tempVarAst,
						            init: null
						        }],

						        kind: 'var'
						    };

						    return true;
						}

						// new Function([, params], [body]);
						function functionCtor(astNode) {
						    if (!astNode.arguments.length) return false;

						    var lastArgIndex = astNode.arguments.length - 1;

						    // new Function([, params], [body]); --> new Function([, params], __proc$Script([body]));
						    astNode.arguments[lastArgIndex] = templates.getProcessScriptMethAst([astNode.arguments[lastArgIndex]]);

						    return false;
						}

						// { ... [obj].write([html]); ... [obj].writeln([html]); ... }
						function documentWrite(astNode) {
						    var indices = templates.getDocumentWriteStatementIndices(astNode.body);

						    // { ... [obj].write([html]); ... [obj].writeln([html]); ... } -->
						    // { ... [obj].write([html], __begin$); ... [obj].writeln([html], __end$); ... }
						    astNode.body[indices[0]].expression.arguments.push(templates.getDocumentWriteArgAst(instructs.DOCUMENT_WRITE_BEGIN_PARAM));
						    astNode.body[indices[indices.length - 1]].expression.arguments.push(templates.getDocumentWriteArgAst(instructs.DOCUMENT_WRITE_END_PARAM));

						    return false;
						}

						// eval(), window.eval(), window['eval']
						function evalArgument(astNode) {
						    if (!astNode.arguments.length) return false;

						    // eval(script) --> eval(__proc$Script(script))
						    var newArg = templates.getProcessScriptMethAst(astNode.arguments);

						    astNode.arguments[0] = newArg;

						    return false;
						}

						// eval.call(), window.eval.call(), window['eval'].call()
						function callEvalArgument(astNode) {
						    // eval.call(window, script) --> eval.call(window, __proc$Script(script))
						    var newArg = templates.getProcessScriptMethAst([astNode.arguments[1]]);

						    astNode.arguments[1] = newArg;

						    return false;
						}

						// eval.apply(), window.eval.apply(), window['eval'].apply()
						function applyEvalArgument(astNode) {
						    // eval.apply(window, [script]) --> eval.apply(window, [__proc$Script(script)])
						    var newArg = templates.getProcessScriptMethAst([astNode.arguments[1].elements[0]]);

						    astNode.arguments[1].elements[0] = newArg;

						    return false;
						}

						// location
						function getLocation(astNode, parent, key) {
						    // location --> __get$Loc(location)
						    var newNode = templates.getGetLocationMethAst();

						    updateAstNode(astNode, newNode, parent, key);

						    return false;
						}

						// location.[field]
						function getLocationMember(astNode) {
						    // location.[field]  --> __get$Loc(location).[field]
						    // location[[field]] --> __get$(__get$Loc(location), [field])
						    var newNode = templates.getGetLocationMethAst(astNode.object);

						    astNode.object = newNode;

						    return false;
						}

						// location = [value]
						function setLocation(astNode, parent, key) {
						    // location = [value] --> (function(){ return __set$Loc(location, [value]) || location = [value];}.apply(this))
						    var newNode = templates.getSetLocationMethAst(astNode.right);

						    updateAstNode(astNode, newNode, parent, key);

						    return false;
						}

						// [object].location = [value]
						function memberSet(astNode, parent, key) {
						    // [any].location = [value] --> __set$([object], 'location', [value])
						    var newNode = templates.getSetMethAst(astNode.left.property.name, astNode.left.object, astNode.right);

						    updateAstNode(astNode, newNode, parent, key);

						    return true;
						}

						// [object].location
						function memberGet(astNode, parent, key) {
						    // [object].location --> __get$([object], 'location')
						    var newNode = templates.getGetMethAst(astNode.property.name, astNode.object);

						    updateAstNode(astNode, newNode, parent, key);

						    return true;
						}

						// [object].[method]() || [object][[method]]()
						function callMethod(astNode, parent, key) {
						    var meth = null;

						    /*eslint-disable indent*/
						    if (!astNode.callee.computed) {
						        meth = {
						            type: _parsingTools.Syntax.Literal,
						            value: astNode.callee.property.name,
						            raw: '"' + astNode.callee.property.name + '"'
						        };
						    } else meth = astNode.callee.property;
						    /*eslint-enable indent*/

						    // [object].[method]([args]) --> _call$([object], [method], [args])
						    // [object][[method]]([args]) --> _call$([object], [method], [args])
						    var newNode = templates.getCallMethodMthAst(astNode.callee.object, meth, astNode.arguments);

						    updateAstNode(astNode, newNode, parent, key);

						    return true;
						}

						// [object][[field]]
						function computedMemberGet(astNode, parent, key) {
						    //[object][[field]] --> __get$([object], [field])
						    var newNode = templates.getGetComputedMethAst(astNode.property, astNode.object);

						    updateAstNode(astNode, newNode, parent, key);

						    return true;
						}

						// [object][[field]] = [value]
						function computedMemberSet(astNode, parent, key) {
						    //[object][[field]] = [value] --> __set$([object], [field], [value])
						    var newNode = templates.getSetComputedMethAst(astNode.left.property, astNode.left.object, astNode.right);

						    updateAstNode(astNode, newNode, parent, key);

						    return true;
						}

						// [object] += [value]
						function concatOperator(astNode, parent, key) {
						    //[object] += [value] --> [object] = [object] + [value]
						    var newNode = templates.getConcatOperatorAst(astNode.left, astNode.right);

						    updateAstNode(astNode, newNode, parent, key);

						    return true;
						}

						// Modify conditions
						exports.default = [{
						    modifier: documentWrite,
						    condition: function (astNode) {
						        // { ... [obj].write([html]); ... [obj].writeln([html]); ... }
						        if (astNode.type === _parsingTools.Syntax.BlockStatement || astNode.type === _parsingTools.Syntax.Program) return templates.getDocumentWriteStatementIndices(astNode.body).length > 1;

						        return false;
						    }
						}, {
						    modifier: functionCtor,
						    condition: function (astNode) {
						        // new Function(...)
						        if (astNode.type === _parsingTools.Syntax.NewExpression && astNode.callee.name === 'Function') return true;

						        return false;
						    }
						}, {
						    modifier: forin,
						    condition: function (astNode) {
						        // for(var key in obj)
						        if (astNode.type === _parsingTools.Syntax.ForInStatement) {
						            // for (obj[prop] in src), for (obj['prop'] in src), for (obj.href in src)
						            if (astNode.left.type === _parsingTools.Syntax.MemberExpression) return true;
						        }

						        return false;
						    }
						}, {
						    modifier: evalArgument,
						    condition: function (astNode) {
						        if (astNode.type === _parsingTools.Syntax.CallExpression) {
						            // eval([...]), setTimeout([...]), setInterval([...])
						            if (astNode.callee.type === _parsingTools.Syntax.Identifier && /^(eval|setTimeout|setInterval)$/.test(astNode.callee.name)) return true;

						            // [obj].eval([...]), [obj]['eval']([...]), [obj].setTimeout([...]), [obj]['setTimeout']([...]), [obj].setInterval([...]), [obj]['setInterval']([...])
						            if (astNode.callee.type === _parsingTools.Syntax.MemberExpression && /^(eval|setTimeout|setInterval)$/.test(astNode.callee.property.name || astNode.callee.property.value)) return true;
						        }

						        return false;
						    }
						}, {
						    modifier: callEvalArgument,
						    condition: function (astNode) {
						        if (astNode.type === _parsingTools.Syntax.CallExpression) {
						            // [obj].eval.call([...]), [obj][eval].call([...]), [obj].setTimeout.call([...]), [obj][setTimeout].call([...]),
						            // [obj].setInterval.call([...]), [obj][setInterval].call([...])
						            if (astNode.callee.type === _parsingTools.Syntax.MemberExpression && astNode.callee.property.name === 'call') {
						                var obj = astNode.callee.object;

						                if (obj.type === _parsingTools.Syntax.MemberExpression && /^(eval|setTimeout|setInterval)$/.test(obj.property.value || obj.property.name)) return true;
						            }

						            // eval.call([...]), setTimeout.call([...]), setInterval.call([...])
						            if (astNode.callee.type === _parsingTools.Syntax.MemberExpression && astNode.callee.property.name === 'call' && /^(eval|setTimeout|setInterval)$/.test(astNode.callee.object.name)) return true;
						        }

						        return false;
						    }
						}, {
						    modifier: applyEvalArgument,
						    condition: function (astNode) {
						        if (astNode.type === _parsingTools.Syntax.CallExpression) {
						            // [obj].eval.apply([...]), [obj][eval].apply([...]), [obj].setTimeout.apply([...]), [obj][setTimeout].apply([...]),
						            // [obj].setInterval.apply([...]), [obj][setInterval].apply([...])
						            if (astNode.callee.type === _parsingTools.Syntax.MemberExpression && astNode.callee.property.name === 'apply') {
						                var obj = astNode.callee.object;

						                if (obj.type === _parsingTools.Syntax.MemberExpression && /^(eval|setTimeout|setInterval)$/.test(obj.property.value || obj.property.name)) return true;
						            }

						            // eval.apply([...]), setTimeout.apply([...]), setInterval.apply([...])
						            if (astNode.callee.type === _parsingTools.Syntax.MemberExpression && astNode.callee.property.name === 'apply' && /^(eval|setTimeout|setInterval)$/.test(astNode.callee.object.name)) return true;
						        }

						        return false;
						    }
						}, {
						    modifier: getLocation,
						    condition: function (astNode, parent) {
						        if (astNode.type === _parsingTools.Syntax.Identifier) {
						            if (astNode.name !== 'location') return false;

						            // var location = [value];
						            if (parent.type === _parsingTools.Syntax.VariableDeclarator && parent.id === astNode) return false;

						            // location = [value]
						            if (parent.type === _parsingTools.Syntax.AssignmentExpression && parent.left === astNode) return false;

						            // [object].location || location.[field]
						            if (parent.type === _parsingTools.Syntax.MemberExpression) return false;

						            // { location: [value] }
						            if (parent.type === _parsingTools.Syntax.Property && parent.key === astNode) return false;

						            // location++ || location-- || ++location || --location
						            if (parent.type === _parsingTools.Syntax.UpdateExpression && parent.operator === '++' || parent.operator === '--') return false;

						            // function (location) { ... } || function func(location) { ... }
						            if ((parent.type === _parsingTools.Syntax.FunctionExpression || parent.type === _parsingTools.Syntax.FunctionDeclaration) && parent.params.indexOf(astNode) !== -1) return false;

						            // Already  modified: __getGlobalProperty('location', location)
						            if (parent.type === _parsingTools.Syntax.CallExpression && parent.callee.name === instructs.GET_LOCATION_METH_NAME) return false;

						            return true;
						        }

						        return false;
						    }
						}, {
						    modifier: getLocationMember,
						    condition: function (astNode, parent) {
						        // [object].[field]
						        if (astNode.type === _parsingTools.Syntax.MemberExpression) {
						            // for(location.[field] in [source])
						            if (parent.type === _parsingTools.Syntax.ForInStatement && parent.left === astNode) return false;

						            // location.[field]
						            if (astNode.object.name === 'location') return true;
						        }

						        return false;
						    }
						}, {
						    modifier: setLocation,
						    condition: function (astNode) {
						        // [object] = [value]
						        if (astNode.type === _parsingTools.Syntax.AssignmentExpression && astNode.operator === '=') {
						            var leftOperand = astNode.left;

						            // location = [value]
						            if (leftOperand.type === _parsingTools.Syntax.Identifier && leftOperand.name === 'location') return true;
						        }

						        return false;
						    }
						}, {
						    modifier: memberSet,
						    condition: function (astNode) {
						        // [object] = [value]
						        if (astNode.type === _parsingTools.Syntax.AssignmentExpression && !astNode.computed && astNode.operator === '=') {
						            var leftOperand = astNode.left;

						            // [object].[field] = []
						            if (leftOperand.type === _parsingTools.Syntax.MemberExpression && leftOperand.property.type === _parsingTools.Syntax.Identifier) {
						                // [object].location = [value]
						                if (instructs.needToWrapProperty(leftOperand.property.name)) return true;
						            }
						        }

						        return false;
						    }
						}, {
						    modifier: callMethod,
						    condition: function (astNode) {
						        // [object]()
						        if (astNode.type === _parsingTools.Syntax.CallExpression) {
						            // [object].[field]() || [object][[field]]()
						            if (astNode.callee.type === _parsingTools.Syntax.MemberExpression) {
						                if (astNode.callee.computed && astNode.callee.property.type === _parsingTools.Syntax.Literal && !instructs.needToWrapMethod(astNode.callee.property.value)) return false;

						                if (!astNode.callee.computed && !instructs.needToWrapMethod(astNode.callee.property.name)) return false;

						                return true;
						            }
						        }

						        return false;
						    }
						}, {
						    modifier: memberGet,
						    condition: function (astNode, parent) {
						        // [object].[field]
						        if (astNode.type === _parsingTools.Syntax.MemberExpression && !astNode.computed) {
						            if (!instructs.needToWrapProperty(astNode.property.name)) return false;

						            // [object].[field] = [value]
						            if (parent.type === _parsingTools.Syntax.AssignmentExpression && parent.left === astNode) return false;

						            // delete [object].[field]
						            if (parent.type === _parsingTools.Syntax.UnaryExpression && parent.operator === 'delete') return false;

						            // [object].[field]()
						            if (parent.type === _parsingTools.Syntax.CallExpression && parent.callee === astNode) return false;

						            // [object].[field]++ || [object].[field]-- || ++[object].[field] || --[object].[field]
						            if (parent.type === _parsingTools.Syntax.UpdateExpression && parent.operator === '++' || parent.operator === '--') return false;

						            // new ([object].[field])() || new ([object].[field])
						            if (parent.type === _parsingTools.Syntax.NewExpression && parent.callee === astNode) return false;

						            // for([object].[field] in [source])
						            if (parent.type === _parsingTools.Syntax.ForInStatement && parent.left === astNode) return false;

						            return true;
						        }

						        return false;
						    }
						}, {
						    modifier: computedMemberGet,
						    condition: function (astNode, parent) {
						        // [object][[field]]
						        if (astNode.type === _parsingTools.Syntax.MemberExpression && astNode.computed) {

						            // [object][[field]] = [value]
						            if (parent.type === _parsingTools.Syntax.AssignmentExpression && parent.left === astNode) return false;

						            // delete [object][[field]]
						            if (parent.type === _parsingTools.Syntax.UnaryExpression && parent.operator === 'delete') return false;

						            // [object].[field]++ || [object].[field]-- || ++[object].[field] || --[object].[field]
						            if (parent.type === _parsingTools.Syntax.UpdateExpression && parent.operator === '++' || parent.operator === '--') return false;

						            // [object][[field]]()
						            if (parent.type === _parsingTools.Syntax.CallExpression && parent.callee === astNode) return false;

						            // new ([object][[field]])() || new ([object][[field]])
						            if (parent.type === _parsingTools.Syntax.NewExpression && parent.callee === astNode) return false;

						            // for([object].[[field]] in [source])
						            if (parent.type === _parsingTools.Syntax.ForInStatement && parent.left === astNode) return false;

						            if (astNode.property.type === _parsingTools.Syntax.Literal && !instructs.needToWrapProperty(astNode.property.value)) return false;

						            return true;
						        }

						        return false;
						    }
						}, {
						    modifier: computedMemberSet,
						    condition: function (astNode) {
						        // [object] = [value]
						        if (astNode.type === _parsingTools.Syntax.AssignmentExpression && astNode.operator === '=') {
						            // [object][[field]] = [value]
						            if (astNode.left.type === _parsingTools.Syntax.MemberExpression && astNode.left.computed) {
						                // [object].location = [value]
						                if (astNode.left.property.type === _parsingTools.Syntax.Literal) return instructs.needToWrapProperty(astNode.left.property.value);

						                return true;
						            }
						        }

						        return false;
						    }
						}, {
						    modifier: concatOperator,
						    condition: function (astNode) {
						        // [object] += [value]
						        if (astNode.type === _parsingTools.Syntax.AssignmentExpression && astNode.operator === '+=') return true;

						        return false;
						    }
						}];
						module.exports = exports.default;
					},
					"parsing-tools.js": function (exports, module, require) {
						exports.__esModule = true; // -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------
						var JSParsingTools={}; // ---------------- Acorn -------------------
						var acornExports={};(function(exports){ // Acorn is a tiny, fast JavaScript parser written in JavaScript.
						//
						// Acorn was written by Marijn Haverbeke and released under an MIT
						// license. The Unicode regexps (for identifiers and whitespace) were
						// taken from [Esprima](http://esprima.org) by Ariya Hidayat.
						//
						// Git repositories for Acorn are available at
						//
						//     http://marijnhaverbeke.nl/git/acorn
						//     https://github.com/marijnh/acorn.git
						//
						// Please use the [github bug tracker][ghbt] to report issues.
						//
						// [ghbt]: https://github.com/marijnh/acorn/issues
						//
						// This file defines the main parser interface. The library also comes
						// with a [error-tolerant parser][dammit] and an
						// [abstract syntax tree walker][walk], defined in other files.
						//
						// [dammit]: acorn_loose.js
						(function(root,mod){if(typeof exports == "object" && typeof module == "object")return mod(exports); // CommonJS
						if(typeof define == "function" && define.amd)return define(["exports"],mod); // AMD
						mod(root.acorn || (root.acorn = {})); // Plain browser env
						})(this,function(exports){"use strict";exports.version = "0.4.1"; // The main exported interface (under `self.acorn` when in the
						// browser) is a `parse` function that takes a code string and
						// returns an abstract syntax tree as specified by [Mozilla parser
						// API][api], with the caveat that the SpiderMonkey-specific syntax
						// (`let`, `yield`, inline XML, etc) is not recognized.
						//
						// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
						var options,input,inputLen,sourceFile;exports.parse = function(inpt,opts){input = String(inpt);inputLen = input.length;setOptions(opts);initTokenState();return parseTopLevel(options.program);}; // A second optional argument can be given to further configure
						// the parser process. These options are recognized:
						var defaultOptions=exports.defaultOptions = { // `ecmaVersion` indicates the ECMAScript version to parse. Must
						// be either 3 or 5. This
						// influences support for strict mode, the set of reserved words, and
						// support for getters and setter.
						ecmaVersion:5, // Turn on `strictSemicolons` to prevent the parser from doing
						// automatic semicolon insertion.
						strictSemicolons:false, // When `allowTrailingCommas` is false, the parser will not allow
						// trailing commas in array and object literals.
						allowTrailingCommas:true, // By default, reserved words are not enforced. Enable
						// `forbidReserved` to enforce them.
						forbidReserved:false, // When `locations` is on, `loc` properties holding objects with
						// `start` and `end` properties in `{line, column}` form (with
						// line being 1-based and column 0-based) will be attached to the
						// nodes.
						locations:false, // A function can be passed as `onComment` option, which will
						// cause Acorn to call that function with `(block, text, start,
						// end)` parameters whenever a comment is skipped. `block` is a
						// boolean indicating whether this is a block (`/* */`) comment,
						// `text` is the content of the comment, and `start` and `end` are
						// character offsets that denote the start and end of the comment.
						// When the `locations` option is on, two more parameters are
						// passed, the full `{line, column}` locations of the start and
						// end of the comments.
						onComment:null, // Nodes have their start and end characters offsets recorded in
						// `start` and `end` properties (directly on the node, rather than
						// the `loc` object, which holds line/column data. To also add a
						// [semi-standardized][range] `range` property holding a `[start,
						// end]` array with the same numbers, set the `ranges` option to
						// `true`.
						//
						// [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
						ranges:false, // It is possible to parse multiple files into a single AST by
						// passing the tree produced by parsing the first file as
						// `program` option in subsequent parses. This will add the
						// toplevel forms of the parsed file to the `Program` (top) node
						// of an existing parse tree.
						program:null, // When `location` is on, you can pass this to record the source
						// file in every node's `loc` object.
						sourceFile:null, // This value, if given, is stored in every node, whether
						// `location` is on or off.
						directSourceFile:null};function setOptions(opts){options = opts || {};for(var opt in defaultOptions) if(!Object.prototype.hasOwnProperty.call(options,opt))options[opt] = defaultOptions[opt];sourceFile = options.sourceFile || null;} // The `getLineInfo` function is mostly useful when the
						// `locations` option is off (for performance reasons) and you
						// want to find the line/column position for a given character
						// offset. `input` should be the code string that the offset refers
						// into.
						var getLineInfo=exports.getLineInfo = function(input,offset){for(var line=1,cur=0;;) {lineBreak.lastIndex = cur;var match=lineBreak.exec(input);if(match && match.index < offset){++line;cur = match.index + match[0].length;}else break;}return {line:line,column:offset - cur};}; // Acorn is organized as a tokenizer and a recursive-descent parser.
						// The `tokenize` export provides an interface to the tokenizer.
						// Because the tokenizer is optimized for being efficiently used by
						// the Acorn parser itself, this interface is somewhat crude and not
						// very modular. Performing another parse or call to `tokenize` will
						// reset the internal state, and invalidate existing tokenizers.
						exports.tokenize = function(inpt,opts){input = String(inpt);inputLen = input.length;setOptions(opts);initTokenState();var t={};function getToken(forceRegexp){readToken(forceRegexp);t.start = tokStart;t.end = tokEnd;t.startLoc = tokStartLoc;t.endLoc = tokEndLoc;t.type = tokType;t.value = tokVal;return t;}getToken.jumpTo = function(pos,reAllowed){tokPos = pos;if(options.locations){tokCurLine = 1;tokLineStart = lineBreak.lastIndex = 0;var match;while((match = lineBreak.exec(input)) && match.index < pos) {++tokCurLine;tokLineStart = match.index + match[0].length;}}tokRegexpAllowed = reAllowed;skipSpace();};return getToken;}; // State is kept in (closure-)global variables. We already saw the
						// `options`, `input`, and `inputLen` variables above.
						// The current position of the tokenizer in the input.
						var tokPos; // The start and end offsets of the current token.
						var tokStart,tokEnd; // When `options.locations` is true, these hold objects
						// containing the tokens start and end line/column pairs.
						var tokStartLoc,tokEndLoc; // The type and value of the current token. Token types are objects,
						// named by variables against which they can be compared, and
						// holding properties that describe them (indicating, for example,
						// the precedence of an infix operator, and the original name of a
						// keyword token). The kind of value that's held in `tokVal` depends
						// on the type of the token. For literals, it is the literal value,
						// for operators, the operator name, and so on.
						var tokType,tokVal; // Interal state for the tokenizer. To distinguish between division
						// operators and regular expressions, it remembers whether the last
						// token was one that is allowed to be followed by an expression.
						// (If it is, a slash is probably a regexp, if it isn't it's a
						// division operator. See the `parseStatement` function for a
						// caveat.)
						var tokRegexpAllowed; // When `options.locations` is true, these are used to keep
						// track of the current line, and know when a new line has been
						// entered.
						var tokCurLine,tokLineStart; // These store the position of the previous token, which is useful
						// when finishing a node and assigning its `end` position.
						var lastStart,lastEnd,lastEndLoc; // This is the parser's state. `inFunction` is used to reject
						// `return` statements outside of functions, `labels` to verify that
						// `break` and `continue` have somewhere to jump to, and `strict`
						// indicates whether strict mode is on.
						var inFunction,labels,strict; // This function is used to raise exceptions on parse errors. It
						// takes an offset integer (into the current `input`) to indicate
						// the location of the error, attaches the position to the end
						// of the error message, and then raises a `SyntaxError` with that
						// message.
						function raise(pos,message){var loc=getLineInfo(input,pos);message += " (" + loc.line + ":" + loc.column + ")";var err=new SyntaxError(message);err.pos = pos;err.loc = loc;err.raisedAt = tokPos;throw err;} // Reused empty array added for node fields that are always empty.
						var empty=[]; // ## Token types
						// The assignment of fine-grained, information-carrying type objects
						// allows the tokenizer to store the information it has about a
						// token in a way that is very cheap for the parser to look up.
						// All token type variables start with an underscore, to make them
						// easy to recognize.
						// These are the general types. The `type` property is only used to
						// make them recognizeable when debugging.
						var _num={type:"num"},_regexp={type:"regexp"},_string={type:"string"};var _name={type:"name"},_eof={type:"eof"}; // Keyword tokens. The `keyword` property (also used in keyword-like
						// operators) indicates that the token originated from an
						// identifier-like word, which is used when parsing property names.
						//
						// The `beforeExpr` property is used to disambiguate between regular
						// expressions and divisions. It is set on all token types that can
						// be followed by an expression (thus, a slash after them would be a
						// regular expression).
						//
						// `isLoop` marks a keyword as starting a loop, which is important
						// to know when parsing a label, in order to allow or disallow
						// continue jumps to that label.
						var _break={keyword:"break"},_case={keyword:"case",beforeExpr:true},_catch={keyword:"catch"};var _continue={keyword:"continue"},_debugger={keyword:"debugger"},_default={keyword:"default"};var _do={keyword:"do",isLoop:true},_else={keyword:"else",beforeExpr:true};var _finally={keyword:"finally"},_for={keyword:"for",isLoop:true},_function={keyword:"function"};var _if={keyword:"if"},_return={keyword:"return",beforeExpr:true},_switch={keyword:"switch"};var _throw={keyword:"throw",beforeExpr:true},_try={keyword:"try"},_var={keyword:"var"};var _while={keyword:"while",isLoop:true},_with={keyword:"with"},_new={keyword:"new",beforeExpr:true};var _this={keyword:"this"}; // The keywords that denote values.
						var _null={keyword:"null",atomValue:null},_true={keyword:"true",atomValue:true};var _false={keyword:"false",atomValue:false}; // Some keywords are treated as regular operators. `in` sometimes
						// (when parsing `for`) needs to be tested against specifically, so
						// we assign a variable name to it for quick comparing.
						var _in={keyword:"in",binop:7,beforeExpr:true}; // Map keyword names to token types.
						var keywordTypes={"break":_break,"case":_case,"catch":_catch,"continue":_continue,"debugger":_debugger,"default":_default,"do":_do,"else":_else,"finally":_finally,"for":_for,"function":_function,"if":_if,"return":_return,"switch":_switch,"throw":_throw,"try":_try,"var":_var,"while":_while,"with":_with,"null":_null,"true":_true,"false":_false,"new":_new,"in":_in,"instanceof":{keyword:"instanceof",binop:7,beforeExpr:true},"this":_this,"typeof":{keyword:"typeof",prefix:true,beforeExpr:true},"void":{keyword:"void",prefix:true,beforeExpr:true},"delete":{keyword:"delete",prefix:true,beforeExpr:true}}; // Punctuation token types. Again, the `type` property is purely for debugging.
						var _bracketL={type:"[",beforeExpr:true},_bracketR={type:"]"},_braceL={type:"{",beforeExpr:true};var _braceR={type:"}"},_parenL={type:"(",beforeExpr:true},_parenR={type:")"};var _comma={type:",",beforeExpr:true},_semi={type:";",beforeExpr:true};var _colon={type:":",beforeExpr:true},_dot={type:"."},_question={type:"?",beforeExpr:true}; // Operators. These carry several kinds of properties to help the
						// parser use them properly (the presence of these properties is
						// what categorizes them as operators).
						//
						// `binop`, when present, specifies that this operator is a binary
						// operator, and will refer to its precedence.
						//
						// `prefix` and `postfix` mark the operator as a prefix or postfix
						// unary operator. `isUpdate` specifies that the node produced by
						// the operator should be of type UpdateExpression rather than
						// simply UnaryExpression (`++` and `--`).
						//
						// `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
						// binary operators with a very low precedence, that should result
						// in AssignmentExpression nodes.
						var _slash={binop:10,beforeExpr:true},_eq={isAssign:true,beforeExpr:true};var _assign={isAssign:true,beforeExpr:true};var _incDec={postfix:true,prefix:true,isUpdate:true},_prefix={prefix:true,beforeExpr:true};var _logicalOR={binop:1,beforeExpr:true};var _logicalAND={binop:2,beforeExpr:true};var _bitwiseOR={binop:3,beforeExpr:true};var _bitwiseXOR={binop:4,beforeExpr:true};var _bitwiseAND={binop:5,beforeExpr:true};var _equality={binop:6,beforeExpr:true};var _relational={binop:7,beforeExpr:true};var _bitShift={binop:8,beforeExpr:true};var _plusMin={binop:9,prefix:true,beforeExpr:true};var _multiplyModulo={binop:10,beforeExpr:true}; // Provide access to the token types for external users of the
						// tokenizer.
						exports.tokTypes = {bracketL:_bracketL,bracketR:_bracketR,braceL:_braceL,braceR:_braceR,parenL:_parenL,parenR:_parenR,comma:_comma,semi:_semi,colon:_colon,dot:_dot,question:_question,slash:_slash,eq:_eq,name:_name,eof:_eof,num:_num,regexp:_regexp,string:_string};for(var kw in keywordTypes) exports.tokTypes["_" + kw] = keywordTypes[kw]; // This is a trick taken from Esprima. It turns out that, on
						// non-Chrome browsers, to check whether a string is in a set, a
						// predicate containing a big ugly `switch` statement is faster than
						// a regular expression, and on Chrome the two are about on par.
						// This function uses `eval` (non-lexical) to produce such a
						// predicate from a space-separated string of words.
						//
						// It starts by sorting the words by length.
						function makePredicate(words){words = words.split(" ");var f="",cats=[];out: for(var i=0;i < words.length;++i) {for(var j=0;j < cats.length;++j) if(cats[j][0].length == words[i].length){cats[j].push(words[i]);continue out;}cats.push([words[i]]);}function compareTo(arr){if(arr.length == 1)return f += "return str === " + JSON.stringify(arr[0]) + ";";f += "switch(str){";for(var i=0;i < arr.length;++i) f += "case " + JSON.stringify(arr[i]) + ":";f += "return true}return false;";} // When there are more than three length categories, an outer
						// switch first dispatches on the lengths, to save on comparisons.
						if(cats.length > 3){cats.sort(function(a,b){return b.length - a.length;});f += "switch(str.length){";for(var i=0;i < cats.length;++i) {var cat=cats[i];f += "case " + cat[0].length + ":";compareTo(cat);}f += "}"; // Otherwise, simply generate a flat `switch` statement.
						}else {compareTo(words);}return new Function("str",f);} // The ECMAScript 3 reserved word list.
						var isReservedWord3=makePredicate("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"); // ECMAScript 5 reserved words.
						var isReservedWord5=makePredicate("class enum extends super const export import"); // The additional reserved words in strict mode.
						var isStrictReservedWord=makePredicate("implements interface let package private protected public static yield"); // The forbidden variable names in strict mode.
						var isStrictBadIdWord=makePredicate("eval arguments"); // And the keywords.
						var isKeyword=makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"); // ## Character categories
						// Big ugly regular expressions that match characters in the
						// whitespace, identifier, and identifier-start categories. These
						// are only applied when a character is found to actually have a
						// code point above 128.
						var nonASCIIwhitespace=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;var nonASCIIidentifierStartChars="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";var nonASCIIidentifierChars="\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";var nonASCIIidentifierStart=new RegExp("[" + nonASCIIidentifierStartChars + "]");var nonASCIIidentifier=new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]"); // Whether a single character denotes a newline.
						var newline=/[\n\r\u2028\u2029]/; // Matches a whole line break (where CRLF is considered a single
						// line break). Used to count lines.
						var lineBreak=/\r\n|[\n\r\u2028\u2029]/g; // Test whether a given character code starts an identifier.
						var isIdentifierStart=exports.isIdentifierStart = function(code){if(code < 65)return code === 36;if(code < 91)return true;if(code < 97)return code === 95;if(code < 123)return true;return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));}; // Test whether a given character is part of an identifier.
						var isIdentifierChar=exports.isIdentifierChar = function(code){if(code < 48)return code === 36;if(code < 58)return true;if(code < 65)return false;if(code < 91)return true;if(code < 97)return code === 95;if(code < 123)return true;return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));}; // ## Tokenizer
						// These are used when `options.locations` is on, for the
						// `tokStartLoc` and `tokEndLoc` properties.
						function line_loc_t(){this.line = tokCurLine;this.column = tokPos - tokLineStart;} // Reset the token state. Used at the start of a parse.
						function initTokenState(){tokCurLine = 1;tokPos = tokLineStart = 0;tokRegexpAllowed = true;skipSpace();} // Called at the end of every token. Sets `tokEnd`, `tokVal`, and
						// `tokRegexpAllowed`, and skips the space after the token, so that
						// the next one's `tokStart` will point at the right position.
						function finishToken(type,val){tokEnd = tokPos;if(options.locations)tokEndLoc = new line_loc_t();tokType = type;skipSpace();tokVal = val;tokRegexpAllowed = type.beforeExpr;}function skipBlockComment(){var startLoc=options.onComment && options.locations && new line_loc_t();var start=tokPos,end=input.indexOf("*/",tokPos += 2);if(end === -1)raise(tokPos - 2,"Unterminated comment");tokPos = end + 2;if(options.locations){lineBreak.lastIndex = start;var match;while((match = lineBreak.exec(input)) && match.index < tokPos) {++tokCurLine;tokLineStart = match.index + match[0].length;}}if(options.onComment)options.onComment(true,input.slice(start + 2,end),start,tokPos,startLoc,options.locations && new line_loc_t());}function skipLineComment(){var start=tokPos;var startLoc=options.onComment && options.locations && new line_loc_t();var ch=input.charCodeAt(tokPos += 2);while(tokPos < inputLen && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {++tokPos;ch = input.charCodeAt(tokPos);}if(options.onComment)options.onComment(false,input.slice(start + 2,tokPos),start,tokPos,startLoc,options.locations && new line_loc_t());} // Called at the start of the parse and after every token. Skips
						// whitespace and comments, and.
						function skipSpace(){while(tokPos < inputLen) {var ch=input.charCodeAt(tokPos);if(ch === 32){ // ' '
						++tokPos;}else if(ch === 13){++tokPos;var next=input.charCodeAt(tokPos);if(next === 10){++tokPos;}if(options.locations){++tokCurLine;tokLineStart = tokPos;}}else if(ch === 10 || ch === 8232 || ch === 8233){++tokPos;if(options.locations){++tokCurLine;tokLineStart = tokPos;}}else if(ch > 8 && ch < 14){++tokPos;}else if(ch === 47){ // '/'
						var next=input.charCodeAt(tokPos + 1);if(next === 42){ // '*'
						skipBlockComment();}else if(next === 47){ // '/'
						skipLineComment();}else break;}else if(ch === 160){ // '\xa0'
						++tokPos;}else if(ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))){++tokPos;}else {break;}}} // ### Token reading
						// This is the function that is called to fetch the next token. It
						// is somewhat obscure, because it works in character codes rather
						// than characters, and because operator parsing has been inlined
						// into it.
						//
						// All in the name of speed.
						//
						// The `forceRegexp` parameter is used in the one case where the
						// `tokRegexpAllowed` trick does not work. See `parseStatement`.
						function readToken_dot(){var next=input.charCodeAt(tokPos + 1);if(next >= 48 && next <= 57)return readNumber(true);++tokPos;return finishToken(_dot);}function readToken_slash(){ // '/'
						var next=input.charCodeAt(tokPos + 1);if(tokRegexpAllowed){++tokPos;return readRegexp();}if(next === 61)return finishOp(_assign,2);return finishOp(_slash,1);}function readToken_mult_modulo(){ // '%*'
						var next=input.charCodeAt(tokPos + 1);if(next === 61)return finishOp(_assign,2);return finishOp(_multiplyModulo,1);}function readToken_pipe_amp(code){ // '|&'
						var next=input.charCodeAt(tokPos + 1);if(next === code)return finishOp(code === 124?_logicalOR:_logicalAND,2);if(next === 61)return finishOp(_assign,2);return finishOp(code === 124?_bitwiseOR:_bitwiseAND,1);}function readToken_caret(){ // '^'
						var next=input.charCodeAt(tokPos + 1);if(next === 61)return finishOp(_assign,2);return finishOp(_bitwiseXOR,1);}function readToken_plus_min(code){ // '+-'
						var next=input.charCodeAt(tokPos + 1);if(next === code){if(next == 45 && input.charCodeAt(tokPos + 2) == 62 && newline.test(input.slice(lastEnd,tokPos))){ // A `-->` line comment
						tokPos += 3;skipLineComment();skipSpace();return readToken();}return finishOp(_incDec,2);}if(next === 61)return finishOp(_assign,2);return finishOp(_plusMin,1);}function readToken_lt_gt(code){ // '<>'
						var next=input.charCodeAt(tokPos + 1);var size=1;if(next === code){size = code === 62 && input.charCodeAt(tokPos + 2) === 62?3:2;if(input.charCodeAt(tokPos + size) === 61)return finishOp(_assign,size + 1);return finishOp(_bitShift,size);}if(next == 33 && code == 60 && input.charCodeAt(tokPos + 2) == 45 && input.charCodeAt(tokPos + 3) == 45){ // `<!--`, an XML-style comment that should be interpreted as a line comment
						tokPos += 4;skipLineComment();skipSpace();return readToken();}if(next === 61)size = input.charCodeAt(tokPos + 2) === 61?3:2;return finishOp(_relational,size);}function readToken_eq_excl(code){ // '=!'
						var next=input.charCodeAt(tokPos + 1);if(next === 61)return finishOp(_equality,input.charCodeAt(tokPos + 2) === 61?3:2);return finishOp(code === 61?_eq:_prefix,1);}function getTokenFromCode(code){switch(code){ // The interpretation of a dot depends on whether it is followed
						// by a digit.
						case 46: // '.'
						return readToken_dot(); // Punctuation tokens.
						case 40:++tokPos;return finishToken(_parenL);case 41:++tokPos;return finishToken(_parenR);case 59:++tokPos;return finishToken(_semi);case 44:++tokPos;return finishToken(_comma);case 91:++tokPos;return finishToken(_bracketL);case 93:++tokPos;return finishToken(_bracketR);case 123:++tokPos;return finishToken(_braceL);case 125:++tokPos;return finishToken(_braceR);case 58:++tokPos;return finishToken(_colon);case 63:++tokPos;return finishToken(_question); // '0x' is a hexadecimal number.
						case 48: // '0'
						var next=input.charCodeAt(tokPos + 1);if(next === 120 || next === 88)return readHexNumber(); // Anything else beginning with a digit is an integer, octal
						// number, or float.
						case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57: // 1-9
						return readNumber(false); // Quotes produce strings.
						case 34:case 39: // '"', "'"
						return readString(code); // Operators are parsed inline in tiny state machines. '=' (61) is
						// often referred to. `finishOp` simply skips the amount of
						// characters it is given as second argument, and returns a token
						// of the type given by its first argument.
						case 47: // '/'
						return readToken_slash(code);case 37:case 42: // '%*'
						return readToken_mult_modulo();case 124:case 38: // '|&'
						return readToken_pipe_amp(code);case 94: // '^'
						return readToken_caret();case 43:case 45: // '+-'
						return readToken_plus_min(code);case 60:case 62: // '<>'
						return readToken_lt_gt(code);case 61:case 33: // '=!'
						return readToken_eq_excl(code);case 126: // '~'
						return finishOp(_prefix,1);}return false;}function readToken(forceRegexp){if(!forceRegexp)tokStart = tokPos;else tokPos = tokStart + 1;if(options.locations)tokStartLoc = new line_loc_t();if(forceRegexp)return readRegexp();if(tokPos >= inputLen)return finishToken(_eof);var code=input.charCodeAt(tokPos); // Identifier or keyword. '\uXXXX' sequences are allowed in
						// identifiers, so '\' also dispatches to that.
						if(isIdentifierStart(code) || code === 92 /* '\' */)return readWord();var tok=getTokenFromCode(code);if(tok === false){ // If we are here, we either found a non-ASCII identifier
						// character, or something that's entirely disallowed.
						var ch=String.fromCharCode(code);if(ch === "\\" || nonASCIIidentifierStart.test(ch))return readWord();raise(tokPos,"Unexpected character '" + ch + "'");}return tok;}function finishOp(type,size){var str=input.slice(tokPos,tokPos + size);tokPos += size;finishToken(type,str);} // Parse a regular expression. Some context-awareness is necessary,
						// since a '/' inside a '[]' set does not end the expression.
						function readRegexp(){var content="",escaped,inClass,start=tokPos;for(;;) {if(tokPos >= inputLen)raise(start,"Unterminated regular expression");var ch=input.charAt(tokPos);if(newline.test(ch))raise(start,"Unterminated regular expression");if(!escaped){if(ch === "[")inClass = true;else if(ch === "]" && inClass)inClass = false;else if(ch === "/" && !inClass)break;escaped = ch === "\\";}else escaped = false;++tokPos;}var content=input.slice(start,tokPos);++tokPos; // Need to use `readWord1` because '\uXXXX' sequences are allowed
						// here (don't ask).
						var mods=readWord1();if(mods && !/^[gmsiy]*$/.test(mods))raise(start,"Invalid regexp flag");return finishToken(_regexp,new RegExp(content,mods));} // Read an integer in the given radix. Return null if zero digits
						// were read, the integer value otherwise. When `len` is given, this
						// will return `null` unless the integer has exactly `len` digits.
						function readInt(radix,len){var start=tokPos,total=0;for(var i=0,e=len == null?Infinity:len;i < e;++i) {var code=input.charCodeAt(tokPos),val;if(code >= 97)val = code - 97 + 10; // a
						else if(code >= 65)val = code - 65 + 10; // A
						else if(code >= 48 && code <= 57)val = code - 48; // 0-9
						else val = Infinity;if(val >= radix)break;++tokPos;total = total * radix + val;}if(tokPos === start || len != null && tokPos - start !== len)return null;return total;}function readHexNumber(){tokPos += 2; // 0x
						var val=readInt(16);if(val == null)raise(tokStart + 2,"Expected hexadecimal number");if(isIdentifierStart(input.charCodeAt(tokPos)))raise(tokPos,"Identifier directly after number");return finishToken(_num,val);} // Read an integer, octal integer, or floating-point number.
						function readNumber(startsWithDot){var start=tokPos,isFloat=false,octal=input.charCodeAt(tokPos) === 48;if(!startsWithDot && readInt(10) === null)raise(start,"Invalid number");if(input.charCodeAt(tokPos) === 46){++tokPos;readInt(10);isFloat = true;}var next=input.charCodeAt(tokPos);if(next === 69 || next === 101){ // 'eE'
						next = input.charCodeAt(++tokPos);if(next === 43 || next === 45)++tokPos; // '+-'
						if(readInt(10) === null)raise(start,"Invalid number");isFloat = true;}if(isIdentifierStart(input.charCodeAt(tokPos)))raise(tokPos,"Identifier directly after number");var str=input.slice(start,tokPos),val;if(isFloat)val = parseFloat(str);else if(!octal || str.length === 1)val = parseInt(str,10);else if(/[89]/.test(str) || strict)raise(start,"Invalid number");else val = parseInt(str,8);return finishToken(_num,val);} // Read a string value, interpreting backslash-escapes.
						function readString(quote){tokPos++;var out="";for(;;) {if(tokPos >= inputLen)raise(tokStart,"Unterminated string constant");var ch=input.charCodeAt(tokPos);if(ch === quote){++tokPos;return finishToken(_string,out);}if(ch === 92){ // '\'
						ch = input.charCodeAt(++tokPos);var octal=/^[0-7]+/.exec(input.slice(tokPos,tokPos + 3));if(octal)octal = octal[0];while(octal && parseInt(octal,8) > 255) octal = octal.slice(0,-1);if(octal === "0")octal = null;++tokPos;if(octal){if(strict)raise(tokPos - 2,"Octal literal in strict mode");out += String.fromCharCode(parseInt(octal,8));tokPos += octal.length - 1;}else {switch(ch){case 110:out += "\n";break; // 'n' -> '\n'
						case 114:out += "\r";break; // 'r' -> '\r'
						case 120:out += String.fromCharCode(readHexChar(2));break; // 'x'
						case 117:out += String.fromCharCode(readHexChar(4));break; // 'u'
						case 85:out += String.fromCharCode(readHexChar(8));break; // 'U'
						case 116:out += "\t";break; // 't' -> '\t'
						case 98:out += "\b";break; // 'b' -> '\b'
						case 118:out += "\u000b";break; // 'v' -> '\u000b'
						case 102:out += "\f";break; // 'f' -> '\f'
						case 48:out += "\0";break; // 0 -> '\0'
						case 13:if(input.charCodeAt(tokPos) === 10)++tokPos; // '\r\n'
						case 10: // ' \n'
						if(options.locations){tokLineStart = tokPos;++tokCurLine;}break;default:out += String.fromCharCode(ch);break;}}}else {if(ch === 13 || ch === 10 || ch === 8232 || ch === 8233)raise(tokStart,"Unterminated string constant");out += String.fromCharCode(ch); // '\'
						++tokPos;}}} // Used to read character escape sequences ('\x', '\u', '\U').
						function readHexChar(len){var n=readInt(16,len);if(n === null)raise(tokStart,"Bad character escape sequence");return n;} // Used to signal to callers of `readWord1` whether the word
						// contained any escape sequences. This is needed because words with
						// escape sequences must not be interpreted as keywords.
						var containsEsc; // Read an identifier, and return it as a string. Sets `containsEsc`
						// to whether the word contained a '\u' escape.
						//
						// Only builds up the word character-by-character when it actually
						// containeds an escape, as a micro-optimization.
						function readWord1(){containsEsc = false;var word,first=true,start=tokPos;for(;;) {var ch=input.charCodeAt(tokPos);if(isIdentifierChar(ch)){if(containsEsc)word += input.charAt(tokPos);++tokPos;}else if(ch === 92){ // "\"
						if(!containsEsc)word = input.slice(start,tokPos);containsEsc = true;if(input.charCodeAt(++tokPos) != 117) // "u"
						raise(tokPos,"Expecting Unicode escape sequence \\uXXXX");++tokPos;var esc=readHexChar(4);var escStr=String.fromCharCode(esc);if(!escStr)raise(tokPos - 1,"Invalid Unicode escape");if(!(first?isIdentifierStart(esc):isIdentifierChar(esc)))raise(tokPos - 4,"Invalid Unicode escape");word += input.substr(tokPos - 6,6);}else {break;}first = false;}return containsEsc?word:input.slice(start,tokPos);} // Read an identifier or keyword token. Will check for reserved
						// words when necessary.
						function readWord(){var word=readWord1();var type=_name;if(!containsEsc){if(isKeyword(word))type = keywordTypes[word];else if(options.forbidReserved && (options.ecmaVersion === 3?isReservedWord3:isReservedWord5)(word) || strict && isStrictReservedWord(word))raise(tokStart,"The keyword '" + word + "' is reserved");}return finishToken(type,word);} // ## Parser
						// A recursive descent parser operates by defining functions for all
						// syntactic elements, and recursively calling those, each function
						// advancing the input stream and returning an AST node. Precedence
						// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
						// instead of `(!x)[1]` is handled by the fact that the parser
						// function that parses unary prefix operators is called first, and
						// in turn calls the function that parses `[]` subscripts  that
						// way, it'll receive the node for `x[1]` already parsed, and wraps
						// *that* in the unary operator node.
						//
						// Acorn uses an [operator precedence parser][opp] to handle binary
						// operator precedence, because it is much more compact than using
						// the technique outlined above, which uses different, nesting
						// functions to specify precedence, for all of the ten binary
						// precedence levels that JavaScript defines.
						//
						// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser
						// ### Parser utilities
						// Continue to the next token.
						function next(){lastStart = tokStart;lastEnd = tokEnd;lastEndLoc = tokEndLoc;readToken();} // Enter strict mode. Re-reads the next token to please pedantic
						// tests ("use strict"; 010; -- should fail).
						function setStrict(strct){strict = strct;tokPos = lastEnd;if(options.locations){while(tokPos < tokLineStart) {tokLineStart = input.lastIndexOf("\n",tokLineStart - 2) + 1;--tokCurLine;}}skipSpace();readToken();} // Start an AST node, attaching a start offset.
						function node_t(){this.type = null;this.start = tokStart;this.end = null;}function node_loc_t(){this.start = tokStartLoc;this.end = null;if(sourceFile !== null)this.source = sourceFile;}function startNode(){var node=new node_t();if(options.locations)node.loc = new node_loc_t();if(options.directSourceFile)node.sourceFile = options.directSourceFile;if(options.ranges)node.range = [tokStart,0];return node;} // Start a node whose start offset information should be based on
						// the start of another node. For example, a binary operator node is
						// only started after its left-hand side has already been parsed.
						function startNodeFrom(other){var node=new node_t();node.start = other.start;if(options.locations){node.loc = new node_loc_t();node.loc.start = other.loc.start;}if(options.ranges)node.range = [other.range[0],0];return node;} // Finish an AST node, adding `type` and `end` properties.
						function finishNode(node,type){node.type = type;node.end = lastEnd;if(options.locations)node.loc.end = lastEndLoc;if(options.ranges)node.range[1] = lastEnd;return node;} // Test whether a statement node is the string literal `"use strict"`.
						function isUseStrict(stmt){return false;} // Predicate that tests whether the next token is of the given
						// type, and if yes, consumes it as a side effect.
						function eat(type){if(tokType === type){next();return true;}} // Test whether a semicolon can be inserted at the current position.
						function canInsertSemicolon(){return !options.strictSemicolons && (tokType === _eof || tokType === _braceR || newline.test(input.slice(lastEnd,tokStart)));} // Consume a semicolon, or, failing that, see if we are allowed to
						// pretend that there is a semicolon at this position.
						function semicolon(){if(!eat(_semi) && !canInsertSemicolon())unexpected();} // Expect a token of a given type. If found, consume it, otherwise,
						// raise an unexpected token error.
						function expect(type){if(tokType === type)next();else unexpected();} // Raise an unexpected token error.
						function unexpected(){raise(tokStart,"Unexpected token");} // Verify that a node is an lval  something that can be assigned
						// to.
						function checkLVal(expr){if(expr.type !== "Identifier" && expr.type !== "MemberExpression")raise(expr.start,"Assigning to rvalue");if(strict && expr.type === "Identifier" && isStrictBadIdWord(expr.name))raise(expr.start,"Assigning to " + expr.name + " in strict mode");} // ### Statement parsing
						// Parse a program. Initializes the parser, reads any number of
						// statements, and wraps them in a Program node.  Optionally takes a
						// `program` argument.  If present, the statements will be appended
						// to its body instead of creating a new node.
						function parseTopLevel(program){lastStart = lastEnd = tokPos;if(options.locations)lastEndLoc = new line_loc_t();inFunction = strict = null;labels = [];readToken();var node=program || startNode(),first=true;if(!program)node.body = [];while(tokType !== _eof) {var stmt=parseStatement();node.body.push(stmt);if(first && isUseStrict(stmt))setStrict(true);first = false;}return finishNode(node,"Program");}var loopLabel={kind:"loop"},switchLabel={kind:"switch"}; // Parse a single statement.
						//
						// If expecting a statement and finding a slash operator, parse a
						// regular expression literal. This is to handle cases like
						// `if (foo) /blah/.exec(foo);`, where looking at the previous token
						// does not help.
						function parseStatement(){if(tokType === _slash || tokType === _assign && tokVal == "/=")readToken(true);var starttype=tokType,node=startNode(); // Most types of statements are recognized by the keyword they
						// start with. Many are trivial to parse, some require a bit of
						// complexity.
						switch(starttype){case _break:case _continue:next();var isBreak=starttype === _break;if(eat(_semi) || canInsertSemicolon())node.label = null;else if(tokType !== _name)unexpected();else {node.label = parseIdent();semicolon();} // Verify that there is an actual destination to break or
						// continue to.
						for(var i=0;i < labels.length;++i) {var lab=labels[i];if(node.label == null || lab.name === node.label.name){if(lab.kind != null && (isBreak || lab.kind === "loop"))break;if(node.label && isBreak)break;}}if(i === labels.length)raise(node.start,"Unsyntactic " + starttype.keyword);return finishNode(node,isBreak?"BreakStatement":"ContinueStatement");case _debugger:next();semicolon();return finishNode(node,"DebuggerStatement");case _do:next();labels.push(loopLabel);node.body = parseStatement();labels.pop();expect(_while);node.test = parseParenExpression();semicolon();return finishNode(node,"DoWhileStatement"); // Disambiguating between a `for` and a `for`/`in` loop is
						// non-trivial. Basically, we have to parse the init `var`
						// statement or expression, disallowing the `in` operator (see
						// the second parameter to `parseExpression`), and then check
						// whether the next token is `in`. When there is no init part
						// (semicolon immediately after the opening parenthesis), it is
						// a regular `for` loop.
						case _for:next();labels.push(loopLabel);expect(_parenL);if(tokType === _semi)return parseFor(node,null);if(tokType === _var){var init=startNode();next();parseVar(init,true);finishNode(init,"VariableDeclaration");if(init.declarations.length === 1 && eat(_in))return parseForIn(node,init);return parseFor(node,init);}var init=parseExpression(false,true);if(eat(_in)){checkLVal(init);return parseForIn(node,init);}return parseFor(node,init);case _function:next();return parseFunction(node,true);case _if:next();node.test = parseParenExpression();node.consequent = parseStatement();node.alternate = eat(_else)?parseStatement():null;return finishNode(node,"IfStatement");case _return:if(!inFunction)raise(tokStart,"'return' outside of function");next(); // In `return` (and `break`/`continue`), the keywords with
						// optional arguments, we eagerly look for a semicolon or the
						// possibility to insert one.
						if(eat(_semi) || canInsertSemicolon())node.argument = null;else {node.argument = parseExpression();semicolon();}return finishNode(node,"ReturnStatement");case _switch:next();node.discriminant = parseParenExpression();node.cases = [];expect(_braceL);labels.push(switchLabel); // Statements under must be grouped (by label) in SwitchCase
						// nodes. `cur` is used to keep the node that we are currently
						// adding statements to.
						for(var cur,sawDefault;tokType != _braceR;) {if(tokType === _case || tokType === _default){var isCase=tokType === _case;if(cur)finishNode(cur,"SwitchCase");node.cases.push(cur = startNode());cur.consequent = [];next();if(isCase)cur.test = parseExpression();else {if(sawDefault)raise(lastStart,"Multiple default clauses");sawDefault = true;cur.test = null;}expect(_colon);}else {if(!cur)unexpected();cur.consequent.push(parseStatement());}}if(cur)finishNode(cur,"SwitchCase");next(); // Closing brace
						labels.pop();return finishNode(node,"SwitchStatement");case _throw:next();if(newline.test(input.slice(lastEnd,tokStart)))raise(lastEnd,"Illegal newline after throw");node.argument = parseExpression();semicolon();return finishNode(node,"ThrowStatement");case _try:next();node.block = parseBlock();node.handler = null;if(tokType === _catch){var clause=startNode();next();expect(_parenL);clause.param = parseIdent();if(strict && isStrictBadIdWord(clause.param.name))raise(clause.param.start,"Binding " + clause.param.name + " in strict mode");expect(_parenR);clause.guard = null;clause.body = parseBlock();node.handler = finishNode(clause,"CatchClause");}node.guardedHandlers = empty;node.finalizer = eat(_finally)?parseBlock():null;if(!node.handler && !node.finalizer)raise(node.start,"Missing catch or finally clause");return finishNode(node,"TryStatement");case _var:next();parseVar(node);semicolon();return finishNode(node,"VariableDeclaration");case _while:next();node.test = parseParenExpression();labels.push(loopLabel);node.body = parseStatement();labels.pop();return finishNode(node,"WhileStatement");case _with:if(strict)raise(tokStart,"'with' in strict mode");next();node.object = parseParenExpression();node.body = parseStatement();return finishNode(node,"WithStatement");case _braceL:return parseBlock();case _semi:next();return finishNode(node,"EmptyStatement"); // If the statement does not start with a statement keyword or a
						// brace, it's an ExpressionStatement or LabeledStatement. We
						// simply start parsing an expression, and afterwards, if the
						// next token is a colon and the expression was a simple
						// Identifier node, we switch to interpreting it as a label.
						default:var maybeName=tokVal,expr=parseExpression();if(starttype === _name && expr.type === "Identifier" && eat(_colon)){for(var i=0;i < labels.length;++i) if(labels[i].name === maybeName)raise(expr.start,"Label '" + maybeName + "' is already declared");var kind=tokType.isLoop?"loop":tokType === _switch?"switch":null;labels.push({name:maybeName,kind:kind});node.body = parseStatement();labels.pop();node.label = expr;return finishNode(node,"LabeledStatement");}else {node.expression = expr;semicolon();return finishNode(node,"ExpressionStatement");}}} // Used for constructs like `switch` and `if` that insist on
						// parentheses around their expression.
						function parseParenExpression(){expect(_parenL);var val=parseExpression();expect(_parenR);return val;} // Parse a semicolon-enclosed block of statements, handling `"use
						// strict"` declarations when `allowStrict` is true (used for
						// function bodies).
						function parseBlock(allowStrict){var node=startNode(),first=true,strict=false,oldStrict;node.body = [];expect(_braceL);while(!eat(_braceR)) {var stmt=parseStatement();node.body.push(stmt);if(first && allowStrict && isUseStrict(stmt)){oldStrict = strict;setStrict(strict = true);}first = false;}if(strict && !oldStrict)setStrict(false);return finishNode(node,"BlockStatement");} // Parse a regular `for` loop. The disambiguation code in
						// `parseStatement` will already have parsed the init statement or
						// expression.
						function parseFor(node,init){node.init = init;expect(_semi);node.test = tokType === _semi?null:parseExpression();expect(_semi);node.update = tokType === _parenR?null:parseExpression();expect(_parenR);node.body = parseStatement();labels.pop();return finishNode(node,"ForStatement");} // Parse a `for`/`in` loop.
						function parseForIn(node,init){node.left = init;node.right = parseExpression();expect(_parenR);node.body = parseStatement();labels.pop();return finishNode(node,"ForInStatement");} // Parse a list of variable declarations.
						function parseVar(node,noIn){node.declarations = [];node.kind = "var";for(;;) {var decl=startNode();decl.id = parseIdent();if(strict && isStrictBadIdWord(decl.id.name))raise(decl.id.start,"Binding " + decl.id.name + " in strict mode");decl.init = eat(_eq)?parseExpression(true,noIn):null;node.declarations.push(finishNode(decl,"VariableDeclarator"));if(!eat(_comma))break;}return node;} // ### Expression parsing
						// These nest, from the most general expression type at the top to
						// 'atomic', nondivisible expression types at the bottom. Most of
						// the functions will simply let the function(s) below them parse,
						// and, *if* the syntactic construct they handle is present, wrap
						// the AST node that the inner parser gave them in another node.
						// Parse a full expression. The arguments are used to forbid comma
						// sequences (in argument lists, array literals, or object literals)
						// or the `in` operator (in for loops initalization expressions).
						function parseExpression(noComma,noIn){var expr=parseMaybeAssign(noIn);if(!noComma && tokType === _comma){var node=startNodeFrom(expr);node.expressions = [expr];while(eat(_comma)) node.expressions.push(parseMaybeAssign(noIn));return finishNode(node,"SequenceExpression");}return expr;} // Parse an assignment expression. This includes applications of
						// operators like `+=`.
						function parseMaybeAssign(noIn){var left=parseMaybeConditional(noIn);if(tokType.isAssign){var node=startNodeFrom(left);node.operator = tokVal;node.left = left;next();node.right = parseMaybeAssign(noIn);checkLVal(left);return finishNode(node,"AssignmentExpression");}return left;} // Parse a ternary conditional (`?:`) operator.
						function parseMaybeConditional(noIn){var expr=parseExprOps(noIn);if(eat(_question)){var node=startNodeFrom(expr);node.test = expr;node.consequent = parseExpression(true);expect(_colon);node.alternate = parseExpression(true,noIn);return finishNode(node,"ConditionalExpression");}return expr;} // Start the precedence parser.
						function parseExprOps(noIn){return parseExprOp(parseMaybeUnary(),-1,noIn);} // Parse binary operators with the operator precedence parsing
						// algorithm. `left` is the left-hand side of the operator.
						// `minPrec` provides context that allows the function to stop and
						// defer further parser to one of its callers when it encounters an
						// operator that has a lower precedence than the set it is parsing.
						function parseExprOp(left,minPrec,noIn){var prec=tokType.binop;if(prec != null && (!noIn || tokType !== _in)){if(prec > minPrec){var node=startNodeFrom(left);node.left = left;node.operator = tokVal;var op=tokType;next();node.right = parseExprOp(parseMaybeUnary(),prec,noIn);var exprNode=finishNode(node,op === _logicalOR || op === _logicalAND?"LogicalExpression":"BinaryExpression");return parseExprOp(exprNode,minPrec,noIn);}}return left;} // Parse unary operators, both prefix and postfix.
						function parseMaybeUnary(){if(tokType.prefix){var node=startNode(),update=tokType.isUpdate;node.operator = tokVal;node.prefix = true;tokRegexpAllowed = true;next();node.argument = parseMaybeUnary();if(update)checkLVal(node.argument);else if(strict && node.operator === "delete" && node.argument.type === "Identifier")raise(node.start,"Deleting local variable in strict mode");return finishNode(node,update?"UpdateExpression":"UnaryExpression");}var expr=parseExprSubscripts();while(tokType.postfix && !canInsertSemicolon()) {var node=startNodeFrom(expr);node.operator = tokVal;node.prefix = false;node.argument = expr;checkLVal(expr);next();expr = finishNode(node,"UpdateExpression");}return expr;} // Parse call, dot, and `[]`-subscript expressions.
						function parseExprSubscripts(){return parseSubscripts(parseExprAtom());}function parseSubscripts(base,noCalls){if(eat(_dot)){var node=startNodeFrom(base);node.object = base;node.property = parseIdent(true);node.computed = false;return parseSubscripts(finishNode(node,"MemberExpression"),noCalls);}else if(eat(_bracketL)){var node=startNodeFrom(base);node.object = base;node.property = parseExpression();node.computed = true;expect(_bracketR);return parseSubscripts(finishNode(node,"MemberExpression"),noCalls);}else if(!noCalls && eat(_parenL)){var node=startNodeFrom(base);node.callee = base;node.arguments = parseExprList(_parenR,false);return parseSubscripts(finishNode(node,"CallExpression"),noCalls);}else return base;} // Parse an atomic expression  either a single token that is an
						// expression, an expression started by a keyword like `function` or
						// `new`, or an expression wrapped in punctuation like `()`, `[]`,
						// or `{}`.
						function parseExprAtom(){switch(tokType){case _this:var node=startNode();next();return finishNode(node,"ThisExpression");case _name:return parseIdent();case _num:case _string:case _regexp:var node=startNode();node.value = tokVal;node.raw = input.slice(tokStart,tokEnd);next();return finishNode(node,"Literal");case _null:case _true:case _false:var node=startNode();node.value = tokType.atomValue;node.raw = tokType.keyword;next();return finishNode(node,"Literal");case _parenL:var tokStartLoc1=tokStartLoc,tokStart1=tokStart;next();var val=parseExpression();val.start = tokStart1;val.end = tokEnd;if(options.locations){val.loc.start = tokStartLoc1;val.loc.end = tokEndLoc;}if(options.ranges)val.range = [tokStart1,tokEnd];expect(_parenR);return val;case _bracketL:var node=startNode();next();node.elements = parseExprList(_bracketR,true,true);return finishNode(node,"ArrayExpression");case _braceL:return parseObj();case _function:var node=startNode();next();return parseFunction(node,false);case _new:return parseNew();default:unexpected();}} // New's precedence is slightly tricky. It must allow its argument
						// to be a `[]` or dot subscript expression, but not a call  at
						// least, not without wrapping it in parentheses. Thus, it uses the
						function parseNew(){var node=startNode();next();node.callee = parseSubscripts(parseExprAtom(),true);if(eat(_parenL))node.arguments = parseExprList(_parenR,false);else node.arguments = empty;return finishNode(node,"NewExpression");} // Parse an object literal.
						function parseObj(){var node=startNode(),first=true,sawGetSet=false;node.properties = [];next();while(!eat(_braceR)) {if(!first){expect(_comma);if(options.allowTrailingCommas && eat(_braceR))break;}else first = false;var prop={type:"Property",key:parsePropertyName()},isGetSet=false,kind;if(eat(_colon)){prop.value = parseExpression(true);kind = prop.kind = "init";}else if(options.ecmaVersion >= 5 && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set")){isGetSet = sawGetSet = true;kind = prop.kind = prop.key.name;prop.key = parsePropertyName();if(tokType !== _parenL)unexpected();prop.value = parseFunction(startNode(),false);}else unexpected(); // getters and setters are not allowed to clash  either with
						// each other or with an init property  and in strict mode,
						// init properties are also not allowed to be repeated.
						if(prop.key.type === "Identifier" && (strict || sawGetSet)){for(var i=0;i < node.properties.length;++i) {var other=node.properties[i];if(other.key.name === prop.key.name){var conflict=kind == other.kind || isGetSet && other.kind === "init" || kind === "init" && (other.kind === "get" || other.kind === "set");if(conflict && !strict && kind === "init" && other.kind === "init")conflict = false;if(conflict)raise(prop.key.start,"Redefinition of property");}}}node.properties.push(prop);}return finishNode(node,"ObjectExpression");}function parsePropertyName(){if(tokType === _num || tokType === _string)return parseExprAtom();return parseIdent(true);} // Parse a function declaration or literal (depending on the
						// `isStatement` parameter).
						function parseFunction(node,isStatement){if(tokType === _name)node.id = parseIdent();else if(isStatement)unexpected();else node.id = null;node.params = [];var first=true;expect(_parenL);while(!eat(_parenR)) {if(!first)expect(_comma);else first = false;node.params.push(parseIdent());} // Start a new scope with regard to labels and the `inFunction`
						// flag (restore them to their old value afterwards).
						var oldInFunc=inFunction,oldLabels=labels;inFunction = true;labels = [];node.body = parseBlock(true);inFunction = oldInFunc;labels = oldLabels; // If this is a strict mode function, verify that argument names
						// are not repeated, and it does not try to bind the words `eval`
						// or `arguments`.
						if(strict || node.body.body.length && isUseStrict(node.body.body[0])){for(var i=node.id?-1:0;i < node.params.length;++i) {var id=i < 0?node.id:node.params[i];if(isStrictReservedWord(id.name) || isStrictBadIdWord(id.name))raise(id.start,"Defining '" + id.name + "' in strict mode");if(i >= 0)for(var j=0;j < i;++j) if(id.name === node.params[j].name)raise(id.start,"Argument name clash in strict mode");}}return finishNode(node,isStatement?"FunctionDeclaration":"FunctionExpression");} // Parses a comma-separated list of expressions, and returns them as
						// an array. `close` is the token type that ends the list, and
						// `allowEmpty` can be turned on to allow subsequent commas with
						// nothing in between them to be parsed as `null` (which is needed
						// for array literals).
						function parseExprList(close,allowTrailingComma,allowEmpty){var elts=[],first=true;while(!eat(close)) {if(!first){expect(_comma);if(allowTrailingComma && options.allowTrailingCommas && eat(close))break;}else first = false;if(allowEmpty && tokType === _comma)elts.push(null);else elts.push(parseExpression(true));}return elts;} // Parse the next token as an identifier. If `liberal` is true (used
						// when parsing properties), it will also convert keywords into
						// identifiers.
						function parseIdent(liberal){var node=startNode();node.name = tokType === _name?tokVal:liberal && !options.forbidReserved && tokType.keyword || unexpected();tokRegexpAllowed = false;next();return finishNode(node,"Identifier");}});}).call(acornExports);JSParsingTools.parse = acornExports.parse || acornExports.acorn.parse; // ------------------------------------------
						// --------------- Code Gen -----------------
						var codeGetExports={};(function(exports){ /*
						         Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
						         Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
						         Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
						         Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
						         Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
						         Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
						         Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
						         Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
						         Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
						         Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
						         Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
						
						         Redistribution and use in source and binary forms, with or without
						         modification, are permitted provided that the following conditions are met:
						
						         * Redistributions of source code must retain the above copyright
						         notice, this list of conditions and the following disclaimer.
						         * Redistributions in binary form must reproduce the above copyright
						         notice, this list of conditions and the following disclaimer in the
						         documentation and/or other materials provided with the distribution.
						
						         THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
						         AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
						         IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
						         ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
						         DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
						         (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
						         LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
						         ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
						         (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
						         THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
						         */'use strict';var isArray,json,renumber,hexadecimal,quotes,escapeless,parentheses,semicolons,safeConcatenation,directive,extra,parse,FORMAT_MINIFY,FORMAT_DEFAULTS;var Syntax={AssignmentExpression:'AssignmentExpression',ArrayExpression:'ArrayExpression',ArrayPattern:'ArrayPattern',ArrowFunctionExpression:'ArrowFunctionExpression',BlockStatement:'BlockStatement',BinaryExpression:'BinaryExpression',BreakStatement:'BreakStatement',CallExpression:'CallExpression',CatchClause:'CatchClause',ClassBody:'ClassBody',ClassDeclaration:'ClassDeclaration',ClassExpression:'ClassExpression',ComprehensionBlock:'ComprehensionBlock',ComprehensionExpression:'ComprehensionExpression',ConditionalExpression:'ConditionalExpression',ContinueStatement:'ContinueStatement',DirectiveStatement:'DirectiveStatement',DoWhileStatement:'DoWhileStatement',DebuggerStatement:'DebuggerStatement',EmptyStatement:'EmptyStatement',ExportBatchSpecifier:'ExportBatchSpecifier',ExportDeclaration:'ExportDeclaration',ExportSpecifier:'ExportSpecifier',ExpressionStatement:'ExpressionStatement',ForStatement:'ForStatement',ForInStatement:'ForInStatement',ForOfStatement:'ForOfStatement',FunctionDeclaration:'FunctionDeclaration',FunctionExpression:'FunctionExpression',GeneratorExpression:'GeneratorExpression',Identifier:'Identifier',IfStatement:'IfStatement',ImportSpecifier:'ImportSpecifier',ImportDeclaration:'ImportDeclaration',Literal:'Literal',LabeledStatement:'LabeledStatement',LogicalExpression:'LogicalExpression',MemberExpression:'MemberExpression',MethodDefinition:'MethodDefinition',ModuleDeclaration:'ModuleDeclaration',NewExpression:'NewExpression',ObjectExpression:'ObjectExpression',ObjectPattern:'ObjectPattern',Program:'Program',Property:'Property',ReturnStatement:'ReturnStatement',SequenceExpression:'SequenceExpression',SpreadElement:'SpreadElement',SwitchStatement:'SwitchStatement',SwitchCase:'SwitchCase',TaggedTemplateExpression:'TaggedTemplateExpression',TemplateElement:'TemplateElement',TemplateLiteral:'TemplateLiteral',ThisExpression:'ThisExpression',ThrowStatement:'ThrowStatement',TryStatement:'TryStatement',UnaryExpression:'UnaryExpression',UpdateExpression:'UpdateExpression',VariableDeclaration:'VariableDeclaration',VariableDeclarator:'VariableDeclarator',WhileStatement:'WhileStatement',WithStatement:'WithStatement',YieldExpression:'YieldExpression'};exports.Syntax = Syntax;var Precedence={Sequence:0,Yield:1,Assignment:1,Conditional:2,ArrowFunction:2,LogicalOR:3,LogicalAND:4,BitwiseOR:5,BitwiseXOR:6,BitwiseAND:7,Equality:8,Relational:9,BitwiseSHIFT:10,Additive:11,Multiplicative:12,Unary:13,Postfix:14,Call:15,New:16,TaggedTemplate:17,Member:18,Primary:19};var BinaryPrecedence={'||':Precedence.LogicalOR,'&&':Precedence.LogicalAND,'|':Precedence.BitwiseOR,'^':Precedence.BitwiseXOR,'&':Precedence.BitwiseAND,'==':Precedence.Equality,'!=':Precedence.Equality,'===':Precedence.Equality,'!==':Precedence.Equality,'is':Precedence.Equality,'isnt':Precedence.Equality,'<':Precedence.Relational,'>':Precedence.Relational,'<=':Precedence.Relational,'>=':Precedence.Relational,'in':Precedence.Relational,'instanceof':Precedence.Relational,'<<':Precedence.BitwiseSHIFT,'>>':Precedence.BitwiseSHIFT,'>>>':Precedence.BitwiseSHIFT,'+':Precedence.Additive,'-':Precedence.Additive,'*':Precedence.Multiplicative,'%':Precedence.Multiplicative,'/':Precedence.Multiplicative};function getDefaultOptions(){ // default options
						return {indent:null,base:null,parse:null,format:{indent:{style:'    ',base:0},newline:'\n',space:' ',json:false,renumber:false,hexadecimal:false,quotes:'single',escapeless:false,compact:false,parentheses:true,semicolons:true,safeConcatenation:false},directive:false,raw:true,verbatim:null};} //-------------------------------------------------===------------------------------------------------------
						//                                            Lexical utils
						//-------------------------------------------------===------------------------------------------------------
						//Const
						var NON_ASCII_WHITESPACES=[0x1680,0x180E,0x2000,0x2001,0x2002,0x2003,0x2004,0x2005,0x2006,0x2007,0x2008,0x2009,0x200A,0x202F,0x205F,0x3000,0xFEFF]; //Regular expressions
						var NON_ASCII_IDENTIFIER_CHARACTERS_REGEXP=new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376' + '\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-' + '\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA' + '\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-' + '\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-' + '\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-' + '\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-' + '\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38' + '\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83' + '\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9' + '\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-' + '\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-' + '\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E' + '\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-' + '\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-' + '\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-' + '\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE' + '\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44' + '\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-' + '\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A' + '\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-' + '\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9' + '\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84' + '\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-' + '\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5' + '\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-' + '\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-' + '\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD' + '\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B' + '\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E' + '\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-' + '\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-' + '\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-' + '\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F' + '\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115' + '\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188' + '\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-' + '\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-' + '\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A' + '\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5' + '\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697' + '\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873' + '\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-' + '\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-' + '\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC' + '\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-' + '\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D' + '\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74' + '\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-' + '\uFFD7\uFFDA-\uFFDC]'); //Methods
						function isIdentifierCh(cp){if(cp < 0x80){return cp >= 97 && cp <= 122 ||  // a..z
						cp >= 65 && cp <= 90 ||  // A..Z
						cp >= 48 && cp <= 57 ||  // 0..9
						cp === 36 || cp === 95 ||  // $ (dollar) and _ (underscore)
						cp === 92; // \ (backslash)
						}var ch=String.fromCharCode(cp);return NON_ASCII_IDENTIFIER_CHARACTERS_REGEXP.test(ch);}function isLineTerminator(cp){return cp === 0x0A || cp === 0x0D || cp === 0x2028 || cp === 0x2029;}function isWhitespace(cp){return cp === 0x20 || cp === 0x09 || isLineTerminator(cp) || cp === 0x0B || cp === 0x0C || cp === 0xA0 || cp >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(cp) >= 0;}function isDecimalDigit(cp){return cp >= 48 && cp <= 57;}function stringRepeat(str,num){var result='';for(num |= 0;num > 0;num >>>= 1,str += str) {if(num & 1){result += str;}}return result;}isArray = Array.isArray;if(!isArray){isArray = function isArray(array){return Object.prototype.toString.call(array) === '[object Array]';};}function updateDeeply(target,override){var key,val;function isHashObject(target){return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);}for(key in override) {if(override.hasOwnProperty(key)){val = override[key];if(isHashObject(val)){if(isHashObject(target[key])){updateDeeply(target[key],val);}else {target[key] = updateDeeply({},val);}}else {target[key] = val;}}}return target;}function generateNumber(value){var result,point,temp,exponent,pos;if(value === 1 / 0){return json?'null':renumber?'1e400':'1e+400';}result = '' + value;if(!renumber || result.length < 3){return result;}point = result.indexOf('.'); //NOTE: 0x30 == '0'
						if(!json && result.charCodeAt(0) === 0x30 && point === 1){point = 0;result = result.slice(1);}temp = result;result = result.replace('e+','e');exponent = 0;if((pos = temp.indexOf('e')) > 0){exponent = +temp.slice(pos + 1);temp = temp.slice(0,pos);}if(point >= 0){exponent -= temp.length - point - 1;temp = +(temp.slice(0,point) + temp.slice(point + 1)) + '';}pos = 0; //NOTE: 0x30 == '0'
						while(temp.charCodeAt(temp.length + pos - 1) === 0x30) {--pos;}if(pos !== 0){exponent -= pos;temp = temp.slice(0,pos);}if(exponent !== 0){temp += 'e' + exponent;}if((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value){result = temp;}return result;} // Generate valid RegExp expression.
						// This function is based on https://github.com/Constellation/iv Engine
						function escapeRegExpCharacter(ch,previousIsBackslash){ // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
						if((ch & ~1) === 0x2028){return (previousIsBackslash?'u':'\\u') + (ch === 0x2028?'2028':'2029');}else if(ch === 10 || ch === 13){ // \n, \r
						return (previousIsBackslash?'':'\\') + (ch === 10?'n':'r');}return String.fromCharCode(ch);}function generateRegExp(reg){var match,result,flags,i,iz,ch,characterInBrack,previousIsBackslash;result = reg.toString();if(reg.source){ // extract flag from toString result
						match = result.match(/\/([^/]*)$/);if(!match){return result;}flags = match[1];result = '';characterInBrack = false;previousIsBackslash = false;for(i = 0,iz = reg.source.length;i < iz;++i) {ch = reg.source.charCodeAt(i);if(!previousIsBackslash){if(characterInBrack){if(ch === 93){ // ]
						characterInBrack = false;}}else {if(ch === 47){ // /
						result += '\\';}else if(ch === 91){ // [
						characterInBrack = true;}}result += escapeRegExpCharacter(ch,previousIsBackslash);previousIsBackslash = ch === 92; // \
						}else { // if new RegExp("\\\n') is provided, create /\n/
						result += escapeRegExpCharacter(ch,previousIsBackslash); // prevent like /\\[/]/
						previousIsBackslash = false;}}return '/' + result + '/' + flags;}return result;}function escapeAllowedCharacter(code,next){var hex,result='\\';switch(code){case 0x08: // \b
						result += 'b';break;case 0x0C: // \f
						result += 'f';break;case 0x09: // \t
						result += 't';break;default:hex = code.toString(16).toUpperCase();if(json || code > 0xFF){result += 'u' + '0000'.slice(hex.length) + hex;}else if(code === 0x0000 && !isDecimalDigit(next)){result += '0';}else if(code === 0x000B){ // \v
						result += 'x0B';}else {result += 'x' + '00'.slice(hex.length) + hex;}break;}return result;}function escapeDisallowedCharacter(code){var result='\\';switch(code){case 0x5C // \
						:result += '\\';break;case 0x0A // \n
						:result += 'n';break;case 0x0D // \r
						:result += 'r';break;case 0x2028:result += 'u2028';break;case 0x2029:result += 'u2029';break;}return result;}function escapeDirective(str){var i,iz,code,quote;quote = quotes === 'double'?'"':'\'';for(i = 0,iz = str.length;i < iz;++i) {code = str.charCodeAt(i);if(code === 0x27){ // '
						quote = '"';break;}else if(code === 0x22){ // "
						quote = '\'';break;}else if(code === 0x5C){ // \
						++i;}}return quote + str + quote;}function escapeString(str){var result='',i,len,code,singleQuotes=0,doubleQuotes=0,single,quote; //TODO http://jsperf.com/character-counting/8
						for(i = 0,len = str.length;i < len;++i) {code = str.charCodeAt(i);if(code === 0x27){ // '
						++singleQuotes;}else if(code === 0x22){ // "
						++doubleQuotes;}else if(code === 0x2F && json){ // /
						result += '\\';}else if(isLineTerminator(code) || code === 0x5C){ // \
						result += escapeDisallowedCharacter(code);continue;}else if(json && code < 0x20 ||  // SP
						!(json || escapeless || code >= 0x20 && code <= 0x7E)){ // SP, ~
						result += escapeAllowedCharacter(code,str.charCodeAt(i + 1));continue;}result += String.fromCharCode(code);}single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);quote = single?'\'':'"';if(!(single?singleQuotes:doubleQuotes)){return quote + result + quote;}str = result;result = quote;for(i = 0,len = str.length;i < len;++i) {code = str.charCodeAt(i);if(code === 0x27 && single || code === 0x22 && !single){ // ', "
						result += '\\';}result += String.fromCharCode(code);}return result + quote;}function join(l,r){if(!l.length)return r;if(!r.length)return l;var lCp=l.charCodeAt(l.length - 1),rCp=r.charCodeAt(0);if(isIdentifierCh(lCp) && isIdentifierCh(rCp) || lCp === rCp && (lCp === 0x2B || lCp === 0x2D) ||  // + +, - -
						lCp === 0x2F && rCp === 0x69){ // /re/ instanceof foo
						return l + _.space + r;}else if(isWhitespace(lCp) || isWhitespace(rCp))return l + r;return l + _.optSpace + r;}function shiftIndent(){var prevIndent=_.indent;_.indent += _.indentUnit;return prevIndent;}function adoptionPrefix($stmt){if($stmt.type === Syntax.BlockStatement)return _.optSpace;if($stmt.type === Syntax.EmptyStatement)return '';return _.newline + _.indent + _.indentUnit;}function adoptionSuffix($stmt){if($stmt.type === Syntax.BlockStatement)return _.optSpace;return _.newline + _.indent;} //Subentities generators
						function generateVerbatim($expr,settings){var verbatim=$expr[extra.verbatim],strVerbatim=typeof verbatim === 'string',precedence=!strVerbatim && verbatim.precedence !== void 0?verbatim.precedence:Precedence.Sequence,parenthesize=precedence < settings.precedence,content=strVerbatim?verbatim:verbatim.content,chunks=content.split(/\r\n|\n/),chunkCount=chunks.length;if(parenthesize)_.js += '(';_.js += chunks[0];for(var i=1;i < chunkCount;i++) _.js += _.newline + _.indent + chunks[i];if(parenthesize)_.js += ')';}function generateFunctionParams($node){var $params=$node.params,$rest=$node.rest,$defaults=$node.defaults,paramCount=$params.length,lastParamIdx=paramCount - 1,hasDefaults=!!$defaults,arrowFuncWithSingleParam=$node.type === Syntax.ArrowFunctionExpression && !$rest && (!hasDefaults || $defaults.length === 0) && paramCount === 1 && $params[0].type === Syntax.Identifier; //NOTE: arg => { } case
						if(arrowFuncWithSingleParam)_.js += $params[0].name;else {_.js += '(';for(var i=0;i < paramCount;++i) {var $param=$params[i];if(hasDefaults && $defaults[i]){var $fakeAssign={left:$param,right:$defaults[i],operator:'='};ExprGen.AssignmentExpression($fakeAssign,Preset.e4);}else {if($params[i].type === Syntax.Identifier)_.js += $param.name;else ExprGen[$param.type]($param,Preset.e4);}if(i !== lastParamIdx)_.js += ',' + _.optSpace;}if($rest){if(paramCount)_.js += ',' + _.optSpace;_.js += '...' + $rest.name;}_.js += ')';}}function generateFunctionBody($node){var $body=$node.body;generateFunctionParams($node);if($node.type === Syntax.ArrowFunctionExpression)_.js += _.optSpace + '=>';if($node.expression){_.js += _.optSpace;var exprJs=exprToJs($body,Preset.e4);if(exprJs.charAt(0) === '{')exprJs = '(' + exprJs + ')';_.js += exprJs;}else {_.js += adoptionPrefix($body);StmtGen[$body.type]($body,Preset.s8);}} //-------------------------------------------------===------------------------------------------------------
						//                                Syntactic entities generation presets
						//-------------------------------------------------===------------------------------------------------------
						var Preset={e1:function(allowIn){return {precedence:Precedence.Assignment,allowIn:allowIn,allowCall:true,allowUnparenthesizedNew:true};},e2:function(allowIn){return {precedence:Precedence.LogicalOR,allowIn:allowIn,allowCall:true,allowUnparenthesizedNew:true};},e3:{precedence:Precedence.Call,allowIn:true,allowCall:true,allowUnparenthesizedNew:false},e4:{precedence:Precedence.Assignment,allowIn:true,allowCall:true,allowUnparenthesizedNew:true},e5:{precedence:Precedence.Sequence,allowIn:true,allowCall:true,allowUnparenthesizedNew:true},e6:function(allowUnparenthesizedNew){return {precedence:Precedence.New,allowIn:true,allowCall:false,allowUnparenthesizedNew:allowUnparenthesizedNew};},e7:{precedence:Precedence.Unary,allowIn:true,allowCall:true,allowUnparenthesizedNew:true},e8:{precedence:Precedence.Postfix,allowIn:true,allowCall:true,allowUnparenthesizedNew:true},e9:{precedence:void 0,allowIn:true,allowCall:true,allowUnparenthesizedNew:true},e10:{precedence:Precedence.Call,allowIn:true,allowCall:true,allowUnparenthesizedNew:true},e11:function(allowCall){return {precedence:Precedence.Call,allowIn:true,allowCall:allowCall,allowUnparenthesizedNew:false};},e12:{precedence:Precedence.Primary,allowIn:false,allowCall:false,allowUnparenthesizedNew:true},e13:{precedence:Precedence.Primary,allowIn:true,allowCall:true,allowUnparenthesizedNew:true},e14:{precedence:Precedence.Sequence,allowIn:false,allowCall:true,allowUnparenthesizedNew:true},e15:function(allowCall){return {precedence:Precedence.Sequence,allowIn:true,allowCall:allowCall,allowUnparenthesizedNew:true};},e16:function(precedence,allowIn){return {precedence:precedence,allowIn:allowIn,allowCall:true,allowUnparenthesizedNew:true};},e17:function(allowIn){return {precedence:Precedence.Call,allowIn:allowIn,allowCall:true,allowUnparenthesizedNew:true};},e18:function(allowIn){return {precedence:Precedence.Assignment,allowIn:allowIn,allowCall:true,allowUnparenthesizedNew:true};},e19:{precedence:Precedence.Sequence,allowIn:true,allowCall:true,semicolonOptional:false},s1:function(functionBody,semicolonOptional){return {allowIn:true,functionBody:false,directiveContext:functionBody,semicolonOptional:semicolonOptional};},s2:{allowIn:true,functionBody:false,directiveContext:false,semicolonOptional:true},s3:function(allowIn){return {allowIn:allowIn,functionBody:false,directiveContext:false,semicolonOptional:false};},s4:function(semicolonOptional){return {allowIn:true,functionBody:false,directiveContext:false,semicolonOptional:semicolonOptional};},s5:function(semicolonOptional){return {allowIn:true,functionBody:false,directiveContext:true,semicolonOptional:semicolonOptional};},s6:{allowIn:false,functionBody:false,directiveContext:false,semicolonOptional:false},s7:{allowIn:true,functionBody:false,directiveContext:false,semicolonOptional:false},s8:{allowIn:true,functionBody:true,directiveContext:false,semicolonOptional:false}}; //-------------------------------------------------===-------------------------------------------------------
						//                                             Expressions
						//-------------------------------------------------===-------------------------------------------------------
						//Regular expressions
						var FLOATING_OR_OCTAL_REGEXP=/[.eExX]|^0[0-9]+/,LAST_DECIMAL_DIGIT_REGEXP=/[0-9]$/; //Common expression generators
						function generateLogicalOrBinaryExpression($expr,settings){var op=$expr.operator,precedence=BinaryPrecedence[$expr.operator],parenthesize=precedence < settings.precedence,allowIn=settings.allowIn || parenthesize,operandGenSettings=Preset.e16(precedence,allowIn),exprJs=exprToJs($expr.left,operandGenSettings);parenthesize |= op === 'in' && !allowIn;if(parenthesize)_.js += '('; // 0x2F = '/'
						if(exprJs.charCodeAt(exprJs.length - 1) === 0x2F && isIdentifierCh(op.charCodeAt(0)))exprJs = exprJs + _.space + op;else exprJs = join(exprJs,op);operandGenSettings.precedence++;var rightJs=exprToJs($expr.right,operandGenSettings); //NOTE: If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
						if(op === '/' && rightJs.charAt(0) === '/' || op.slice(-1) === '<' && rightJs.slice(0,3) === '!--')exprJs += _.space + rightJs;else exprJs = join(exprJs,rightJs);_.js += exprJs;if(parenthesize)_.js += ')';}function generateArrayPatternOrExpression($expr){var $elems=$expr.elements,elemCount=$elems.length;if(elemCount){var lastElemIdx=elemCount - 1,multiline=elemCount > 1,prevIndent=shiftIndent(),itemPrefix=_.newline + _.indent;_.js += '[';for(var i=0;i < elemCount;i++) {var $elem=$elems[i];if(multiline)_.js += itemPrefix;if($elem)ExprGen[$elem.type]($elem,Preset.e4);if(i !== lastElemIdx || !$elem)_.js += ',';}_.indent = prevIndent;if(multiline)_.js += _.newline + _.indent;_.js += ']';}else _.js += '[]';}function generateImportOrExportSpecifier($expr){_.js += $expr.id.name;if($expr.name)_.js += _.space + 'as' + _.space + $expr.name.name;}function generateGeneratorOrComprehensionExpression($expr){ //NOTE: GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
						var $blocks=$expr.blocks,$filter=$expr.filter,isGenerator=$expr.type === Syntax.GeneratorExpression,exprJs=isGenerator?'(':'[',bodyJs=exprToJs($expr.body,Preset.e4);if($blocks){var prevIndent=shiftIndent(),blockCount=$blocks.length;for(var i=0;i < blockCount;++i) {var blockJs=exprToJs($blocks[i],Preset.e5);exprJs = i > 0?join(exprJs,blockJs):exprJs + blockJs;}_.indent = prevIndent;}if($filter){var filterJs=exprToJs($filter,Preset.e5);exprJs = join(exprJs,'if' + _.optSpace);exprJs = join(exprJs,'(' + filterJs + ')');}exprJs = join(exprJs,bodyJs);exprJs += isGenerator?')':']';_.js += exprJs;} //Expression raw generator dictionary
						var ExprRawGen={SequenceExpression:function generateSequenceExpression($expr,settings){var $children=$expr.expressions,childrenCount=$children.length,lastChildIdx=childrenCount - 1,parenthesize=Precedence.Sequence < settings.precedence,exprGenSettings=Preset.e1(settings.allowIn || parenthesize);if(parenthesize)_.js += '(';for(var i=0;i < childrenCount;i++) {var $child=$children[i];ExprGen[$child.type]($child,exprGenSettings);if(i !== lastChildIdx)_.js += ',' + _.optSpace;}if(parenthesize)_.js += ')';},AssignmentExpression:function generateAssignmentExpression($expr,settings){var $left=$expr.left,$right=$expr.right,parenthesize=Precedence.Assignment < settings.precedence,allowIn=settings.allowIn || parenthesize;if(parenthesize)_.js += '(';ExprGen[$left.type]($left,Preset.e17(allowIn));_.js += _.optSpace + $expr.operator + _.optSpace;ExprGen[$right.type]($right,Preset.e18(allowIn));if(parenthesize)_.js += ')';},ArrowFunctionExpression:function generateArrowFunctionExpression($expr,settings){var parenthesize=Precedence.ArrowFunction < settings.precedence;if(parenthesize)_.js += '(';generateFunctionBody($expr);if(parenthesize)_.js += ')';},ConditionalExpression:function generateConditionalExpression($expr,settings){var $test=$expr.test,$conseq=$expr.consequent,$alt=$expr.alternate,parenthesize=Precedence.Conditional < settings.precedence,allowIn=settings.allowIn || parenthesize,testGenSettings=Preset.e2(allowIn),branchGenSettings=Preset.e1(allowIn);if(parenthesize)_.js += '(';ExprGen[$test.type]($test,testGenSettings);_.js += _.optSpace + '?' + _.optSpace;ExprGen[$conseq.type]($conseq,branchGenSettings);_.js += _.optSpace + ':' + _.optSpace;ExprGen[$alt.type]($alt,branchGenSettings);if(parenthesize)_.js += ')';},LogicalExpression:generateLogicalOrBinaryExpression,BinaryExpression:generateLogicalOrBinaryExpression,CallExpression:function generateCallExpression($expr,settings){var $callee=$expr.callee,$args=$expr['arguments'],argCount=$args.length,lastArgIdx=argCount - 1,parenthesize=!settings.allowCall || Precedence.Call < settings.precedence;if(parenthesize)_.js += '(';ExprGen[$callee.type]($callee,Preset.e3);_.js += '(';for(var i=0;i < argCount;++i) {var $arg=$args[i];ExprGen[$arg.type]($arg,Preset.e4);if(i !== lastArgIdx)_.js += ',' + _.optSpace;}_.js += ')';if(parenthesize)_.js += ')';},NewExpression:function generateNewExpression($expr,settings){var $args=$expr['arguments'],parenthesize=Precedence.New < settings.precedence,argCount=$args.length,lastArgIdx=argCount - 1,withCall=!settings.allowUnparenthesizedNew || parentheses || argCount > 0,calleeJs=exprToJs($expr.callee,Preset.e6(!withCall));if(parenthesize)_.js += '(';_.js += join('new',calleeJs);if(withCall){_.js += '(';for(var i=0;i < argCount;++i) {var $arg=$args[i];ExprGen[$arg.type]($arg,Preset.e4);if(i !== lastArgIdx)_.js += ',' + _.optSpace;}_.js += ')';}if(parenthesize)_.js += ')';},MemberExpression:function generateMemberExpression($expr,settings){var $obj=$expr.object,$prop=$expr.property,parenthesize=Precedence.Member < settings.precedence,isNumObj=!$expr.computed && $obj.type === Syntax.Literal && typeof $obj.value === 'number';if(parenthesize)_.js += '(';if(isNumObj){ //NOTE: When the following conditions are all true:
						//   1. No floating point
						//   2. Don't have exponents
						//   3. The last character is a decimal digit
						//   4. Not hexadecimal OR octal number literal
						// then we should add a floating point.
						var numJs=exprToJs($obj,Preset.e11(settings.allowCall)),withPoint=LAST_DECIMAL_DIGIT_REGEXP.test(numJs) && !FLOATING_OR_OCTAL_REGEXP.test(numJs);_.js += withPoint?numJs + '.':numJs;}else ExprGen[$obj.type]($obj,Preset.e11(settings.allowCall));if($expr.computed){_.js += '[';ExprGen[$prop.type]($prop,Preset.e15(settings.allowCall));_.js += ']';}else _.js += '.' + $prop.name;if(parenthesize)_.js += ')';},UnaryExpression:function generateUnaryExpression($expr,settings){var parenthesize=Precedence.Unary < settings.precedence,op=$expr.operator,argJs=exprToJs($expr.argument,Preset.e7);if(parenthesize)_.js += '('; //NOTE: delete, void, typeof
						// get `typeof []`, not `typeof[]`
						if(_.optSpace === '' || op.length > 2)_.js += join(op,argJs);else {_.js += op; //NOTE: Prevent inserting spaces between operator and argument if it is unnecessary
						// like, `!cond`
						var leftCp=op.charCodeAt(op.length - 1),rightCp=argJs.charCodeAt(0); // 0x2B = '+', 0x2D =  '-'
						if(leftCp === rightCp && (leftCp === 0x2B || leftCp === 0x2D) || isIdentifierCh(leftCp) && isIdentifierCh(rightCp)){_.js += _.space;}_.js += argJs;}if(parenthesize)_.js += ')';},YieldExpression:function generateYieldExpression($expr,settings){var $arg=$expr.argument,js=$expr.delegate?'yield*':'yield',parenthesize=Precedence.Yield < settings.precedence;if(parenthesize)_.js += '(';if($arg){var argJs=exprToJs($arg,Preset.e4);js = join(js,argJs);}_.js += js;if(parenthesize)_.js += ')';},UpdateExpression:function generateUpdateExpression($expr,settings){var $arg=$expr.argument,$op=$expr.operator,prefix=$expr.prefix,precedence=prefix?Precedence.Unary:Precedence.Postfix,parenthesize=precedence < settings.precedence;if(parenthesize)_.js += '(';if(prefix){_.js += $op;ExprGen[$arg.type]($arg,Preset.e8);}else {ExprGen[$arg.type]($arg,Preset.e8);_.js += $op;}if(parenthesize)_.js += ')';},FunctionExpression:function generateFunctionExpression($expr){var isGenerator=!!$expr.generator;_.js += isGenerator?'function*':'function';if($expr.id){_.js += isGenerator?_.optSpace:_.space;_.js += $expr.id.name;}else _.js += _.optSpace;generateFunctionBody($expr);},ExportBatchSpecifier:function generateExportBatchSpecifier(){_.js += '*';},ArrayPattern:generateArrayPatternOrExpression,ArrayExpression:generateArrayPatternOrExpression,ClassExpression:function generateClassExpression($expr){var $id=$expr.id,$super=$expr.superClass,$body=$expr.body,exprJs='class';if($id){var idJs=exprToJs($id,Preset.e9);exprJs = join(exprJs,idJs);}if($super){var superJs=exprToJs($super,Preset.e4);superJs = join('extends',superJs);exprJs = join(exprJs,superJs);}_.js += exprJs + _.optSpace;StmtGen[$body.type]($body,Preset.s2);},MethodDefinition:function generateMethodDefinition($expr){var exprJs=$expr['static']?'static' + _.optSpace:'',keyJs=exprToJs($expr.key,Preset.e5);if($expr.computed)keyJs = '[' + keyJs + ']';if($expr.kind === 'get' || $expr.kind === 'set'){keyJs = join($expr.kind,keyJs);_.js += join(exprJs,keyJs);}else {if($expr.value.generator)_.js += exprJs + '*' + keyJs;else _.js += join(exprJs,keyJs);}generateFunctionBody($expr.value);},Property:function generateProperty($expr){var $val=$expr.value,$kind=$expr.kind,keyJs=exprToJs($expr.key,Preset.e5);if($expr.computed)keyJs = '[' + keyJs + ']';if($kind === 'get' || $kind === 'set'){_.js += $kind + _.space + keyJs;generateFunctionBody($val);}else {if($expr.shorthand)_.js += keyJs;else if($expr.method){_.js += $val.generator?'*' + keyJs:keyJs;generateFunctionBody($val);}else {_.js += keyJs + ':' + _.optSpace;ExprGen[$val.type]($val,Preset.e4);}}},ObjectExpression:function generateObjectExpression($expr){var $props=$expr.properties,propCount=$props.length;if(propCount){var lastPropIdx=propCount - 1,prevIndent=shiftIndent();_.js += '{';for(var i=0;i < propCount;i++) {var $prop=$props[i],propType=$prop.type || Syntax.Property;_.js += _.newline + _.indent;ExprGen[propType]($prop,Preset.e5);if(i !== lastPropIdx)_.js += ',';}_.indent = prevIndent;_.js += _.newline + _.indent + '}';}else _.js += '{}';},ObjectPattern:function generateObjectPattern($expr){var $props=$expr.properties,propCount=$props.length;if(propCount){var lastPropIdx=propCount - 1,multiline=false;if(propCount === 1)multiline = $props[0].value.type !== Syntax.Identifier;else {for(var i=0;i < propCount;i++) {if(!$props[i].shorthand){multiline = true;break;}}}_.js += multiline?'{' + _.newline:'{';var prevIndent=shiftIndent(),propSuffix=',' + (multiline?_.newline:_.optSpace);for(var i=0;i < propCount;i++) {var $prop=$props[i];if(multiline)_.js += _.indent;ExprGen[$prop.type]($prop,Preset.e5);if(i !== lastPropIdx)_.js += propSuffix;}_.indent = prevIndent;_.js += multiline?_.newline + _.indent + '}':'}';}else _.js += '{}';},ThisExpression:function generateThisExpression(){_.js += 'this';},Identifier:function generateIdentifier($expr){_.js += $expr.name;},ImportSpecifier:generateImportOrExportSpecifier,ExportSpecifier:generateImportOrExportSpecifier,Literal:function generateLiteral($expr){if(extra.raw && $expr.raw !== void 0)_.js += $expr.raw;else if($expr.value === null)_.js += 'null';else {var valueType=typeof $expr.value;if(valueType === 'string')_.js += escapeString($expr.value);else if(valueType === 'number')_.js += generateNumber($expr.value);else if(valueType === 'boolean')_.js += $expr.value?'true':'false';else _.js += generateRegExp($expr.value);}},GeneratorExpression:generateGeneratorOrComprehensionExpression,ComprehensionExpression:generateGeneratorOrComprehensionExpression,ComprehensionBlock:function generateComprehensionBlock($expr){var $left=$expr.left,leftJs=void 0,rightJs=exprToJs($expr.right,Preset.e5);if($left.type === Syntax.VariableDeclaration)leftJs = $left.kind + _.space + stmtToJs($left.declarations[0],Preset.s6);else leftJs = exprToJs($left,Preset.e10);leftJs = join(leftJs,$expr.of?'of':'in');_.js += 'for' + _.optSpace + '(' + join(leftJs,rightJs) + ')';},SpreadElement:function generateSpreadElement($expr){var $arg=$expr.argument;_.js += '...';ExprGen[$arg.type]($arg,Preset.e4);},TaggedTemplateExpression:function generateTaggedTemplateExpression($expr,settings){var $tag=$expr.tag,$quasi=$expr.quasi,parenthesize=Precedence.TaggedTemplate < settings.precedence;if(parenthesize)_.js += '(';ExprGen[$tag.type]($tag,Preset.e11(settings.allowCall));ExprGen[$quasi.type]($quasi,Preset.e12);if(parenthesize)_.js += ')';},TemplateElement:function generateTemplateElement($expr){ //NOTE: Don't use "cooked". Since tagged template can use raw template
						// representation. So if we do so, it breaks the script semantics.
						_.js += $expr.value.raw;},TemplateLiteral:function generateTemplateLiteral($expr){var $quasis=$expr.quasis,$childExprs=$expr.expressions,quasiCount=$quasis.length,lastQuasiIdx=quasiCount - 1;_.js += '`';for(var i=0;i < quasiCount;++i) {var $quasi=$quasis[i];ExprGen[$quasi.type]($quasi,Preset.e13);if(i !== lastQuasiIdx){var $childExpr=$childExprs[i];_.js += '${' + _.optSpace;ExprGen[$childExpr.type]($childExpr,Preset.e5);_.js += _.optSpace + '}';}}_.js += '`';}}; //-------------------------------------------------===------------------------------------------------------
						//                                              Statements
						//-------------------------------------------------===------------------------------------------------------
						//Regular expressions
						var EXPR_STMT_UNALLOWED_EXPR_REGEXP=/^{|^class(?:\s|{)|^function(?:\s|\*|\()/; //Common statement generators
						function generateTryStatementHandlers(stmtJs,$finalizer,handlers){var handlerCount=handlers.length,lastHandlerIdx=handlerCount - 1;for(var i=0;i < handlerCount;++i) {var handlerJs=stmtToJs(handlers[i],Preset.s7);stmtJs = join(stmtJs,handlerJs);if($finalizer || i !== lastHandlerIdx)stmtJs += adoptionSuffix(handlers[i].body);}return stmtJs;}function generateForStatementIterator($op,$stmt,settings){var $body=$stmt.body,$left=$stmt.left,bodySemicolonOptional=!semicolons && settings.semicolonOptional,prevIndent1=shiftIndent(),stmtJs='for' + _.optSpace + '(';if($left.type === Syntax.VariableDeclaration){var prevIndent2=shiftIndent();stmtJs += $left.kind + _.space + stmtToJs($left.declarations[0],Preset.s6);_.indent = prevIndent2;}else stmtJs += exprToJs($left,Preset.e10);stmtJs = join(stmtJs,$op);var rightJs=exprToJs($stmt.right,Preset.e5);stmtJs = join(stmtJs,rightJs) + ')';_.indent = prevIndent1;_.js += stmtJs + adoptionPrefix($body);StmtGen[$body.type]($body,Preset.s4(bodySemicolonOptional));} //Statement generator dictionary
						var StmtRawGen={BlockStatement:function generateBlockStatement($stmt,settings){var $body=$stmt.body,len=$body.length,lastIdx=len - 1,prevIndent=shiftIndent();_.js += '{' + _.newline; //NOTE: extremely stupid solution for the T170848. We can't preserver all comments, because it's
						//ultra slow, but we make a trick: if we have a function body without content then we add
						//empty block comment into it. A lot of popular sites uses this ads library which fails if we don't
						//do that.
						if(settings.functionBody && !$body.length)_.js += '/**/';for(var i=0;i < len;i++) {var $item=$body[i];_.js += _.indent;StmtGen[$item.type]($item,Preset.s1(settings.functionBody,i === lastIdx));_.js += _.newline;}_.indent = prevIndent;_.js += _.indent + '}';},BreakStatement:function generateBreakStatement($stmt,settings){if($stmt.label)_.js += 'break ' + $stmt.label.name;else _.js += 'break';if(semicolons || !settings.semicolonOptional)_.js += ';';},ContinueStatement:function generateContinueStatement($stmt,settings){if($stmt.label)_.js += 'continue ' + $stmt.label.name;else _.js += 'continue';if(semicolons || !settings.semicolonOptional)_.js += ';';},ClassBody:function generateClassBody($stmt){var $body=$stmt.body,itemCount=$body.length,lastItemIdx=itemCount - 1,prevIndent=shiftIndent();_.js += '{' + _.newline;for(var i=0;i < itemCount;i++) {var $item=$body[i],itemType=$item.type || Syntax.Property;_.js += _.indent;ExprGen[itemType]($item,Preset.e5);if(i !== lastItemIdx)_.js += _.newline;}_.indent = prevIndent;_.js += _.newline + _.indent + '}';},ClassDeclaration:function generateClassDeclaration($stmt){var $body=$stmt.body,$super=$stmt.superClass,js='class ' + $stmt.id.name;if($super){var superJs=exprToJs($super,Preset.e4);js += _.space + join('extends',superJs);}_.js += js + _.optSpace;StmtGen[$body.type]($body,Preset.s2);},DirectiveStatement:function generateDirectiveStatement($stmt,settings){if(extra.raw && $stmt.raw)_.js += $stmt.raw;else _.js += escapeDirective($stmt.directive);if(semicolons || !settings.semicolonOptional)_.js += ';';},DoWhileStatement:function generateDoWhileStatement($stmt,settings){var $body=$stmt.body,$test=$stmt.test,bodyJs=adoptionPrefix($body) + stmtToJs($body,Preset.s7) + adoptionSuffix($body); //NOTE: Because `do 42 while (cond)` is Syntax Error. We need semicolon.
						var stmtJs=join('do',bodyJs);_.js += join(stmtJs,'while' + _.optSpace + '(');ExprGen[$test.type]($test,Preset.e5);_.js += ')';if(semicolons || !settings.semicolonOptional)_.js += ';';},CatchClause:function generateCatchClause($stmt){var $param=$stmt.param,$guard=$stmt.guard,$body=$stmt.body,prevIndent=shiftIndent();_.js += 'catch' + _.optSpace + '(';ExprGen[$param.type]($param,Preset.e5);if($guard){_.js += ' if ';ExprGen[$guard.type]($guard,Preset.e5);}_.indent = prevIndent;_.js += ')' + adoptionPrefix($body);StmtGen[$body.type]($body,Preset.s7);},DebuggerStatement:function generateDebuggerStatement($stmt,settings){_.js += 'debugger';if(semicolons || !settings.semicolonOptional)_.js += ';';},EmptyStatement:function generateEmptyStatement(){_.js += ';';},ExportDeclaration:function generateExportDeclaration($stmt,settings){var $specs=$stmt.specifiers,$decl=$stmt.declaration,withSemicolon=semicolons || !settings.semicolonOptional; // export default AssignmentExpression[In] ;
						if($stmt['default']){var declJs=exprToJs($decl,Preset.e4);_.js += join('export default',declJs);if(withSemicolon)_.js += ';';} // export * FromClause ;
						// export ExportClause[NoReference] FromClause ;
						// export ExportClause ;
						else if($specs){var stmtJs='export';if($specs.length === 0)stmtJs += _.optSpace + '{' + _.optSpace + '}';else if($specs[0].type === Syntax.ExportBatchSpecifier){var specJs=exprToJs($specs[0],Preset.e5);stmtJs = join(stmtJs,specJs);}else {var prevIndent=shiftIndent(),specCount=$specs.length,lastSpecIdx=specCount - 1;stmtJs += _.optSpace + '{';for(var i=0;i < specCount;++i) {stmtJs += _.newline + _.indent;stmtJs += exprToJs($specs[i],Preset.e5);if(i !== lastSpecIdx)stmtJs += ',';}_.indent = prevIndent;stmtJs += _.newline + _.indent + '}';}if($stmt.source){_.js += join(stmtJs,'from' + _.optSpace);ExprGen.Literal($stmt.source);}else _.js += stmtJs;if(withSemicolon)_.js += ';';} // export VariableStatement
						// export Declaration[Default]
						else if($decl){var declJs=stmtToJs($decl,Preset.s4(!withSemicolon));_.js += join('export',declJs);}},ExpressionStatement:function generateExpressionStatement($stmt,settings){var exprJs=exprToJs($stmt.expression,Preset.e5),parenthesize=EXPR_STMT_UNALLOWED_EXPR_REGEXP.test(exprJs) || directive && settings.directiveContext && $stmt.expression.type === Syntax.Literal && typeof $stmt.expression.value === 'string'; //NOTE: '{', 'function', 'class' are not allowed in expression statement.
						// Therefore, they should be parenthesized.
						if(parenthesize)_.js += '(' + exprJs + ')';else _.js += exprJs;if(semicolons || !settings.semicolonOptional)_.js += ';';},ImportDeclaration:function generateImportDeclaration($stmt,settings){var $specs=$stmt.specifiers,stmtJs='import',specCount=$specs.length; //NOTE: If no ImportClause is present,
						// this should be `import ModuleSpecifier` so skip `from`
						// ModuleSpecifier is StringLiteral.
						if(specCount){var hasBinding=!!$specs[0]['default'],firstNamedIdx=hasBinding?1:0,lastSpecIdx=specCount - 1; // ImportedBinding
						if(hasBinding)stmtJs = join(stmtJs,$specs[0].id.name); // NamedImports
						if(firstNamedIdx < specCount){if(hasBinding)stmtJs += ',';stmtJs += _.optSpace + '{'; // import { ... } from "...";
						if(firstNamedIdx === lastSpecIdx)stmtJs += _.optSpace + exprToJs($specs[firstNamedIdx],Preset.e5) + _.optSpace;else {var prevIndent=shiftIndent(); // import {
						//    ...,
						//    ...,
						// } from "...";
						for(var i=firstNamedIdx;i < specCount;i++) {stmtJs += _.newline + _.indent + exprToJs($specs[i],Preset.e5);if(i !== lastSpecIdx)stmtJs += ',';}_.indent = prevIndent;stmtJs += _.newline + _.indent;}stmtJs += '}' + _.optSpace;}stmtJs = join(stmtJs,'from');}_.js += stmtJs + _.optSpace;ExprGen.Literal($stmt.source);if(semicolons || !settings.semicolonOptional)_.js += ';';},VariableDeclarator:function generateVariableDeclarator($stmt,settings){var $id=$stmt.id,$init=$stmt.init,genSettings=Preset.e1(settings.allowIn);if($init){ExprGen[$id.type]($id,genSettings);_.js += _.optSpace + '=' + _.optSpace;ExprGen[$init.type]($init,genSettings);}else {if($id.type === Syntax.Identifier)_.js += $id.name;else ExprGen[$id.type]($id,genSettings);}},VariableDeclaration:function generateVariableDeclaration($stmt,settings){var $decls=$stmt.declarations,len=$decls.length,prevIndent=len > 1?shiftIndent():_.indent,declGenSettings=Preset.s3(settings.allowIn);_.js += $stmt.kind;for(var i=0;i < len;i++) {var $decl=$decls[i];_.js += i === 0?_.space:',' + _.optSpace;StmtGen[$decl.type]($decl,declGenSettings);}if(semicolons || !settings.semicolonOptional)_.js += ';';_.indent = prevIndent;},ThrowStatement:function generateThrowStatement($stmt,settings){var argJs=exprToJs($stmt.argument,Preset.e5);_.js += join('throw',argJs);if(semicolons || !settings.semicolonOptional)_.js += ';';},TryStatement:function generateTryStatement($stmt){var $block=$stmt.block,$finalizer=$stmt.finalizer,stmtJs='try' + adoptionPrefix($block) + stmtToJs($block,Preset.s7) + adoptionSuffix($block);var $handlers=$stmt.handlers || $stmt.guardedHandlers;if($handlers)stmtJs = generateTryStatementHandlers(stmtJs,$finalizer,$handlers);if($stmt.handler){$handlers = isArray($stmt.handler)?$stmt.handler:[$stmt.handler];stmtJs = generateTryStatementHandlers(stmtJs,$finalizer,$handlers);}if($finalizer){stmtJs = join(stmtJs,'finally' + adoptionPrefix($finalizer));stmtJs += stmtToJs($finalizer,Preset.s7);}_.js += stmtJs;},SwitchStatement:function generateSwitchStatement($stmt){var $cases=$stmt.cases,$discr=$stmt.discriminant,prevIndent=shiftIndent();_.js += 'switch' + _.optSpace + '(';ExprGen[$discr.type]($discr,Preset.e5);_.js += ')' + _.optSpace + '{' + _.newline;_.indent = prevIndent;if($cases){var caseCount=$cases.length,lastCaseIdx=caseCount - 1;for(var i=0;i < caseCount;i++) {var $case=$cases[i];_.js += _.indent;StmtGen[$case.type]($case,Preset.s4(i === lastCaseIdx));_.js += _.newline;}}_.js += _.indent + '}';},SwitchCase:function generateSwitchCase($stmt,settings){var $conseqs=$stmt.consequent,$firstConseq=$conseqs[0],$test=$stmt.test,i=0,conseqSemicolonOptional=!semicolons && settings.semicolonOptional,conseqCount=$conseqs.length,lastConseqIdx=conseqCount - 1,prevIndent=shiftIndent();if($test){var testJs=exprToJs($test,Preset.e5);_.js += join('case',testJs) + ':';}else _.js += 'default:';if(conseqCount && $firstConseq.type === Syntax.BlockStatement){i++;_.js += adoptionPrefix($firstConseq);StmtGen[$firstConseq.type]($firstConseq,Preset.s7);}for(;i < conseqCount;i++) {var $conseq=$conseqs[i],semicolonOptional=i === lastConseqIdx && conseqSemicolonOptional;_.js += _.newline + _.indent;StmtGen[$conseq.type]($conseq,Preset.s4(semicolonOptional));}_.indent = prevIndent;},IfStatement:function generateIfStatement($stmt,settings){var $conseq=$stmt.consequent,$test=$stmt.test,prevIndent=shiftIndent(),semicolonOptional=!semicolons && settings.semicolonOptional;_.js += 'if' + _.optSpace + '(';ExprGen[$test.type]($test,Preset.e5);_.js += ')';_.indent = prevIndent;_.js += adoptionPrefix($conseq);if($stmt.alternate){var conseq=stmtToJs($conseq,Preset.s7) + adoptionSuffix($conseq),alt=stmtToJs($stmt.alternate,Preset.s4(semicolonOptional));if($stmt.alternate.type === Syntax.IfStatement)alt = 'else ' + alt;else alt = join('else',adoptionPrefix($stmt.alternate) + alt);_.js += join(conseq,alt);}else StmtGen[$conseq.type]($conseq,Preset.s4(semicolonOptional));},ForStatement:function generateForStatement($stmt,settings){var $init=$stmt.init,$test=$stmt.test,$body=$stmt.body,$update=$stmt.update,bodySemicolonOptional=!semicolons && settings.semicolonOptional,prevIndent=shiftIndent();_.js += 'for' + _.optSpace + '(';if($init){if($init.type === Syntax.VariableDeclaration)StmtGen[$init.type]($init,Preset.s6);else {ExprGen[$init.type]($init,Preset.e14);_.js += ';';}}else _.js += ';';if($test){_.js += _.optSpace;ExprGen[$test.type]($test,Preset.e5);}_.js += ';';if($update){_.js += _.optSpace;ExprGen[$update.type]($update,Preset.e5);}_.js += ')';_.indent = prevIndent;_.js += adoptionPrefix($body);StmtGen[$body.type]($body,Preset.s4(bodySemicolonOptional));},ForInStatement:function generateForInStatement($stmt,settings){generateForStatementIterator('in',$stmt,settings);},ForOfStatement:function generateForOfStatement($stmt,settings){generateForStatementIterator('of',$stmt,settings);},LabeledStatement:function generateLabeledStatement($stmt,settings){var $body=$stmt.body,bodySemicolonOptional=!semicolons && settings.semicolonOptional,prevIndent=_.indent;_.js += $stmt.label.name + ':' + adoptionPrefix($body);if($body.type !== Syntax.BlockStatement)prevIndent = shiftIndent();StmtGen[$body.type]($body,Preset.s4(bodySemicolonOptional));_.indent = prevIndent;},ModuleDeclaration:function generateModuleDeclaration($stmt,settings){_.js += 'module' + _.space + $stmt.id.name + _.space + 'from' + _.optSpace;ExprGen.Literal($stmt.source);if(semicolons || !settings.semicolonOptional)_.js += ';';},Program:function generateProgram($stmt){var $body=$stmt.body,len=$body.length,lastIdx=len - 1;if(safeConcatenation && len > 0)_.js += '\n';for(var i=0;i < len;i++) {var $item=$body[i];_.js += _.indent;StmtGen[$item.type]($item,Preset.s5(!safeConcatenation && i === lastIdx));if(i !== lastIdx)_.js += _.newline;}},FunctionDeclaration:function generateFunctionDeclaration($stmt){var isGenerator=!!$stmt.generator;_.js += isGenerator?'function*' + _.optSpace:'function' + _.space;_.js += $stmt.id.name;generateFunctionBody($stmt);},ReturnStatement:function generateReturnStatement($stmt,settings){var $arg=$stmt.argument;if($arg){var argJs=exprToJs($arg,Preset.e5);_.js += join('return',argJs);}else _.js += 'return';if(semicolons || !settings.semicolonOptional)_.js += ';';},WhileStatement:function generateWhileStatement($stmt,settings){var $body=$stmt.body,$test=$stmt.test,bodySemicolonOptional=!semicolons && settings.semicolonOptional,prevIndent=shiftIndent();_.js += 'while' + _.optSpace + '(';ExprGen[$test.type]($test,Preset.e5);_.js += ')';_.indent = prevIndent;_.js += adoptionPrefix($body);StmtGen[$body.type]($body,Preset.s4(bodySemicolonOptional));},WithStatement:function generateWithStatement($stmt,settings){var $body=$stmt.body,$obj=$stmt.object,bodySemicolonOptional=!semicolons && settings.semicolonOptional,prevIndent=shiftIndent();_.js += 'with' + _.optSpace + '(';ExprGen[$obj.type]($obj,Preset.e5);_.js += ')';_.indent = prevIndent;_.js += adoptionPrefix($body);StmtGen[$body.type]($body,Preset.s4(bodySemicolonOptional));}};function generateStatement($stmt,option){StmtGen[$stmt.type]($stmt,option);} //CodeGen
						//-----------------------------------------------------------------------------------
						function exprToJs($expr,settings){var savedJs=_.js;_.js = '';ExprGen[$expr.type]($expr,settings);var src=_.js;_.js = savedJs;return src;}function stmtToJs($stmt,settings){var savedJs=_.js;_.js = '';StmtGen[$stmt.type]($stmt,settings);var src=_.js;_.js = savedJs;return src;}function run($node){_.js = '';if(StmtGen[$node.type])StmtGen[$node.type]($node,Preset.s7);else ExprGen[$node.type]($node,Preset.e19);return _.js;}function wrapExprGen(gen){return function($expr,settings){if(extra.verbatim && $expr.hasOwnProperty(extra.verbatim))generateVerbatim($expr,settings);else gen($expr,settings);};}function createExprGenWithExtras(){var gens={};for(var key in ExprRawGen) {if(ExprRawGen.hasOwnProperty(key))gens[key] = wrapExprGen(ExprRawGen[key]);}return gens;} //Strings
						var _={js:'',newline:'\n',optSpace:' ',space:' ',indentUnit:'    ',indent:''}; //Generators
						var ExprGen=void 0,StmtGen=StmtRawGen;function generate($node,options){var defaultOptions=getDefaultOptions(),result,pair;if(options != null){ //NOTE: Obsolete options
						//
						//   `options.indent`
						//   `options.base`
						//
						// Instead of them, we can use `option.format.indent`.
						if(typeof options.indent === 'string'){defaultOptions.format.indent.style = options.indent;}if(typeof options.base === 'number'){defaultOptions.format.indent.base = options.base;}options = updateDeeply(defaultOptions,options);_.indentUnit = options.format.indent.style;if(typeof options.base === 'string'){_.indent = options.base;}else {_.indent = stringRepeat(_.indentUnit,options.format.indent.base);}}else {options = defaultOptions;_.indentUnit = options.format.indent.style;_.indent = stringRepeat(_.indentUnit,options.format.indent.base);}json = options.format.json;renumber = options.format.renumber;hexadecimal = json?false:options.format.hexadecimal;quotes = json?'double':options.format.quotes;escapeless = options.format.escapeless;_.newline = options.format.newline;_.optSpace = options.format.space;if(options.format.compact)_.newline = _.optSpace = _.indentUnit = _.indent = '';_.space = _.optSpace?_.optSpace:' ';parentheses = options.format.parentheses;semicolons = options.format.semicolons;safeConcatenation = options.format.safeConcatenation;directive = options.directive;parse = json?null:options.parse;extra = options;if(extra.verbatim)ExprGen = createExprGenWithExtras();else ExprGen = ExprRawGen;return run($node);}FORMAT_MINIFY = {indent:{style:'',base:0},renumber:true,hexadecimal:true,quotes:'auto',escapeless:true,compact:true,parentheses:false,semicolons:false};FORMAT_DEFAULTS = getDefaultOptions().format;exports.generate = generate;exports.Precedence = updateDeeply({},Precedence);exports.browser = false;exports.FORMAT_MINIFY = FORMAT_MINIFY;exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;})(codeGetExports);JSParsingTools.generate = codeGetExports.generate;JSParsingTools.Syntax = codeGetExports.Syntax; // ------------------------------------------
						exports.default = JSParsingTools;module.exports = exports.default; // [walk]: util/walk.js
					},
					"templates.js": function (exports, module, require) {
						exports.__esModule = true;
						exports.getProcessScriptMethAst = getProcessScriptMethAst;
						exports.getGetLocationMethAst = getGetLocationMethAst;
						exports.getSetLocationMethAst = getSetLocationMethAst;
						exports.getSetMethAst = getSetMethAst;
						exports.getCallMethodMthAst = getCallMethodMthAst;
						exports.getGetMethAst = getGetMethAst;
						exports.getGetComputedMethAst = getGetComputedMethAst;
						exports.getSetComputedMethAst = getSetComputedMethAst;
						exports.getConcatOperatorAst = getConcatOperatorAst;
						exports.getDocumentWriteArgAst = getDocumentWriteArgAst;
						exports.getDocumentWriteStatementIndices = getDocumentWriteStatementIndices;

						function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

						// -------------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// -------------------------------------------------------------

						var _parsingTools = require('./parsing-tools');

						var _instructions = require('./instructions');

						var instructs = _interopRequireWildcard(_instructions);

						function getProcessScriptMethAst(args) {
						    return {
						        type: _parsingTools.Syntax.CallExpression,

						        callee: {
						            type: _parsingTools.Syntax.Identifier,
						            name: instructs.PROCESS_SCRIPT_METH_NAME
						        },

						        arguments: [args[0]]
						    };
						}

						function getGetLocationMethAst() {
						    return {
						        type: _parsingTools.Syntax.CallExpression,

						        callee: {
						            type: _parsingTools.Syntax.Identifier,
						            name: instructs.GET_LOCATION_METH_NAME
						        },

						        arguments: [{
						            type: _parsingTools.Syntax.Identifier,
						            name: 'location'
						        }]
						    };
						}

						function getSetLocationMethAst(value) {
						    return {
						        type: _parsingTools.Syntax.CallExpression,

						        callee: {
						            type: _parsingTools.Syntax.MemberExpression,
						            computed: false,

						            object: {
						                type: _parsingTools.Syntax.FunctionExpression,
						                id: null,
						                params: [],
						                defaults: [],

						                body: {
						                    type: _parsingTools.Syntax.BlockStatement,
						                    body: [{
						                        type: _parsingTools.Syntax.ReturnStatement,

						                        argument: {
						                            type: _parsingTools.Syntax.LogicalExpression,
						                            operator: '||',

						                            left: {
						                                type: _parsingTools.Syntax.CallExpression,

						                                callee: {
						                                    type: _parsingTools.Syntax.Identifier,
						                                    name: instructs.SET_LOCATION_METH_NAME
						                                },

						                                arguments: [{
						                                    type: _parsingTools.Syntax.Identifier,
						                                    name: 'location'
						                                }, value]
						                            },

						                            right: {
						                                type: _parsingTools.Syntax.AssignmentExpression,
						                                operator: '=',

						                                left: {
						                                    type: _parsingTools.Syntax.Identifier,
						                                    name: 'location'
						                                },

						                                right: value
						                            }
						                        }
						                    }]
						                },

						                rest: null,
						                generator: false,
						                expression: false
						            },

						            property: {
						                type: _parsingTools.Syntax.Identifier,
						                name: 'apply'
						            }
						        },

						        arguments: [{
						            type: _parsingTools.Syntax.ThisExpression
						        }]
						    };
						}

						function getSetMethAst(propertyName, obj, value) {
						    return {
						        type: _parsingTools.Syntax.CallExpression,

						        callee: {
						            type: _parsingTools.Syntax.Identifier,
						            name: instructs.SET_PROPERTY_METH_NAME
						        },

						        arguments: [obj, {
						            type: _parsingTools.Syntax.Literal,
						            value: propertyName,
						            raw: '"' + propertyName + '"'
						        }, value]
						    };
						}

						function getCallMethodMthAst(owner, meth, args) {
						    return {
						        type: _parsingTools.Syntax.CallExpression,

						        callee: {
						            type: _parsingTools.Syntax.Identifier,
						            name: instructs.CALL_METHOD_METH_NAME
						        },

						        arguments: [owner, meth, {
						            type: _parsingTools.Syntax.ArrayExpression,
						            elements: args
						        }]
						    };
						}

						function getGetMethAst(propertyName, owner) {
						    return {
						        type: _parsingTools.Syntax.CallExpression,

						        callee: {
						            type: _parsingTools.Syntax.Identifier,
						            name: instructs.GET_PROPERTY_METH_NAME
						        },

						        arguments: [owner, {
						            type: _parsingTools.Syntax.Literal,
						            value: propertyName,
						            raw: '"' + propertyName + '"'
						        }]
						    };
						}

						function getGetComputedMethAst(property, owner) {
						    return {
						        type: _parsingTools.Syntax.CallExpression,

						        callee: {
						            type: _parsingTools.Syntax.Identifier,
						            name: instructs.GET_PROPERTY_METH_NAME
						        },

						        arguments: [owner, property]
						    };
						}

						function getSetComputedMethAst(property, owner, value) {
						    return {
						        type: _parsingTools.Syntax.CallExpression,

						        callee: {
						            type: _parsingTools.Syntax.Identifier,
						            name: instructs.SET_PROPERTY_METH_NAME
						        },

						        arguments: [owner, property, value]
						    };
						}

						function getConcatOperatorAst(left, right) {
						    return {
						        type: _parsingTools.Syntax.AssignmentExpression,
						        operator: '=',
						        left: left,

						        right: {
						            type: _parsingTools.Syntax.BinaryExpression,
						            operator: '+',
						            left: left,
						            right: right
						        }
						    };
						}

						function getDocumentWriteArgAst(arg) {
						    return {
						        type: _parsingTools.Syntax.Literal,
						        value: arg,
						        raw: '\'' + arg + '\''
						    };
						}

						function getDocumentWriteStatementIndices(statements) {
						    var indices = [];

						    var isExpressionStatement = function (statement) {
						        return statement.type === _parsingTools.Syntax.ExpressionStatement;
						    };
						    var isCallStatement = function (statement) {
						        return statement.expression.type === _parsingTools.Syntax.CallExpression;
						    };
						    var isMember = function (statement) {
						        return statement.expression.callee.type === _parsingTools.Syntax.MemberExpression;
						    };
						    var isDocumentWrite = function (statement) {
						        return statement.expression.callee.property.name === 'write' || statement.expression.callee.property.name === 'writeln';
						    };

						    for (var i = 0; i < statements.length; i++) {
						        var statement = statements[i];

						        if (isExpressionStatement(statement) && isCallStatement(statement) && isMember(statement) && isDocumentWrite(statement)) {
						            indices.push(i);
						        }
						    }

						    return indices;
						}
					}
				},
				"script.js": function (exports, module, require) {
					exports.__esModule = true;

					function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

					function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					var _js = require('./js');

					var _js2 = _interopRequireDefault(_js);

					var _const = require('../const');

					var _const2 = _interopRequireDefault(_const);

					// Byte Order Mark
					var BOM_REGEX = new RegExp('^(\\xEF\\xBB\\xBF|' + '\\xFE\\xFF|' + '\\xFF\\xFE|' + '\\x00\\x00\\xFE\\xFF|' + '\\xFF\\xFE\\x00\\x00|' + '\\x2B\\x2F\\x76\\x38|' + '\\x2B\\x2F\\x76\\x39|' + '\\x2B\\x2F\\x76\\x2B|' + '\\x2B\\x2F\\x76\\x2F|' + '\\xF7\\x64\\x4C|' + '\\xDD\\x73\\x66\\x73|' + '\\x0E\\xFE\\xFF|' + '\\xFB\\xEE\\x28|' + '\\x84\\x31\\x95\\x33)');

					var ScriptProcessor = (function () {
					    function ScriptProcessor() {
					        _classCallCheck(this, ScriptProcessor);

					        this.OVERRIDE_DOM_METH_SCRIPT = 'window["' + _const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME + '"]';

					        this.SCRIPT_HEADER = '\r\ntypeof window !== "undefined" && ' + this.OVERRIDE_DOM_METH_SCRIPT + ' && ' + this.OVERRIDE_DOM_METH_SCRIPT + '();\r\n' + _js2.default.MOCK_ACCESSORS;

					        this.SCRIPT_HEADER_REG_EX = new RegExp('^\\s*typeof[^\\n]+' + _const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME + '[^\\n]+\\n[^\\n]+\\n[^\\n]+\\n[^\\n]+\\n[^\\n]+\\n[^\\n]+\\n[^\\n]+\\n[^\\n]+__proc\\$Script;', 'i');
					    }

					    ScriptProcessor.prototype.process = function process(text, withoutHeader) {
					        var bom = this.getBOM(text);

					        if (bom) text = text.replace(bom, '');

					        text = _js2.default.process(text);

					        // Overriding methods that work with the DOM.
					        if (!_js2.default.isDataScript(text) && !withoutHeader && text.indexOf(_const2.default.DOM_SANDBOX_OVERRIDE_DOM_METHOD_NAME) === -1) text = this.SCRIPT_HEADER + text;

					        return bom ? bom + text : text;
					    };

					    ScriptProcessor.prototype.getBOM = function getBOM(text) {
					        var match = text.match(BOM_REGEX);

					        return match ? match[0] : null;
					    };

					    return ScriptProcessor;
					})();

					exports.default = new ScriptProcessor();
					module.exports = exports.default;
				},
				"style.js": function (exports, module, require) {
					exports.__esModule = true;

					function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

					function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					var _const = require('../const');

					var _const2 = _interopRequireDefault(_const);

					var IS_STYLESHEET_PROCESSED_REG_EX = new RegExp('^\\s*' + _const2.default.IS_STYLESHEET_PROCESSED_COMMENT.replace(/\/|\*/g, '\\$&'));

					var SOURCE_MAP_REG_EX = /#\s*sourceMappingURL\s*=\s*[^\s]+(\s|\*\/)/i;
					var CSS_URL_PROPERTY_VALUE_PATTERN = /(url\s*\(\s*)(?:(')([^\s']*)(')|(")([^\s"]*)(")|([^\s\)]*))(\s*\))|(@import\s+)(?:(')([^\s']*)(')|(")([^\s"]*)("))/g;

					var StyleProcessor = (function () {
					    function StyleProcessor() {
					        _classCallCheck(this, StyleProcessor);
					    }

					    StyleProcessor.prototype.process = function process(css, urlReplacer, isStylesheetTable) {
					        var isStylesheetProcessed = IS_STYLESHEET_PROCESSED_REG_EX.test(css);

					        if (typeof css === 'string' && !isStylesheetProcessed) {
					            var prefix = isStylesheetTable ? _const2.default.IS_STYLESHEET_PROCESSED_COMMENT + '\n' : '';

					            // Replace :hover pseudo class
					            css = css.replace(/\s*:\s*hover(\W)/gi, '[' + _const2.default.HOVER_PSEUDO_CLASS_ATTR + ']$1');

					            // Remove source map directive
					            css = css.replace(SOURCE_MAP_REG_EX, '$1');

					            // NOTE: replace URLs in css rules with the proxy URLs.
					            return prefix + this._replaceStylsheetUrls(css, urlReplacer);
					        }

					        return css;
					    };

					    StyleProcessor.prototype.cleanUp = function cleanUp(css, parseProxyUrl, formatUrl) {
					        if (typeof css === 'string') {
					            css = css.replace(new RegExp('\\[' + _const2.default.HOVER_PSEUDO_CLASS_ATTR + '\\](\\W)', 'ig'), ':hover$1');

					            return this._replaceStylsheetUrls(css, function (url) {
					                var originUrlObj = parseProxyUrl(url);

					                if (originUrlObj) return formatUrl(originUrlObj.originResourceInfo);

					                return url;
					            });
					        }

					        return css;
					    };

					    StyleProcessor.prototype._replaceStylsheetUrls = function _replaceStylsheetUrls(css, processor) {
					        return css.replace(CSS_URL_PROPERTY_VALUE_PATTERN, function () {
					            var prefix = arguments[1] || arguments[10];
					            var openQuote = arguments[2] || arguments[5] || arguments[11] || arguments[14] || '';
					            var url = arguments[3] || arguments[6] || arguments[8] || arguments[12] || arguments[15];
					            var closeQuote = arguments[4] || arguments[7] || arguments[13] || arguments[16] || '';
					            var postfix = arguments[9] || '';

					            return url ? prefix + openQuote + processor(url) + closeQuote + postfix : arguments[0];
					        });
					    };

					    return StyleProcessor;
					})();

					exports.default = new StyleProcessor();
					module.exports = exports.default;
				}
			},
			"service-msg-cmd.js": function (exports, module, require) {
				exports.__esModule = true;
				// -------------------------------------------------------------
				// WARNING: this file is used by both the client and the server.
				// Do not use any browser or node-specific API!
				// -------------------------------------------------------------

				var ServiceCommands = {
				    GET_UPLOADED_FILES: 'GET_UPLOADED_FILES',
				    SET_COOKIE: 'CMD_SET_COOKIE',
				    UPLOAD_FILES: 'UPLOAD_FILES',
				    GET_IFRAME_TASK_SCRIPT: 'GET_IFRAME_TASK_SCRIPT'
				};

				exports.default = ServiceCommands;
				module.exports = exports.default;
			},
			"utils": {
				"string-trim.js": function (exports, module, require) {
					exports.__esModule = true;
					exports.default = trim;
					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					// NOTE: Some websites override the String.prototype.trim method. When we use this function
					// in our scripts, we expect it to have the default behavior. Therefore, in order to protect
					// ourselves from spoofing, we must use our own implementation.

					function trim(str) {
					    return str.replace(/^\s+|\s+$/g, '');
					}

					module.exports = exports.default;
				},
				"url.js": function (exports, module, require) {
					exports.__esModule = true;

					function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

					// -------------------------------------------------------------
					// WARNING: this file is used by both the client and the server.
					// Do not use any browser or node-specific API!
					// -------------------------------------------------------------

					var _stringTrim = require('./string-trim');

					var _stringTrim2 = _interopRequireDefault(_stringTrim);

					var UrlUtil = {};

					//Const
					var PROTOCOL_RE = /(^(\w+?\:))/;
					var LEADING_SLASHES_RE = /^(\/\/)/;
					var HOST_RE = /^(.*?)(\/|%|\?|;|#|$)/;
					var PORT_RE = /:([0-9]*)$/;
					var QUERY_AND_HASH_RE = /(\?.+|#[^#]*)$/;

					var URL_UTIL_PROTOCOL_IS_NOT_SUPPORTED = 'CLIENT_URL_UTIL_PROTOCOL_IS_NOT_SUPPORTED';
					var REQUEST_DESCRIPTOR_VALUES_SEPARATOR = '!';

					var IFRAME = 'iframe';
					var SCRIPT = 'script';

					UrlUtil.URL_UTIL_PROTOCOL_IS_NOT_SUPPORTED = URL_UTIL_PROTOCOL_IS_NOT_SUPPORTED;
					UrlUtil.REQUEST_DESCRIPTOR_VALUES_SEPARATOR = REQUEST_DESCRIPTOR_VALUES_SEPARATOR;
					UrlUtil.IFRAME = IFRAME;
					UrlUtil.SCRIPT = SCRIPT;

					function validateOriginUrl(url) {
					    if (!/^https?:/.test(url)) {
					        throw {
					            code: URL_UTIL_PROTOCOL_IS_NOT_SUPPORTED,
					            originUrl: url
					        };
					    }
					}

					UrlUtil.isSubDomain = function (domain, subDomain) {
					    domain = domain.replace(/^www./i, '');
					    subDomain = subDomain.replace(/^www./i, '');

					    if (domain === subDomain) return true;

					    var index = subDomain.lastIndexOf(domain);

					    return subDomain[index - 1] === '.' && subDomain.length === index + domain.length;
					};

					UrlUtil.sameOriginCheck = function (location, checkedUrl) {
					    if (!checkedUrl) return true;

					    var parsedLocation = UrlUtil.parseUrl(location);
					    var parsedCheckedUrl = UrlUtil.parseUrl(checkedUrl);
					    var parsedProxyLocation = UrlUtil.parseProxyUrl(location);
					    var parsedOriginUrl = parsedProxyLocation ? parsedProxyLocation.originResourceInfo : parsedLocation;
					    var isRelative = !parsedCheckedUrl.host;

					    if (isRelative || parsedCheckedUrl.host === parsedLocation.host && parsedCheckedUrl.protocol === parsedLocation.protocol) return true;

					    if (parsedOriginUrl) {
					        var portsEq = !parsedOriginUrl.port && !parsedCheckedUrl.port || parsedOriginUrl.port && parsedOriginUrl.port.toString() === parsedCheckedUrl.port;

					        if (parsedOriginUrl.protocol === parsedCheckedUrl.protocol && portsEq) {
					            if (parsedOriginUrl.hostname === parsedCheckedUrl.hostname) return true;

					            return UrlUtil.isSubDomain(parsedOriginUrl.hostname, parsedCheckedUrl.hostname) || UrlUtil.isSubDomain(parsedCheckedUrl.hostname, parsedOriginUrl.hostname);
					        }
					    }

					    return false;
					};

					// NOTE: Convert origin protocol and hostname to lower case
					// (https://github.com/superroma/testcafe-hammerhead/issues/1)
					UrlUtil.convertHostToLowerCase = function (url) {
					    var parsedUrl = UrlUtil.parseUrl(url);

					    return (parsedUrl.protocol + '//' + parsedUrl.host).toLowerCase() + parsedUrl.partAfterHost;
					};

					UrlUtil.getProxyUrl = function (url, proxyHostname, proxyPort, jobUid, jobOwnerToken, resourceType) {
					    validateOriginUrl(url);

					    var params = [jobOwnerToken, jobUid];

					    if (resourceType) params.push(resourceType);

					    params = params.join(REQUEST_DESCRIPTOR_VALUES_SEPARATOR);

					    return 'http://' + proxyHostname + ':' + proxyPort + '/' + params + '/' + UrlUtil.convertHostToLowerCase(url);
					};

					UrlUtil.getDomain = function (parsed) {
					    return UrlUtil.formatUrl({
					        protocol: parsed.protocol,
					        host: parsed.host,
					        hostname: parsed.hostname,
					        port: parsed.port
					    });
					};

					UrlUtil.parseProxyUrl = function (proxyUrl) {
					    //TODO remove it
					    var parsedUrl = UrlUtil.parseUrl(proxyUrl);

					    if (!parsedUrl.partAfterHost) return null;

					    var match = parsedUrl.partAfterHost.match(/^\/(\S+?)\/(https?:\/\/\S+)/);

					    if (!match) return null;

					    var params = match[1].split(REQUEST_DESCRIPTOR_VALUES_SEPARATOR);

					    // NOTE: we should have at least job uid and owner token
					    if (params.length < 2) return null;

					    return {
					        originUrl: match[2],
					        originResourceInfo: UrlUtil.parseUrl(match[2]),
					        partAfterHost: parsedUrl.partAfterHost,

					        proxy: {
					            hostname: parsedUrl.hostname,
					            port: parsedUrl.port
					        },

					        jobInfo: {
					            ownerToken: params[0],
					            uid: params[1]
					        },

					        resourceType: params[2] || null
					    };
					};

					UrlUtil.getPathname = function (path) {
					    return path.replace(QUERY_AND_HASH_RE, '');
					};

					UrlUtil.parseUrl = function (url) {
					    var parsed = {};

					    url = UrlUtil.prepareUrl(url);

					    if (!url) return parsed;

					    url = _stringTrim2.default(url);

					    // Protocol
					    var hasImplicitProtocol = false;
					    var remainder = url.replace(PROTOCOL_RE, function (str, protocol) {
					        parsed.protocol = protocol;
					        return '';
					    }).replace(LEADING_SLASHES_RE, function () {
					        hasImplicitProtocol = true;
					        return '';
					    });

					    // NOTE: URL is relative
					    if (!parsed.protocol && !hasImplicitProtocol) {
					        parsed.partAfterHost = url;
					        return parsed;
					    }

					    // Host
					    parsed.partAfterHost = remainder.replace(HOST_RE, function (str, host, restPartSeparator) {
					        parsed.host = host;
					        return restPartSeparator;
					    });

					    if (parsed.host) {
					        parsed.hostname = parsed.host.replace(PORT_RE, function (str, port) {
					            parsed.port = port;
					            return '';
					        });
					    }

					    return parsed;
					};

					UrlUtil.isSupportedProtocol = function (url) {
					    return !/^\s*(chrome-extension:|blob:|javascript:|about:|mailto:|tel:|data:|skype:|skypec2c:|file:|#)/i.test(url);
					};

					UrlUtil.resolveUrlAsOrigin = function (url, getProxyUrl) {
					    getProxyUrl = getProxyUrl || UrlUtil.getProxyUrl;

					    if (UrlUtil.isSupportedProtocol(url)) {
					        var proxyUrl = getProxyUrl(url);
					        var parsedProxyUrl = UrlUtil.parseProxyUrl(proxyUrl);

					        return UrlUtil.formatUrl(parsedProxyUrl.originResourceInfo);
					    }

					    return url;
					};

					UrlUtil.formatUrl = function (parsedUrl) {
					    // NOTE: URL is relative
					    if (!parsedUrl.host && (!parsedUrl.hostname || !parsedUrl.port)) return parsedUrl.partAfterHost;

					    var url = parsedUrl.protocol || '';

					    url += '//';

					    if (parsedUrl.username || parsedUrl.password) url += parsedUrl.username + ':' + parsedUrl.password + '@';

					    if (parsedUrl.host) url += parsedUrl.host;else {
					        url += parsedUrl.hostname;

					        if (parsedUrl.port) url += ':' + parsedUrl.port;
					    }

					    if (parsedUrl.partAfterHost) url += parsedUrl.partAfterHost;

					    return url;
					};

					UrlUtil.prepareUrl = function (url) {
					    // TODO: fix it
					    /* eslint-disable no-undef */
					    if (url === null && /iPad|iPhone/i.test(window.navigator.userAgent)) return '';
					    /* eslint-enable no-undef */

					    url = (url + '').replace(/\n|\t/g, '');

					    // NOTE: Remove unnecessary slashes form the begin of the url.
					    // For example, "//////google.com" url is equal to "//google.com"
					    return url.replace(/^\/+(\/\/.*$)/, '$1');
					};

					exports.default = UrlUtil;
					module.exports = exports.default;
				}
			}
		}
	}
})("testcafe-hammerhead/src/client/hammerhead");

    }

    initHammerheadClient(window);
})();

