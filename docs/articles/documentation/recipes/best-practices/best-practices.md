# TestCafe Best Practices

This article covers best ways to approach different aspects of functional web testing with TestCafe and is divided into the following sections:

* Smart Assertions
* Page Objects Use
* Use of Roles for Login
 
* File structure
* Clean up between Tests (beforeEach)
* Testing only e2e scenarios / e2e tests appliance
* Selectors strategy

Each section starts with a faulty code snippet that illustrates the potential issue.

## Smart Assertions

The asyncronous nature of the web brings additional difficulties into functional testing. Peripheral factors (network lag, processor or memory bottlenecks in containers) can interfere with the assertions and render tests inconclusive (otherwise known as 'flaky').

Out of the box, TestCafe includes a [Smart Assertion Query Mechanism](../../guides/basic-guides/assert.md#smart-assertion-query-mechanism), which helps mitigate these effects. This mechanism introduces additional wait time for all the assertions: if an assertion fails, the test doesn't fail straight away. Instead, the assertion retries multiple times within a timeout. That helps to stabilize the tests without a big impact on performance.

However, the smart assertions query mechanism only works with promises returned from TestCafe's own `Selector API`.

The following example demonstrates the potential issue:

```js
import { Selector } from 'testcafe';

fixture `My fixture`
    .page `http://devexpress.github.io/testcafe/example/`;

test('Assertion with Selector', async t => {
    const developerNameInput = Selector('#developer-name');

    //this technique leads to unstable results. Avoid it.
    const developerName      = await Selector('#developer-name').value;
    //

    console.log(developerName);

    await t
        .wait(1000)
        .expect(developerNameInput.value).eql('')
        .typeText(developerNameInput, 'Peter')
        .expect(developerName).eql('Peter');
});
```

In this snippet, the `developerName` is initialized with the value of a Selector, but because of the `await` keyword, the value is calculated and assigned only once, when this line executes. This effectively disables the smart assertions query mechanism, which in this case leads to inconclusive results. This test fails.

To avoid this, the variable should be initialized with a `Selector API` promise. To do that, omit the `await` keyword:

```js
import { Selector } from 'testcafe';

fixture `My fixture`
    .page `http://devexpress.github.io/testcafe/example/`;

test('Assertion with Selector', async t => {
    const developerNameInput = Selector('#developer-name');
    const developerName      = Selector('#developer-name').value;

    console.log(developerName);

    await t
        .wait(1000)
        .expect(developerNameInput.value).eql('')
        .typeText(developerNameInput, 'Peter')
        .expect(developerName).eql('Peter');
});
```

The `developerName` is now initialized with a re-executable Selector API promise. When a test controller receives this promise, it enables the smart assertion query mechanism and TestCafe is able to wait for the value to update.

> The smart assertion query mechanism only affects promises generated by TestCafe Selector API. Await user-created promises and promises generated by third-party libraries.

This rule applies to ClientFunctions in the same capacity.

The test below doesn't execute consistently:

```js
import { Selector, ClientFunction } from 'testcafe';

fixture `My fixture`
    .page `http://devexpress.github.io/testcafe/example/`;

test('Assertion with ClientFunction', async t => {
    const getValue        = ClientFunction(() => document.getElementById('preferred-interface').value)
    const interfaceSelect = Selector('#preferred-interface');
    const interfaceOption = interfaceSelect.find('option');
    const value           = await getValue();


    await t
        .click(interfaceSelect)
        .click(interfaceOption.withText('JavaScript API'))
        .expect(value).eql('JavaScript API')
});
```

In this example, the client function obtains the value of a drop-down element. This value is then passed to the `t.expect` method. Since the client function is awaited when it's assigned to the variable, the value gets resolved instantly and never updates- the smart assertion query mechanism doesn't apply and the test fails.

To solve the issue, pass the client function without the `await` keyword:

```js
import { Selector, ClientFunction } from 'testcafe';

fixture `My fixture`
    .page `http://devexpress.github.io/testcafe/example/`;

test('Assertion with ClientFunction', async t => {
    const getValue = ClientFunction(() => document.getElementById('preferred-interface').value)

    const interfaceSelect = Selector('#preferred-interface');
    const interfaceOption = interfaceSelect.find('option');
    const value           =  getValue();

    await t
        .click(interfaceSelect)
        .click(interfaceOption.withText('JavaScript API'))
        .expect(value).eql('JavaScript API')
});
```

In this case, TestCafe applies the smart query mechanism and retries the assertion multiple times. This test is more conclusive as it is responsive to the changes that happen on the page.
