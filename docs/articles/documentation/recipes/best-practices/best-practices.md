---
layout: docs
title: Best Practices
permalink: /documentation/recipes/best-practices/best-practices.html
---
# Best Practices

This article covers the recommended ways to test with TestCafe and covers the following topics:

* Smart Assertions
* Use of Page Objects
* Use of Roles for Login

* File structure
* Clean up between Tests (beforeEach)
* Testing only e2e scenarios / e2e tests appliance
* Selectors strategy

## Smart Assertions

Since web testing is asynchronous, peripheral factors (like network lag, processor, or memory bottlenecks in containers) can interfere with the assertions and render tests inconclusive (otherwise known as 'flaky').

Out of the box, TestCafe includes a [Smart Assertion Query Mechanism](../../guides/basic-guides/assert.md#smart-assertion-query-mechanism), which helps mitigate these effects. This mechanism introduces additional wait time for all the assertions: if an assertion fails, the test doesn't fail straight away. Instead, the assertion retries multiple times within a timeout. That helps to stabilize the tests without a big impact on performance.

However, the smart assertions query mechanism only works with promises returned from TestCafe's own `Selector API`.

The following example demonstrates the potential issue:

```js
import { Selector } from 'testcafe';

fixture `My fixture`
    .page `http://devexpress.github.io/testcafe/example/`;

test('Assertion with Selector', async t => {
    const developerNameInput = Selector('#developer-name');

    //this technique leads to unstable results. Avoid it.
    const developerName      = await Selector('#developer-name').value;
    //

    console.log(developerName);

    await t
        .wait(1000)
        .expect(developerNameInput.value).eql('')
        .typeText(developerNameInput, 'Peter')
        .expect(developerName).eql('Peter');
});
```

In this snippet, the `developerName` is initialized with the value of a Selector, but because of the `await` keyword, the value is calculated and assigned only once, when this line executes. This effectively disables the smart assertions query mechanism, which in this case leads to inconclusive results. This test fails.

To avoid this, initialize the variable with a `Selector API` promise. To do that, omit the `await` keyword:

```js
import { Selector } from 'testcafe';

fixture `My fixture`
    .page `http://devexpress.github.io/testcafe/example/`;

test('Assertion with Selector', async t => {
    const developerNameInput = Selector('#developer-name');
    const developerName      = Selector('#developer-name').value;

    console.log(developerName);

    await t
        .wait(1000)
        .expect(developerNameInput.value).eql('')
        .typeText(developerNameInput, 'Peter')
        .expect(developerName).eql('Peter');
});
```

The `developerName` is now initialized with a re-executable Selector API promise. When a test controller receives this promise, it enables the smart assertion query mechanism and TestCafe can wait for the value to update.

> The smart assertion query mechanism works with promises generated by TestCafe Selector API. Use the `await` keyword with user-created promises and promises generated by third-party libraries.

This rule applies to ClientFunctions in the same capacity.

The test below doesn't yield consistent results:

```js
import { Selector, ClientFunction } from 'testcafe';

fixture `My fixture`
    .page `http://devexpress.github.io/testcafe/example/`;

test('Assertion with ClientFunction', async t => {
    const getValue        = ClientFunction(() => document.getElementById('preferred-interface').value)
    const interfaceSelect = Selector('#preferred-interface');
    const interfaceOption = interfaceSelect.find('option');
    const value           = await getValue();


    await t
        .click(interfaceSelect)
        .click(interfaceOption.withText('JavaScript API'))
        .expect(value).eql('JavaScript API')
});
```

In this example, the client function obtains the value of a drop-down element. This value is then passed to the `t.expect` method. Since the client function is awaited when it's assigned to the variable, the value gets resolved instantly and never updates. The smart assertion query mechanism doesn't apply and the test fails.

To solve the issue, pass the client function without the `await` keyword:

```js
import { Selector, ClientFunction } from 'testcafe';

fixture `My fixture`
    .page `http://devexpress.github.io/testcafe/example/`;

test('Assertion with ClientFunction', async t => {
    const getValue = ClientFunction(() => document.getElementById('preferred-interface').value)

    const interfaceSelect = Selector('#preferred-interface');
    const interfaceOption = interfaceSelect.find('option');
    const value           =  getValue();

    await t
        .click(interfaceSelect)
        .click(interfaceOption.withText('JavaScript API'))
        .expect(value).eql('JavaScript API')
});
```

In this case, TestCafe applies the smart query mechanism and retries the assertion multiple times. This test responds to the changes that happen on the page and is more conclusive.

## Use of Page Objects

Use the Page Model in your tests. It helps you abstract the tested page into a single file that you can use to target page elements.

This approach improves the flexibility of your tests - if the UI changes, you only need to change one file to update all the references. Define common operations as your model's methods. Tests are then more readable and less brittle because there is no duplicate code.

The page model use is described in more detail in the [Page Model](../../guides/concepts/page-model.md) article.

A code example is available in the [testcafe-examples](https://github.com/DevExpress/testcafe-examples/tree/master/examples/use-page-model) repository.

## Use of Roles for Login

Handle authentication during your tests with [User Roles](../../guides/advanced-guides/authentication.md#user-roles). See the [Authentication] article for more in-depth information.

## File Structure

Follow these guidelines to keep your test structure manageable and "clean":

* If you use [page model](../../guides/concepts/page-model.md) for your tests (which is recommended), put all the page model files into one directory. If your application is divisible into logical chunks (components or subsystems), split up the associated page model objects into separate files.

* Use the page model to store Selectors and compound actions that are common in your app. For instance, put all actions that are necessary to perform a login into one reusable function.

> You can find an example of a page model in the [testcafe-examples](https://github.com/DevExpress/testcafe-examples/tree/master/examples/use-page-model) repository.

* Use the `.testcaferc.json` configuration file to fine-tune your tests, which can be useful in CI/CD systems. This file must be located in the root directory of the project. For more information, read the [Configuration File](../../reference/configuration-file.md) article.

* While it's technically possible to define multiple `fixture`s in a single file, it is not recommended. Define one fixture in every test file.
<!-- OR: -->
* Don't define multiple `fixture`s in a single file. While technically possible, this is not recommended.

* TestCafe tests are purely functional. As such, they should not be concerned about the implementation details and it is best to isolate them from production code. Keep your test files in a separate directory. You can name this directory appropriately (for instance, `tests`).

* In your test folder, group your tests into subfolders. These groups cover different subsystems of your application with tests.

* Any reused data (for example, large sets of expected values or forms inputs) is better stored in a directory of its own. Consider a descriptive folder name (for instance, `data`).

With all the suggestions applied, your project's file structure might look like this:

```sh
.
├── .testcaferc.json
└── tests
    ├── |- test_group1/
    │   └── |-test1.js
    │       └── |-test2.js
    ├── |- test_group2/
    │   └── |-test1.js
    │       └── |-test2.js
    ├── |- page_model/
    │   └── |- file1.js
    │       └── |- file2.js
    ├── |- helpers/
    │   └── |- helper1.js
    │       └── |- helper2.js
    └── |-data
```

## Cleanup With beforeEach / State Management

State management is an integral and important part of web testing. When your tests run, there are inevitably leftovers- database or local storage records, cache, or cookies. Your tests might require setup to run - like adding records to the database.

One common strategy is to set up with the previous test's `after` and `afterEach` hooks. While good for cleanup, these hooks create mutual dependence between your tests when used to set up for the following test. The success rate of a test is then influenced by a preceding one, which is not desirable.

Plus, if setup with `before` or `beforeEach` is unsuccessful, the associated test does not run, saving you time. If your setup with `after` and `afterEach` yields an error, the following test runs and probably fails.

To fulfill your test's state prerequisites, use the `before` and `beforeEach` hooks. Clean up with the `after` and `afterEach` hooks.

Use the `test.before` and `test.after` hooks to set the state that an individual test requires. Use the `fixture.beforeEach` and `fixture.afterEach` to set common state that is required across the board.

## E2E Tests Application

TestCafe is a tool built for end-to-end testing. Do not use it to perform non-functional testing (like performance or load testing). Such tests would not yield any conclusive results.

Write less E2E tests. Because end to end tests are slow by nature, their amount should be drastically lower than that of unit or integration tests. Test the general business logic of your application and abstain from rare use cases and edge scenarios.

## Selectors Strategy

The best ways to work with Selectors are covered in the [TestCafe Studio blog](https://community.devexpress.com/blogs/testcafe/archive/2020/06/10/testcafe-studio-v1-3-0-a-new-way-to-work-with-selectors.aspx#).

In general, follow these guidelines when you write the Selectors for your tests.

* Selectors shouldn’t be too specific. Otherwise, you might have to rewrite them after each page modification. For instance, `Selector(‘body’).find(‘div’).nth(5).find(‘p’).nth(3)` must be revised each time the number of elements on the page changes.

* Selectors shouldn't be too generic. Otherwise, they may return different elements after each markup change. For example, `Selector(‘div > button’)` can match multiple elements simultaneously.

* Selectors shouldn’t rely on element parameters that might change. For instance, `Selector('[style*="background-color: red"]')` uses a CSS style that changes frequently.

* Selectors should remain readable. Selectors should be easy to understand (by you or another developer) for as long as the test is maintained. For instance, it may be difficult to understand which element corresponds to the following selector: `Selector(‘div’).find(‘pre’).nextSibling(-1)`. In contrast, `Selector(‘#topContainer’).find(‘.child’).withText(‘Add item’)` is much easier to read.

* Selectors should reflect the user’s point of view. Since TestCafe supports end-to-end testing, it’s a good idea to build selectors that identify elements as an end-user would. For instance, `Selector(‘form’).find(‘[name=”btn-foo-123”]’)` might be stable, but it is written from the programmer’s perspective rather than from the user’s point of view.

Use custom attributes (like `data-testid`) that are solely devoted to item selection with TestCafe on your page. These attributes are unlikely to change during development and enable you to rewrite your Selectors rarer.

Group the Selectors in a page model. It increases the resilience of your tests and helps remove redundant code.

Use the Selectors extension plugins to work with frameworks. These extension allow you to create Selectors that are more native to every framework.
Such plugins are available for the following popular front-end frameworks: [Angular](https://github.com/DevExpress/testcafe-angular-selectors), [React](https://github.com/DevExpress/testcafe-react-selectors), [Vue](https://github.com/DevExpress/testcafe-vue-selectors).
